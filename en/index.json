[{"content":"","date":"2024 October 7","externalUrl":null,"permalink":"/tags/graphics/","section":"Tags","summary":"","title":"Graphics","type":"tags"},{"content":"","date":"2024 October 7","externalUrl":null,"permalink":"/tags/pbrt/","section":"Tags","summary":"","title":"Pbrt","type":"tags"},{"content":" 辐射度量学研究光的表示与传播, pbrt通过光谱而非RGB来表示颜色.\n辐射度量学 # 几何光学足够用于完成渲染任务, 主要损失在于无法模拟干涉与衍射. 几何光学具有以下特征.\n线性 能量守恒 无偏振 无荧光、磷光, 即光在某个波长下的表现与别的波长或时间下的表现无关 状态稳定, 即辐射亮度分布不随时间变化 基本量 # 能量 # 光源发出光子, 光子携带能量. 能量单位为焦耳(J), 特定波长的光子携带的能量如下式. 其中c为光速, h为Planck常量, \\(h = 6.626\\times 10^{-34} m^2 kg/s\\).\n$$ \\begin{equation} Q = \\frac{hc}{\\lambda} \\end{equation} $$\n辐射通量 # 辐射通量是(radiant flux)单位时间通过表面或空间的能量, 也可以被称作功率(power), 单位为J/s, 即瓦特(W). 辐射通量的定义见下式.\n$$ \\begin{equation} \\Phi = \\frac{dQ}{dt} \\end{equation} $$\n对于一个点光源, 辐射通量为以光源为球心的球面单位时间接收到的能量, 球的半径不影响辐射通量的值.\n辐射照度 \u0026amp; 辐射出射度 # 辐射照度(irradiance)是单位面积接收到的辐射通量, 与之对应的辐射出射度(radiant exitance)是单位面积发出的辐射通量, 他们的单位为\\(W/m^2\\).\n$$ \\begin{equation} E(p) = \\frac{d\\Phi}{dA} \\end{equation} $$\n同样以点光源为例, 以光源为球心的球面的辐射照度见下式.\n$$ \\begin{equation} E = \\frac{\\Phi}{4 \\pi r^2} \\end{equation} $$\n非垂直光线根据投影到光线垂直面的面积计算, \\(\\theta\\)为光线与法线的夹角.\n$$ \\begin{equation} E(p) = \\frac{d\\Phi \\cos\\theta}{dA} \\end{equation} $$\n辐射强度 # 辐射强度(radiant intensity)是单位立体角上的辐射通量, 它描述了光在方向上的分布, 但实际上只对点光源有意义.\n$$ \\begin{equation} I = \\frac{dQ}{d\\omega} \\end{equation} $$\n以点光源为球心的球面的辐射强度见下式.\n$$ \\begin{equation} I = \\frac{\\Phi}{4 \\pi} \\end{equation} $$\n辐射亮度 # 辐射亮度(radiance)是单位面积单位立体角上的辐射通量, 即将辐射照度进一步在每个方向上微分. 辐射亮度定义见下式, 其中\\(E_{\\omega}\\)代表与\\(\\omega\\)垂直的表面的辐射照度.\n$$ \\begin{equation} L(p, \\omega) = \\frac{E_{\\omega}(p)}{d\\omega} = \\frac{d^2\\Phi}{d\\omega dA^{\\perp}} = \\frac{d^2\\Phi}{d\\omega dA \\cos\\theta} \\end{equation} $$\n辐射亮度是渲染任务中最重要的辐射度量值, 别的值都可以由它积分得到, 且光在真空中传播时具有辐射亮度不变的特性.\n入射/出射辐射方程 # 辐射亮度在表面边界处未必是连续的, 表面某点上方与下方的极限值需要单独表示.\n$$ \\begin{equation} L^+(p,\\omega)=\\lim_{t \\to 0^+} L(p + t \\bold{n}_p, \\omega) \\end{equation} $$\n$$ \\begin{equation} L^-(p,\\omega)=\\lim_{t \\to 0^-} L(p - t \\bold{n}_p, \\omega) \\end{equation} $$\n为解决这一问题需要区分入射与出射辐射亮度.\n$$ \\begin{equation} L_i(p, \\omega) = \\begin{cases} L^+(p, -\\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026gt; 0\\\\ L^-(p, -\\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026lt; 0 \\end{cases} \\end{equation} $$\n$$ \\begin{equation} L_i(p, \\omega) = \\begin{cases} L^+(p, \\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026gt; 0\\\\ L^-(p, \\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026lt; 0 \\end{cases} \\end{equation} $$\n对于空间中不在表面上的某点, 辐射亮度是连续的.\n$$ \\begin{equation} L_o(p, \\omega) = L_i(p, -\\omega) = L(p, \\omega) \\end{equation} $$\n辐射光谱分布 # 辐射亮度可以进一步对波长微分以获取辐射光谱分布.\n$$ \\begin{equation} L_\\lambda = \\frac{dL}{d\\lambda} \\end{equation} $$\n亮度与光度 # 辐射度单位都有与之对应的光度单位, 这里只讨论最基本的亮度, 其余可以积分得到. 亮度表示人眼观察到的某个光谱功率分布的值, 定义如下. V为响应曲线即人眼对各个波长的光的敏感程度, 目前所使用的响应曲线是基于室内的实验得到的, 人眼在较暗环境对颜色的敏感度会降低, 因此无法很好的表示室外光照环境, 但仍然将其作为研究基准.\n$$ \\begin{equation} Y = \\int_{\\lambda} L_\\lambda(\\lambda) V(\\lambda) d\\lambda \\end{equation} $$\n辐射度量值的积分 # 从辐射亮度到辐射照度的积分如图所示, 其中\\(\\Omega\\)是法线上方半球覆盖的立体角, \\(\\theta\\)是立体角在单位球上对应的向量与法线的夹角.\n$$ \\begin{equation} E(p, \\bold{n}) = \\int_\\Omega L_i(p,\\omega) |\\cos\\theta| d\\omega \\end{equation} $$\n投影立体角上的积分 # 通过将单位球上的立体角投影到与法线垂直的平面可以转化为2D上的积分, 投影立体角与立体角满足Lambert定律. pbrt不会使用这种积分.\n$$ \\begin{equation} \\begin{aligned} d\\omega^{\\perp} \u0026amp;= d\\omega|cos\\theta|\\\\ E(p, \\bold{n}) \u0026amp;= \\int_{H^2(\\bold{n})} L_i(p,\\omega) d\\omega^{\\perp} \\end{aligned} \\end{equation} $$\n球面坐标系上的积分 # 利用单位球表面积可以将立体角微分转化为球面坐标系.\n$$ \\begin{equation} \\begin{aligned} d\\omega \u0026amp;= sin\\theta d\\theta d\\phi\\\\ E(p, \\bold{n}) \u0026amp;= \\int_0^{2\\pi} \\int_0^{\\frac{\\pi}{2}} L_i(p, \\theta, \\phi) cos\\theta sin\\theta d\\theta d\\phi \\end{aligned} \\end{equation} $$\n面积上的积分 # 这里的面积指的是立体角对应的入射光源处的面积, 这种转化可以方便度量面积光源对某一点的影响. \\(\\theta_o\\)是这个面积位于的平面与立体角对应的向量的夹角, r是这个表面与辐射照度度量点的距离.\n$$ \\begin{equation} \\begin{aligned} d\\omega \u0026amp;= \\frac{\\cos\\theta_o dA}{r^2}\\\\ E(p, \\bold{n}) \u0026amp;= \\int_{A} L cos\\theta_i \\frac{\\cos\\theta_o dA}{r^2} \\end{aligned} \\end{equation} $$\n表面反射 # 我们需要反射光线的光谱与方向分布来描述反射, 对于透明物体更复杂的次表面光线传播会影响出射光线的位置. 渲染任务中通过BRDF与BSSRDF来抽象这一过程, BRDF描述反射, BSSRDF在此基础上考虑透明物体.\nBRDF # BRDF代表双向反射分布函数, 它描述出射辐射亮度与入射辐射照度的关系.\n$$ \\begin{equation} f_r(p, \\omega_o, \\omega_i) = \\frac{dL_o(p, \\omega_o)}{dE(p, \\omega_i)} = \\frac{dL_o(p, \\omega_o)}{L_i(p, \\omega_i) \\cos\\theta_i d\\omega_i} \\end{equation} $$\nBRDF具有以下两点性质.\n互易性 $$ \\begin{equation} f_r(p, \\omega_o, \\omega_i) = f_r(p, \\omega_i, \\omega_o) \\end{equation} $$\n能量守恒 $$ \\begin{equation} \\int_\\Omega f_r(p, \\omega_o, \\omega_i) cos\\theta_i d\\omega_i \u0026lt; 1 \\end{equation} $$\nBRDF的半球-方向反射量可以用于表示入射光从所有方向均匀照射时某个方向的反射辐射亮度, 由于互易性也可以表示各个方向都具有相同的反射辐射亮度时对应的某个方向的入射辐射亮度.\n$$ \\begin{equation} \\rho_{hd}(\\omega_o) = \\int_\\Omega f_r(p, \\omega_o, \\omega_i) cos\\theta_i d\\omega_i \\end{equation} $$\nBRDF的半球-半球反射量代表入射光从所有方向均匀照射时的反射率.\n$$ \\begin{equation} \\rho_{hh} = \\int_\\Omega \\frac{\\int_\\Omega f_r(p, \\omega_o, \\omega_i) \\cos\\theta_i d\\omega_i}{\\int_\\Omega \\cos\\theta_i d\\omega_i} \\cos\\theta_o d\\omega_o \\end{equation} $$\nBTDF # BTDF代表双向透射分布函数, 与BRDF具有相似的形式, 它不遵循互易性.\nBSDF # 将BRDF与BTDF一起考虑时被称为BSDF, 即双向散射分布函数, 此时可以使用整个球面的入射光线计算出射方向的辐射亮度.\n$$ \\begin{equation} L_o(p, \\omega_o) = \\int_\\Theta f(p, \\omega_o, \\omega_i) L_i(p, \\omega_i) |\\cos\\theta_i| d\\omega_i \\end{equation} $$\nBSSRDF # BSSRDF代表双向散射表面反射分布函数, 时出射位置辐射亮度微分与入射位置辐射通量微分的比值, 用于表示光线在表面内部传播再后离开表面的现象, 即次表面散射.\n$$ \\begin{equation} S(p_o, \\omega_o, p_i, \\omega_i) = \\frac{dL_o(p_o, \\omega_o)}{d\\Phi(p_i, \\omega_i)} \\end{equation} $$\n出射辐射亮度需要计算在入射立体角与面积上的积分.\n$$ \\begin{equation} L_o(p_o, \\omega_o) = \\int_A \\int_\\Omega S(p_o, \\omega_o, p_i, \\omega_i) L_i(p_i, \\omega_i) |\\cos\\theta_i| d\\omega_i dA \\end{equation} $$\n自发光 # 达到一定温度后带电荷的原子的运动会导致不同波长的电磁辐射的释放, 室温下大部分物体只发射红外光.\n发光效率代表光源将多少功率转化为可见光, 单位lm/W. 分母可以是光源使用的功率或发出的所有波长上的功率, 若为使用功率, 则发光效率也代表光源将功率转化为电磁辐射的效率.\n此外, 光出射度与辐射照度在单位面积上的比值或出射亮度与辐射亮度在单位面积单位立体角上的比值也可以定义发光效率.\n$$ \\begin{equation} \\frac{\\int_\\lambda \\Phi_e(\\lambda) V(\\lambda) d\\lambda}{\\int_\\lambda \\Phi_i(\\lambda) d\\lambda} \\end{equation} $$\n黑体发光 # 黑体是一种理想发光光源, 可以最高效率的将功率转化为电磁辐射. 黑体这个名字是因为它几乎吸收所有波长的光线且不会反射它们.\nPlanck定律表达了黑体中波长、温度与辐射亮度的关系. h为Planck常数, c为光速, \\(k_b\\)为Boltzmann常数, \\(k_b = 1.3806488 \\times 10^{-23} J/K\\).\n$$ \\begin{equation} L_e(\\lambda, T) = \\frac{2hc^2}{\\lambda^5(e^{\\frac{hc}{\\lambda k_b T}} - 1)} \\end{equation} $$\n根据Kirchhoff定律, 非黑体的辐射与它吸收掉的辐射亮度相关, 利用半球-方向反射量可以得到下式.\n$$ \\begin{equation} {L_e}\u0026rsquo;(T, \\omega, \\lambda) = L_e(\\lambda, T)(1 - \\rho_{hd}(\\omega)) \\end{equation} $$\nStefan–Boltzmann定律给出了黑体的辐射出射度, \\(\\sigma\\)为Stefan–Boltzmann常数, \\(\\sigma = 5.67032 \\times 10^{-8} Wm^{-2}K^{-4}\\).\n$$ \\begin{equation} M(p) = \\sigma T^4 \\end{equation} $$\n若发光体发出的光谱分布与某个温度下黑体辐射发出的光谱分布类似, 此时该发光体以该温度作为色温. 通过光源发光最大处的波长与Wien位移定律可以确定当前的色温, b为Wien位移常数, \\(b = 2.897721 \\times 10^{-3}mK\\).\n$$ \\begin{equation} \\lambda_{\\max} = \\frac{b}{T} \\end{equation} $$\n通常5000K以上的色温为冷色, 2700-3000K为暖色.\n标准光源 # 标准光源是由CIE(国际照明委员会)定义的.\n标准光源A用于表示常见的白炽灯, 色温2856K.\n标准光源D用于描述日光的不同阶段, 一个权重用于表示受云量影响的黄蓝变化, 另一个表示受湿度影响的粉绿变化. D65与欧洲中午光照类似, 色温6504K, CIE推荐将它作为标准日光.\n标准光源F用于表示荧光.\n光谱分布 # 本节主要介绍pbrt中对光谱的抽象, pbrt只会存储可见光.\nconstexpr Float Lambda_min = 360, Lambda_max = 830; 光谱接口 # pbrt中的Spectrum继承自TaggedPointer来实现运行时多态并避免虚表开销, TaggedPointer中定义的函数子类必须实现.\nclass Spectrum : public TaggedPointer\u0026lt;ConstantSpectrum, DenselySampledSpectrum, PiecewiseLinearSpectrum, RGBAlbedoSpectrum, RGBUnboundedSpectrum, RGBIlluminantSpectrum, BlackbodySpectrum\u0026gt; { // ... }; Spectrum通过函数子返回特定波长下的功率. Dispatch用于确定分派函数到具体实现.\ninline Float Spectrum::operator()(Float lambda) const { auto op = [\u0026amp;](auto ptr) { return (*ptr)(lambda); }; return Dispatch(op); } Spectrum的实现必须提供MaxValue以保证高效的采样.\nFloat MaxValue() const; 通用光谱分布 # ConstantSpectrum # 返回常数密度.\nDenselySampledSpectrum # DenselySampledSpectrum存储\\([\\lambda_min, \\lambda_max]\\)下以1nm为区间采样到的功率. 这通过采样另一个Spectrum来实现. 显然这种查表方法会分配较大的内存.\nDenselySampledSpectrum(Spectrum spec, int lambda_min = Lambda_min, int lambda_max = Lambda_max, Allocator alloc = {}) : lambda_min(lambda_min), lambda_max(lambda_max), values(lambda_max - lambda_min + 1, alloc) { if (spec) for (int lambda = lambda_min; lambda \u0026lt;= lambda_max; ++lambda) values[lambda - lambda_min] = spec(lambda); } PiecewiseLinearSpectrum # PiecewiseLinearSpectrum定义少量插值点再插值得到各个波长下的密度, 对于部分区间比较平滑的分布这可以有效节省内存. 构造函数中会对插值点排序, 读取功率时PiecewiseLinearSpectrum找到对应区间并插值.\nFloat PiecewiseLinearSpectrum::operator()(Float lambda) const { // Handle _PiecewiseLinearSpectrum_ corner cases if (lambdas.empty() || lambda \u0026lt; lambdas.front() || lambda \u0026gt; lambdas.back()) return 0; // Find offset to largest _lambdas_ below _lambda_ and interpolate int o = FindInterval(lambdas.size(), [\u0026amp;](int i) { return lambdas[i] \u0026lt;= lambda; }); DCHECK(lambda \u0026gt;= lambdas[o] \u0026amp;\u0026amp; lambda \u0026lt;= lambdas[o + 1]); Float t = (lambda - lambdas[o]) / (lambdas[o + 1] - lambdas[o]); return Lerp(t, values[o], values[o + 1]); } BlackbodySpectrum # BlackbodySpectrum通过温度构造, 由于黑体光谱中功率过大采样时会通过最大功率值归一化.\nPBRT_CPU_GPU BlackbodySpectrum(Float T) : T(T) { // Compute blackbody normalization constant for given temperature Float lambdaMax = 2.8977721e-3f / T; normalizationFactor = 1 / Blackbody(lambdaMax * 1e9f, T); } PBRT_CPU_GPU Float operator()(Float lambda) const { return Blackbody(lambda, T) * normalizationFactor; } 嵌入光谱数据 # 部分常见的光谱分布可以直接通过字符串获取, 例如DenselySampledSpectrum类型的D65光源.\nSpectrum GetNamedSpectrum(std::string name); 采样光谱分布 # pbrt不提供复杂的积分计算功能, 但是会提供采样函数以执行Monte Carlo积分. 相比于传统的RGB渲染使用3个固定的波长, pbrt默认会采样4个不同的波长.\nSampledSpectrum # SampledSpectrum用于存储多个采样样本.\nexplicit SampledSpectrum(Float c) { values.fill(c); } SampledSpectrum(pstd::span\u0026lt;const Float\u0026gt; v) { for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) values[i] = v[i]; } pbrt提供bool重载使得采样值全为0时可以跳过计算.\nexplicit operator bool() const { for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) if (values[i] != 0) return true; return false; } pbrt支持逐样本数学计算, 例如加法.\nSampledSpectrum \u0026amp;operator+=(const SampledSpectrum \u0026amp;s) { for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) values[i] += s.values[i]; return *this; } SampledWavelengths # SampledWavelengths会存储每个样本的采样波长与概率密度, 与SampledSpectrum分开存储主要是因为SampledSpectrum在渲染过程中(尤其是GPU)需要大量创建, 分离出去可以减小对象的内存占用. 同时, 经过一段时间的开发后, pbrt的作者发现混合不同波长的计算并不会导致bug.\npstd::array\u0026lt;Float, NSpectrumSamples\u0026gt; lambda, pdf; 最基础的均匀采样如下.\nPBRT_CPU_GPU static SampledWavelengths SampleUniform(Float u, Float lambda_min = Lambda_min, Float lambda_max = Lambda_max) { SampledWavelengths swl; // Sample first wavelength using _u_ swl.lambda[0] = Lerp(u, lambda_min, lambda_max); // Initialize _lambda_ for remaining wavelengths Float delta = (lambda_max - lambda_min) / NSpectrumSamples; for (int i = 1; i \u0026lt; NSpectrumSamples; ++i) { swl.lambda[i] = swl.lambda[i - 1] + delta; if (swl.lambda[i] \u0026gt; lambda_max) swl.lambda[i] = lambda_min + (swl.lambda[i] - lambda_max); } // Compute PDF for sampled wavelengths for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) swl.pdf[i] = 1 / (lambda_max - lambda_min); return swl; } 散射可能导致不同波长的光具有不同的传播路径, pbrt支持只保留一个样本继续传播光线. 由于这些样本都遵循相同的分布, pbrt保留第0个样本即可. 类似于俄罗斯轮盘, 保留的样本的概率密度会乘上它在这个过程中存活的概率1 / NSpectrumSamples.\nPBRT_CPU_GPU void TerminateSecondary() { if (SecondaryTerminated()) return; // Update wavelength probabilities for termination for (int i = 1; i \u0026lt; NSpectrumSamples; ++i) pdf[i] = 0; pdf[0] /= NSpectrumSamples; } PBRT_CPU_GPU bool SecondaryTerminated() const { for (int i = 1; i \u0026lt; NSpectrumSamples; ++i) if (pdf[i] != 0) return false; return true; } 颜色 # 与光谱分布相比, 颜色会更多的考虑人眼的感知, 而非单纯的物理量. pbrt基于光谱分布而非颜色, 但是由于处理渲染图像输出、部分场景描述使用颜色来表示反射率等信息等原因, pbrt需要正确的处理颜色与光谱分布的转换.\n三刺激理论中使用三个光谱匹配函数计算得到的刺激值即可表示颜色, 这三个值构成了3D的色彩空间. 由于刺激值由积分得到, 在色彩空间中颜色的加法与缩放是允许的, 但是颜色之间并不能相乘, 这也是RGB渲染的问题之一. 匹配积分如下, S为光谱分布, \\(m_{1,2,3}\\)为三刺激理论中RGB对应的波长各自的匹配函数.\n$$ \\begin{equation} v_i = \\int_\\lambda S(\\lambda)m_i(\\lambda)d\\lambda \\end{equation} $$\nXYZ色彩空间 # CIE通过大量实验定义了RGB色彩空间, 由于有负值, 经过变换后得到XYZ色彩空间. XYZ色彩空间是设备无关的, 通常用于色彩空间转换的中介.\npbrt中使用Y归一化后的色彩值. Y上的匹配函数与用于计算亮度的光谱响应曲线成正比, 满足\\(V(\\lambda) = 683 Y(\\lambda)\\).\n$$ \\begin{equation} \\begin{aligned} x_\\lambda \u0026amp;= \\frac{\\int_\\lambda S(\\lambda)X(\\lambda)d\\lambda}{\\int_\\lambda Y(\\lambda)d\\lambda}\\\\ y_\\lambda \u0026amp;= \\frac{\\int_\\lambda S(\\lambda)Y(\\lambda)d\\lambda}{\\int_\\lambda Y(\\lambda)d\\lambda}\\\\ z_\\lambda \u0026amp;= \\frac{\\int_\\lambda S(\\lambda)Z(\\lambda)d\\lambda}{\\int_\\lambda Y(\\lambda)d\\lambda} \\end{aligned} \\end{equation} $$\npbrt支持获取X、Y、Z对应的DenselySampledSpectrum类型的光谱分布.\nnamespace Spectra { const DenselySampledSpectrum \u0026amp;X(); const DenselySampledSpectrum \u0026amp;Y(); const DenselySampledSpectrum \u0026amp;Z(); } pbrt支持通过计算积分将光谱分布转化为XYZ空间的颜色.\nXYZ SpectrumToXYZ(Spectrum s) { return XYZ(InnerProduct(\u0026amp;Spectra::X(), s), InnerProduct(\u0026amp;Spectra::Y(), s), InnerProduct(\u0026amp;Spectra::Z(), s)) / CIE_Y_integral; } SampledSpectrum可以通过Monte Carlo转化为XYZ(感觉样本不太够).\nXYZ SampledSpectrum::ToXYZ(const SampledWavelengths \u0026amp;lambda) const { // Sample the $X$, $Y$, and $Z$ matching curves at _lambda_ SampledSpectrum X = Spectra::X().Sample(lambda); SampledSpectrum Y = Spectra::Y().Sample(lambda); SampledSpectrum Z = Spectra::Z().Sample(lambda); // Evaluate estimator to compute $(x,y,z)$ coefficients SampledSpectrum pdf = lambda.PDF(); return XYZ(SafeDiv(X * *this, pdf).Average(), SafeDiv(Y * *this, pdf).Average(), SafeDiv(Z * *this, pdf).Average()) / CIE_Y_integral; } xyY色彩空间 # 颜色可以被分离为亮度(lightness, 不是luminance)与色度(chroma), 色度通过投影到\\(x+y+z=1\\)平面即可得到, 投影后为舌状图.\n$$ \\begin{equation} \\begin{aligned} x \u0026amp;= \\frac{x_\\lambda}{x_\\lambda + y_\\lambda + z_\\lambda}\\\\ y \u0026amp;= \\frac{y_\\lambda}{x_\\lambda + y_\\lambda + z_\\lambda}\\\\ Y \u0026amp;= x_\\lambda + y_\\lambda + z_\\lambda \\end{aligned} \\end{equation} $$\nRGB颜色 # 每个显示器都具有不同的RGB响应曲线 在RGB响应曲线已知的情况下, 可以利用XYZ空间得到色彩变换矩阵. 下式以红色为例展示了这一转换的过程.\n$$ \\begin{equation} \\begin{aligned} r \u0026amp;= \\int_\\lambda R(\\lambda)S(\\lambda)d\\lambda\\\\ \u0026amp;= \\int_\\lambda R(\\lambda)(x_\\lambda X(\\lambda) + y_\\lambda Y(\\lambda) + z_\\lambda Z(\\lambda)) d\\lambda\\\\ \u0026amp;= x_\\lambda \\int_\\lambda R(\\lambda) X(\\lambda) d\\lambda + y_\\lambda \\int_\\lambda R(\\lambda) Y(\\lambda) d\\lambda + z_\\lambda \\int_\\lambda R(\\lambda) Z(\\lambda) d\\lambda \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} \\begin{bmatrix} r\\\\ g\\\\ b \\end{bmatrix} = \\begin{pmatrix} \\int_\\lambda R(\\lambda) X(\\lambda)d\\lambda \u0026amp; \\int_\\lambda R(\\lambda) Y(\\lambda)d\\lambda \u0026amp; \\int_\\lambda R(\\lambda) Z(\\lambda)d\\lambda\\\\ \\int_\\lambda G(\\lambda) X(\\lambda)d\\lambda \u0026amp; \\int_\\lambda G(\\lambda) Y(\\lambda)d\\lambda \u0026amp; \\int_\\lambda G(\\lambda) Z(\\lambda)d\\lambda\\\\ \\int_\\lambda B(\\lambda) X(\\lambda)d\\lambda \u0026amp; \\int_\\lambda B(\\lambda) Y(\\lambda)d\\lambda \u0026amp; \\int_\\lambda B(\\lambda) Z(\\lambda)d\\lambda \\end{pmatrix} \\begin{bmatrix} x_\\lambda\\\\ y_\\lambda\\\\ z_\\lambda \\end{bmatrix} \\end{equation} $$\nRGB色彩空间 # 某种响应曲线对应下三原色(R为当前响应曲线下的(1, 0, 0)对应的颜色, G、B同理)的色度在色度图上构成的三角形就是RGB色彩空间. 该色彩空间下三色值为1的颜色在色度图上的色度为白点, 由于人眼感知的问题白色通常在短波具有更高的功率, 一般选用D65作为白点.\nRGBColorSpace的构造需要提供白色光照对应的光谱分布, 以便于后续用户通过RGB指定光源颜色. 同时由于R、G、B的色度已知, 可以得到Y=1下它们对应的XYZ颜色. 结合白色光照的XYZ颜色, 此时只有三原色的亮度信息是缺失的, 即下式中的常数, 可以在构造函数中计算出来. 以XYZ空间为中转可以实现快速的颜色空间转换.\n$$ \\begin{equation} \\begin{bmatrix} w_x \\\\ w_y \\\\ w_z \\\\ \\end{bmatrix} = \\begin{pmatrix} r_x \u0026amp; g_x \u0026amp; b_x\\\\ r_y \u0026amp; g_y \u0026amp; b_y\\\\ r_z \u0026amp; g_z \u0026amp; b_z \\end{pmatrix} \\begin{pmatrix} c_x \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; c_y \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; c_z \\end{pmatrix} \\begin{bmatrix} 1\\\\ 1\\\\ 1 \\end{bmatrix} \\end{equation} $$\nRGBColorSpace::RGBColorSpace(Point2f r, Point2f g, Point2f b, Spectrum illuminant, const RGBToSpectrumTable *rgbToSpec, Allocator alloc) : r(r), g(g), b(b), illuminant(illuminant, alloc), rgbToSpectrumTable(rgbToSpec) { // Compute whitepoint primaries and XYZ coordinates XYZ W = SpectrumToXYZ(illuminant); w = W.xy(); XYZ R = XYZ::FromxyY(r), G = XYZ::FromxyY(g), B = XYZ::FromxyY(b); // Initialize XYZ color space conversion matrices SquareMatrix\u0026lt;3\u0026gt; rgb(R.X, G.X, B.X, R.Y, G.Y, B.Y, R.Z, G.Z, B.Z); XYZ C = InvertOrExit(rgb) * W; XYZFromRGB = rgb * SquareMatrix\u0026lt;3\u0026gt;::Diag(C[0], C[1], C[2]); RGBFromXYZ = InvertOrExit(XYZFromRGB); } 标准色彩空间 # 常见的色彩空间如下, 它们在pbrt中都被预定义了.\nsRGB, 90年代为Web标准颜色而开发, 目前应用最广泛 DCI-P3, 为数字影视行业开发, 色域广于sRGB, 应用逐渐扩大(比如我写这篇文章的mba就默认P3色域) Rec2020, 为UHDTV开发, 色域广于DCI-P3 ACES2065-1, 色彩空间范围超过色度图, 可用于长期数据存储, 不受行业发展的影响. 使用光谱渲染的原因 # RGB色彩空间中颜色相乘不等于对应的光谱相乘, 例如用RGB表示入射光与反射率时得到的漫反射颜色是不正确的. 提到的另一点强调光谱提供的波长信息可以更方便的对色散、薄膜干涉、微表面的衍射等现象建模, 这一点我感觉更重要.\n波长样本数的选择 # 由于每个像素会生成多个样本, 通常采样到不同的波长, 每个样本并不需要采样过多的波长. 经过数据分析简单场景下采样32个波长可以达到最优的效果, 而复杂场景下8个样本可以达到最优. Monte Carlo下需要每个像素生成多个不同光线路径的样本来减小损失, 且Monte Carlo带来的损失要大于波长样本数造成的损失, 因此pbrt采用默认4个样本.\nRGB转光谱 # 光谱转RGB的过程是确定的, 但由于同色异谱等原因RGB转光谱要相对困难. 由于现有3D工具通常以RGB参数或纹理存储反射率、自发光等信息, RGB转光谱是一项重要的任务.\n转换过程需要考虑3种光谱分布.\n发光光谱, 用于自发光光源, RGB取值范围是无界的 反射光谱, 用于描述可吸收光照的表面的反射率, 由于能量守恒RGB位于[0,1]中 无界光谱, 自发光之外的其他无界值, 如折射率与介质散射 首先解决反射光谱转换, 它需要满足以下三点性质.\n一致性, 转换得到光谱可以通过一般方法转换为当前的RGB 光滑性, RGB值的微小变动应该也对应光谱的微小变动 能量守恒 pbrt使用2次多项式对光谱建模, 利用sigmoid函数保持能量守恒. 由于sigmoid函数的特征, 反射率为0与1需要特殊处理.\n$$ \\begin{equation} \\begin{aligned} s(x) \u0026amp;= \\frac{1}{2} + \\frac{x}{2 \\sqrt{1 + x^2}}\\\\ S(\\lambda) \u0026amp;= s(c_2 \\lambda^2 + c_1 \\lambda + c_0)\\\\ \\end{aligned} \\end{equation} $$\npbrt通过数值优化来求解参数, 优化方程中加入白点是为了保证在三原色上具有均匀分布. pbrt选用CIE76\\(\\Delta E\\)作为优化范式, 利用Gauss-Newton方法求解.\n$$ \\begin{equation} (c_0^*, c_1^*, c_2^*) = \\underset{c_0,c_1,c_2} {\\operatorname{argmin}} \\left\\Vert \\begin{bmatrix} r\\\\ g\\\\ b \\end{bmatrix} - \\int \\begin{bmatrix} R(\\lambda)\\\\ G(\\lambda)\\\\ G(\\lambda) \\end{bmatrix} S(\\lambda, c_0, c_1, c_2) W(\\lambda) d\\lambda \\right\\Vert \\end{equation} $$\n为了使插值更平滑, 根据对色彩空间中参数梯度变化, pbrt根据RGB哪个值最大来决定要查的表. 例如当R最大时会把颜色做如下的转换. x、y在表中的位置是线性的, z因为在0与1附近变化最大, 是非线性的, 需要通过二分找到在表中的位置.\n$$ \\begin{equation} (x,y,z)=(\\frac{g}{r}, \\frac{b}{r}, r) \\end{equation} $$\n此时我们可以定义RGBAlbedoSpectrum, 构造函数通过颜色来得到反射率分布.\nRGBAlbedoSpectrum::RGBAlbedoSpectrum(const RGBColorSpace \u0026amp;cs, RGB rgb) { rsp = cs.ToRGBCoeffs(rgb); } 无界光谱 # 无界光谱定义在RGBUnboundedSpectrum中, 通过将最大值归一化为\\(\\frac{1}{2}\\)来提升参数优化的效果.\nRGBUnboundedSpectrum::RGBUnboundedSpectrum(const RGBColorSpace \u0026amp;cs, RGB rgb) { Float m = std::max({rgb.r, rgb.g, rgb.b}); scale = 2 * m; rsp = cs.ToRGBCoeffs(scale ? rgb / scale : RGB(0, 0, 0)); } Float RGBUnboundedSpectrum::operator()(Float lambda) const { return scale * rsp(lambda); } Float RGBUnboundedSpectrum::MaxValue() const { return scale * rsp.MaxValue(); } 自发光光谱 # 自发光光谱定义在RGBIlluminantSpectrum中, 在RGBUnboundedSpectrum的基础上, 自发光光源在取值时会乘上当前色彩空间的标准光源在该波长下的值, 这是为了模拟人眼对颜色的自适应, 或者说白平衡.\nRGBIlluminantSpectrum::RGBIlluminantSpectrum(const RGBColorSpace \u0026amp;cs, RGB rgb) : illuminant(\u0026amp;cs.illuminant) { Float m = std::max({rgb.r, rgb.g, rgb.b}); scale = 2 * m; rsp = cs.ToRGBCoeffs(scale ? rgb / scale : RGB(0, 0, 0)); } Float RGBIlluminantSpectrum::operator()(Float lambda) const { if (!illuminant) return 0; return scale * rsp(lambda) * (*illuminant)(lambda); } 结语 # 这章对辐射度量学与光谱渲染进行了详细的介绍, 反射模型相关内容也有涉及, 由于它直接影响渲染过程中光线传播显示的颜色, 后面第9章会有单独的章节细化这些内容.\nRGB渲染只能说是光谱渲染的一个简化版本, 不过考虑到现有GPU架构, 光谱渲染应用在实时渲染应该还有一段距离, 积分的计算有点为难shader了.\n另外, TaggedPointer这种显示指明子类的多态实现属实有点丑陋, 但不借助反射的话应该也没什么好方法了.\n","date":"2024 October 7","externalUrl":null,"permalink":"/render/1728265562044-pbrt-v4-episode-4/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. IV: 辐射与光","type":"render"},{"content":"","date":"2024 October 7","externalUrl":null,"permalink":"/tags/rendering/","section":"Tags","summary":"","title":"Rendering","type":"tags"},{"content":"","date":"2024 October 7","externalUrl":null,"permalink":"/render/","section":"Rendering","summary":"","title":"Rendering","type":"render"},{"content":" 对于所有图形学任务, 几何物体的表示都是设计的核心部分. 这一章主要介绍pbrt中几何物体接口的设计.\n坐标系 # 左手系, y朝上.\nn元基类 # pbrt中n元类都继承自n元基类, n元基类是带有子类的模板类, 这样可以更方便的实现子类的模板方法. Tuple3定义如下.\ntemplate \u0026lt;template \u0026lt;typename\u0026gt; class Child, typename T\u0026gt; class Tuple3 { // ... }; pbrt并未将tuple长度模板化, 这样可以支持类似v.x的访问方式, 当然长度模板化后可以通过下标访问, 如v[i], pbrt也是支持的.\npbrt实现的方法都会限制输入输出类型与子类一致, 以加法重载为例, 参数与返回值都限制为Child类. 在pbrt的设计中, 子类也是模板类, 例如Vector3\u0026lt;T\u0026gt;. 包含不同类型参数的子类是可以运算的, 返回值由模板推导得到.\ntemplate \u0026lt;typename U\u0026gt; auto operator+(Child\u0026lt;U\u0026gt; c) const -\u0026gt; Child\u0026lt;decltype(T{} + U{})\u0026gt; { return {x + c.x, y + c.y, z + c.z}; } 向量 # 向量类支持计算长度, 长度类型通过TupleLength类提供, 其定义如下.\ntemplate \u0026lt;typename T\u0026gt; struct TupleLength { using type = Float; }; template \u0026lt;\u0026gt; struct TupleLength\u0026lt;double\u0026gt; { using type = double; }; 长度计算方法如下. 这里使用using是为了通过自定义sqrt来支持不被std::sqrt支持的类型.\ntemplate \u0026lt;typename T\u0026gt; T LengthSquared(Vector3\u0026lt;T\u0026gt; v) { return Sqr(v.x) + Sqr(v.y) + Sqr(v.z); } template \u0026lt;typename T\u0026gt; auto Length(Vector3\u0026lt;T\u0026gt; v) -\u0026gt; typename TupleLength\u0026lt;T\u0026gt;::type { using std::sqrt; return sqrt(LengthSquared(v)); } 支持长度计算后Normalize的支持就顺水推舟了, 这里通过auto来保证归一化后具有正确的类型, 例如Vector3\u0026lt;int\u0026gt;转化为Vector3\u0026lt;Float\u0026gt;.\ntemplate \u0026lt;typename T\u0026gt; auto Normalize(Vector3\u0026lt;T\u0026gt; v) { return v / Length(v); } 为避免std::acos在向量接近平行处的精度损失, pbrt采用如下方式计算夹角, 参数需要是单位向量.\ntemplate \u0026lt;typename T\u0026gt; Float AngleBetween(Vector3\u0026lt;T\u0026gt; v1, Vector3\u0026lt;T\u0026gt; v2) { if (Dot(v1, v2) \u0026lt; 0) return Pi - 2 * SafeASin(Length(v1 + v2) / 2); else return 2 * SafeASin(Length(v2 - v1) / 2); } pbrt支持施密特正交的计算.\ntemplate \u0026lt;typename T\u0026gt; Vector3\u0026lt;T\u0026gt; GramSchmidt(Vector3\u0026lt;T\u0026gt; v, Vector3\u0026lt;T\u0026gt; w) { return v - Dot(v, w) * w; } pbrt支持叉乘, DifferenceOfProducts可以为a*b-c*d保留更高的精度.\ntemplate \u0026lt;typename T\u0026gt; Vector3\u0026lt;T\u0026gt; Cross(Vector3\u0026lt;T\u0026gt; v, Vector3\u0026lt;T\u0026gt; w) { return {DifferenceOfProducts(v.y, w.z, v.z, w.y), DifferenceOfProducts(v.z, w.x, v.x, w.z), DifferenceOfProducts(v.x, w.y, v.y, w.x)}; } pbrt支持通过一个Vector3来生成一个坐标系, 其余两个基向量如下. 为避免\\(1 + v_z = 0\\), 式中的符号根据\\(v_z\\)的符号修改.\n$$ \\left( 1 - \\frac{v_x^2}{1 + v_z}, -\\frac{v_x v_z}{1 + v_z}, -v_x \\right) $$ $$ \\left( -\\frac{v_x v_y}{1 + v_z}, 1 - \\frac{v_y^2}{1 + v_z}, -v_y \\right) $$\ntemplate \u0026lt;typename T\u0026gt; void CoordinateSystem(Vector3\u0026lt;T\u0026gt; v1, Vector3\u0026lt;T\u0026gt; *v2, Vector3\u0026lt;T\u0026gt; *v3) { Float sign = pstd::copysign(Float(1), v1.z); Float a = -1 / (sign + v1.z); Float b = v1.x * v1.y * a; *v2 = Vector3\u0026lt;T\u0026gt;(1 + sign * Sqr(v1.x) * a, sign * b, -sign * v1.x); *v3 = Vector3\u0026lt;T\u0026gt;(b, sign + Sqr(v1.y) * a, -v1.y); } 点 # 对点进行减法可以返回向量, 点之间的距离通过向量的长度计算.\ntemplate \u0026lt;typename U\u0026gt; auto operator-(Point3\u0026lt;U\u0026gt; p) const -\u0026gt; Vector3\u0026lt;decltype(T{} - U{})\u0026gt; { return {x - p.x, y - p.y, z - p.z}; } template \u0026lt;typename T\u0026gt; auto DistanceSquared(Point3\u0026lt;T\u0026gt; p1, Point3\u0026lt;T\u0026gt; p2) { return LengthSquared(p1 - p2); } 法线 # 法线可以由平面上两个不平行的切线向量的叉乘得到, 法线可以不归一化. 与向量类相比, 法线类不允许叉乘、相加等操作.\n法线通常需要在平面上方, 即某个向量对应的半球上, pbrt中通过FaceForward修改法线方向.\ntemplate \u0026lt;typename T\u0026gt; Normal3\u0026lt;T\u0026gt; FaceForward(Normal3\u0026lt;T\u0026gt; n, Vector3\u0026lt;T\u0026gt; v) { return (Dot(n, v) \u0026lt; 0.f) ? -n : n; } 光线 # 光线类定义了一个射线, 包括一个Point3f类型的原点与Vector3f类型的射线方向.\npbrt通过函数子计算光线上某点, 即\\(o+td\\).\nPoint3f operator()(Float t) const { return o + d * t; } Ray拥有时间成员time, 用于特定时间的采样动态场景.\nRay同时拥有介质成员medium, 用于光线传播体渲染的计算.\n光线微分 # 光线微分继承自光线, 主要用于获取\\(x\\)与\\(y\\)方向相邻样本对应的光线的信息, 以计算光线对应的面积来实现纹理采样的抗锯齿.\n包围盒 # pbrt使用轴对称包围盒(AABB), 支持2D包围盒Bounds2与3D包围盒Bounds3, 同样是通过模板类支持顶点为不同类型的包围盒.\n包围盒的构造函数为赋值为当前类型的极大值与极小值.\nBounds3() { T minNum = std::numeric_limits\u0026lt;T\u0026gt;::lowest(); T maxNum = std::numeric_limits\u0026lt;T\u0026gt;::max(); pMin = Point3\u0026lt;T\u0026gt;(maxNum, maxNum, maxNum); pMax = Point3\u0026lt;T\u0026gt;(minNum, minNum, minNum); } 包围盒支持通过下标访问最小顶点与最大顶点.\nPoint3\u0026lt;T\u0026gt; operator[](int i) const { return (i == 0) ? pMin : pMax; } Point3\u0026lt;T\u0026gt; \u0026amp;operator[](int i) { return (i == 0) ? pMin : pMax; } Corner函数用于通过bit flag来返回顶点, 0对应最小点, 1对应最大点.\nPoint3\u0026lt;T\u0026gt; Corner(int corner) const { return Point3\u0026lt;T\u0026gt;((*this)[(corner \u0026amp; 1)].x, (*this)[(corner \u0026amp; 2) ? 1 : 0].y, (*this)[(corner \u0026amp; 4) ? 1 : 0].z); } 通过比较某点到最小点与最大点的距离可以得出该点与包围盒的最短距离, 距离类型为TupleLength.\ntemplate \u0026lt;typename T, typename U\u0026gt; auto DistanceSquared(Point3\u0026lt;T\u0026gt; p, const Bounds3\u0026lt;U\u0026gt; \u0026amp;b) { using TDist = decltype(T{} - U{}); TDist dx = std::max\u0026lt;TDist\u0026gt;({0, b.pMin.x - p.x, p.x - b.pMax.x}); TDist dy = std::max\u0026lt;TDist\u0026gt;({0, b.pMin.y - p.y, p.y - b.pMax.y}); TDist dz = std::max\u0026lt;TDist\u0026gt;({0, b.pMin.z - p.z, p.z - b.pMax.z}); return Sqr(dx) + Sqr(dy) + Sqr(dz); } template \u0026lt;typename T, typename U\u0026gt; auto Distance(Point3\u0026lt;T\u0026gt; p, const Bounds3\u0026lt;U\u0026gt; \u0026amp;b) { auto dist2 = DistanceSquared(p, b); using TDist = typename TupleLength\u0026lt;decltype(dist2)\u0026gt;::type; return std::sqrt(TDist(dist2)); } pbrt支持通过AABB对角线构建包围球.\nvoid BoundingSphere(Point3\u0026lt;T\u0026gt; *center, Float *radius) const { *center = (pMin + pMax) / 2; *radius = Inside(*center, *this) ? Distance(*center, pMax) : 0; } 球体 # 球体可以用于高效的构建多个方向向量的包围结构.\n立体角 # 以锥体的顶点作为球心作球面, 这个面积与半径平方的比值即为立体角, 一个球体对应的立体角为\\(4\\pi\\). 立体角可以用于表示物体投影到单位圆上的投影面积, 根据球面积分单位立体角具有如下的映射方式, 其中\\(\\theta\\)为极角, \\(\\phi\\)为水平角.\n$$ \\begin{equation} d\\bold{l} = \\sin \\theta d\\theta d\\phi \\end{equation} $$\n球面多边形 # 球形多边形即为某个多面锥体在单位球上的投影面积.\n球面多边形每个角的角度是这个顶点对应的两个锥体上的平面形成的二面角, 球面角超是球面多边形内角和超过平面多边形面积的部分, 它与球面多边形的面积相等.\n$$ \\begin{equation} E = \\sum_{i=1}^{n} \\theta_i - (n - 2)\\pi \\end{equation} $$\n在pbrt中, 利用球面三角恒等式将球面角超的计算化简为如下形式, 以避免过多使用反三角函数损失精度.\n$$ \\begin{equation} \\tan\\left(\\frac{1}{2} A\\right) = \\frac{\\bold{a} \\cdot (\\bold{b} \\times \\bold{c})}{1 + (\\bold{a} \\cdot \\bold{b}) + (\\bold{a} \\cdot \\bold{c}) + (\\bold{b} \\cdot \\bold{c})} \\end{equation} $$\npbrt中球面四边形仍然采用直接计算二面角的方式来计算.\n球面参数化 # 球面坐标系 # $$ \\begin{equation} \\begin{aligned} x \u0026amp;= r \\sin\\theta \\cos\\phi\\\\ y \u0026amp;= r \\sin\\theta \\sin\\phi\\\\ z \u0026amp;= r \\cos\\theta \\end{aligned} \\end{equation} $$\n逆运算如下.\n$$ \\begin{equation} \\begin{aligned} \\theta \u0026amp;= \\arccos z\\\\ \\phi \u0026amp;= \\arctan \\frac{y}{x} \\end{aligned} \\end{equation} $$\n\\(\\phi\\)对应的三角函数也可以快速计算.\n$$ \\begin{equation} \\begin{aligned} \\cos\\theta \u0026amp;= \\frac{x}{r \\sin\\theta}\\\\ \\sin\\theta \u0026amp;= \\frac{y}{r \\sin\\theta} \\end{aligned} \\end{equation} $$\n八面体编码 # 由于浮点精度, 球面坐标系的两极比赤道具有更高的精度, 八面体压缩得到更均匀的分布. 利用八面体压缩可以将Vector3f展开到二维平面, pbrt将每个元素用2个字节存储, 只需要4个字节即可存储一个单位向量.\n八面体压缩收集计算绝对值向量投影到\\(x+y+z=1\\)平面, 再投影到\\(xy\\)平面得到压缩向量\\((x, y)\\), 上半球面的向量只需要设置符号, 下半球面向量先计算其对应上半球面绝对值向量的压缩值关于\\(x+y=1\\)的对称值再去修改符号.\nOctahedralVector(Vector3f v) { v /= std::abs(v.x) + std::abs(v.y) + std::abs(v.z); if (v.z \u0026gt;= 0) { x = Encode(v.x); y = Encode(v.y); } else { x = Encode((1 - std::abs(v.y)) * Sign(v.x)); y = Encode((1 - std::abs(v.x)) * Sign(v.y)); } } pbrt将八面体压缩值最终存储在整数中.\nstatic uint16_t Encode(Float f) { return pstd::round(Clamp((f + 1) / 2, 0, 1) * 65535.f); } 解压缩过程如下.\nexplicit operator Vector3f() const { Vector3f v; v.x = -1 + 2 * (x / 65535.f); v.y = -1 + 2 * (y / 65535.f); v.z = 1 - (std::abs(v.x) + std::abs(v.y)); if (v.z \u0026lt; 0) { v.x = (1 - std::abs(v.y)) * Sign(v.x); v.y = (1 - std::abs(v.x)) * Sign(v.y); } return Normalize(v); } 等面积映射 # 等面积映射保证球面上任意区域的面积与参数化后的空间中对应的面积的比例相似.\n令\\((u,v)\\in[-1,1]\\), \\(u\\ge0\\)且\\(u-|v|\\ge0\\)时等面积映射的极坐标见下式. 此时\\(\\phi\\in[-\\frac{\\pi}{4}, \\frac{\\pi}{4}]\\), 其它区域的映射具有相似的形式.\n$$ \\begin{equation} \\begin{aligned} r \u0026amp;= u\\\\ \\phi \u0026amp;= \\frac{\\pi}{4}\\frac{v}{u} \\end{aligned} \\end{equation} $$\n极坐标到球面坐标的等面积映射如下.\n$$ \\begin{equation} \\begin{aligned} x \u0026amp;= (\\cos\\phi) r \\sqrt{2-r^2}\\\\ y \u0026amp;= (\\sin\\phi) r \\sqrt{2-r^2}\\\\ z \u0026amp;= 1 - r^2 \\end{aligned} \\end{equation} $$\npbrt中等面积映射的解压缩遵循如下步骤.\n取\\((u, v)\\)的绝对值即映射到第一象限来简化计算 根据与象限对角线的距离来计算\\(r\\) 计算出对应的极坐标, 并且由于旋转需要\\(\\phi+\\frac{\\pi}{4}\\) 根据\\(u,v\\)位于\\(x+y=1\\)的哪一侧确定z的方向. 等面积映射到球面坐标, 根据\\(u,v\\)的符号确定最终映射值的符号 压缩过程基本是解压缩的逆过程.\n方向包围结构 # 方向包围结构用于快速获取对应的立体角范围, 典型应用场景是剔除掉没有射向物体方向的光线.\npbrt在DirectionCone中通过锥体的中心轴方向与锥体扩散角的余弦定义了包围锥.\npbrt支持通过包围盒与锥体顶点计算出对应的包围锥体, 这通过计算顶点到包围盒对应的包围球的切线扩散角来实现.\nPBRT_CPU_GPU inline DirectionCone BoundSubtendedDirections(const Bounds3f \u0026amp;b, Point3f p) { // Compute bounding sphere for _b_ and check if _p_ is inside Float radius; Point3f pCenter; b.BoundingSphere(\u0026amp;pCenter, \u0026amp;radius); if (DistanceSquared(p, pCenter) \u0026lt; Sqr(radius)) return DirectionCone::EntireSphere(); // Compute and return _DirectionCone_ for bounding sphere Vector3f w = Normalize(pCenter - p); Float sin2ThetaMax = Sqr(radius) / DistanceSquared(pCenter, p); Float cosThetaMax = SafeSqrt(1 - sin2ThetaMax); return DirectionCone(w, cosThetaMax); } 变换 # 图形学中通常利用四维矩阵进行三维空间中物体的变换.\n齐次坐标 # 通过4D的齐次坐标可以只用一个矩阵表示变换, 要求第4个元素不为0, 前三个元素除以第四个元素可以得到3D空间上的值.\n变换类定义 # Transform类存储SquareMatrix\u0026lt;4\u0026gt;类型的矩阵m与逆矩阵mInv. 为避免相同的矩阵占有过多内存, pbrt通过InternCache类构建哈希表, 相同的变换使用同一块存储在哈希表中的内存.\n基础操作 # 变换初始化时为单位变换, 即对角线为1其余为0. 对于奇异矩阵即非可逆矩阵, mInv会被初始化为NaN.\n平移 # 通过设置矩阵第四列可以实现平移.\n缩放 # 通过设置对角线上前三个元素可以实现缩放.\nx,y,z旋转 # 通过设置另外两个轴的元素可以实现顺时针旋转. 由于y轴下x到z是逆时针的, 所以符号不同.\n任意轴旋转 # 任意轴旋转通过Rodrigues公式实现, 遵循以下步骤.\n将旋转轴转为单位向量 向量投影到旋转轴顶端对应的平面 投影向量与旋转轴叉乘, 二者组成坐标系 在该坐标系下执行旋转, 最后乘上向量长度 通过获取x,y,z轴旋转后的结果可以得到旋转矩阵.\n$$ \\begin{equation} \\begin{aligned} \\bold{v_c} \u0026amp;= \\bold{a}||\\bold{v}|| \\cos\\alpha = \\bold{a}(\\bold{v} \\cdot \\bold{a})\\\\ \\bold{v_1} \u0026amp;= \\bold{v} - \\bold{v_c}\\\\ \\bold{v_2} \u0026amp;= \\bold{v_1} \\times \\bold{a}\\\\ \\bold{v\u0026rsquo;} \u0026amp;= \\bold{v_c} + \\bold{v_1}\\cos\\theta + \\bold{v_2}\\sin\\theta \\end{aligned} \\end{equation} $$\n从一个向量旋转到另一个 # 给定两个向量, 我们可以通过叉乘来生成旋转坐标轴, 但是在两个向量接近平行时这种方法不再稳定, 且需要昂贵的三角函数参与.\npbrt通过Householder矩阵实现反射.\n$$ \\begin{equation} \\begin{aligned} H(\\bold{v}) \u0026amp;= I - 2 \\frac{\\bold{v} \\bold{v}^T}{\\bold{v} \\cdot \\bold{v}}\\\\ H(\\bold{v})\\bold{x} \u0026amp;= \\bold{x} - 2 \\frac{\\bold{v}}{||\\bold{v}||}(\\frac{\\bold{v}}{||\\bold{v}||} \\cdot \\bold{x}) \\end{aligned} \\end{equation} $$\npbrt默认参数是归一化的, 通过向量的数值选择距离两个向量相对较远的轴作为反射中间轴. 这里0.72使用是因为\\(0.72\\approx\\frac{\\sqrt{2}}{2}\\).\nVector3f refl; if (std::abs(from.x) \u0026lt; 0.72f \u0026amp;\u0026amp; std::abs(to.x) \u0026lt; 0.72f) refl = Vector3f(1, 0, 0); else if (std::abs(from.y) \u0026lt; 0.72f \u0026amp;\u0026amp; std::abs(to.y) \u0026lt; 0.72f) refl = Vector3f(0, 1, 0); else refl = Vector3f(0, 0, 1); 最终旋转矩阵如下式. 由于这里f、t、r都是归一化的, Householder相当于根据等腰三角形的长边来反射.\n$$ \\begin{equation} R = H(\\bold{r} - \\bold{t}) H(\\bold{r} - \\bold{f}) \\end{equation} $$\n观察矩阵 # 给出摄像机位置、目标位置、上方向即可很快通过叉乘构建出坐标系.\n应用变换 # 点 \u0026amp; 向量 # 直接矩阵计算.\n法线 # 法线需要考虑不均匀缩放带来的影响. 令t为变换前与法线正交的切线, T为一般的变换, S为正确的变换, ‘代表变换后的结果, 可得下式.\n$$ \\begin{equation} \\begin{aligned} 0 \u0026amp;= (\\bold{n}\u0026rsquo;)^T \\bold{t}\u0026rsquo;\\\\ \u0026amp;= (S\\bold{n})^T (T\\bold{t})\\\\ \u0026amp;= \\bold{n}^T S^T T \\bold{t} \\end{aligned} \\end{equation} $$\n由于\\(\\bold{n}^T\\bold{t}=0\\), 故\\(S=(M^{-1})^T\\).\n光线 # 应用变换在光线起始点与光线方向.\n包围盒 # 应用变换在包围盒中心点与包围盒范围(即对角线的一半, 与方向类似).\n变换的组合 \u0026amp; 坐标系的变换 # 都是线性代数的基础知识.\n交互 # 渲染任务中需要处理各类物体的交互, 例如光线与表面的交互影响反射方向、光线与介质的交互影响radiance. pbrt中定义了Interaction类来对各类交互进行抽象, 构造函数如下.\nInteraction(Point3fi pi, Normal3f n, Point2f uv, Vector3f wo, Float time) : pi(pi), n(n), uv(uv), wo(Normalize(wo)), time(time) {} 交互都需要存储点, 例如光线与表面的交点. pbrt通过Point3i中的Interval来表示交点的数值误差.\n部分交互需要存储方向, 例如光线的方向, pbrt将其存储在wo中.\n由于部分交互并不关心是表面交互还是介质交互, 表面相关的值为0时就将其忽略, 所以pbrt将法线与表面uv这些表面参数存储在基类中以简化交互的实现. pbrt支持通过法线判断当前为表面交互还是介质交互.\nbool IsSurfaceInteraction() const { return n != Normal3f(0, 0, 0); } bool IsMediumInteraction() const { return !IsSurfaceInteraction(); } Interaction类中通过MediumInterface来表示介质间的交互, 并存储某个点的介质.\nconst MediumInterface *mediumInterface = nullptr; Medium medium = nullptr; 表面交互 # SurfaceInteraction会额外存储点和法线在u、v上的偏导数, 法线是根据点的偏导数的叉乘计算的, u、v的偏导数可以不是正交的.\npbrt在SurfaceInteraction类中定义了shading成员来存储着色后的值, 例如normal mapping会修改mesh实际的法线. shading用几何物体上的实际值来初始化.\nstruct { Normal3f n; Vector3f dpdu, dpdv; Normal3f dndu, dndv; } shading; 部分着色过程需要用到mesh的三角形编号, 这会被存储在SurfaceInteraction中.\nint faceIndex = 0; pbrt中闭合形状的法线是指向外侧的, 如果着色过程中生成的法线指向内侧, pbrt支持通过传入参数决定几何法线和着色法线哪个需要改变方向.\nshading.n = ns; if (orientationIsAuthoritative) n = FaceForward(n, shading.n); else shading.n = FaceForward(shading.n, n); 介质交互 # MediumInteraction在Interaction基础上添加了PhaseFunction.\n结语 # 这部分并未涉及具体几何形状的存储方式, 主要介绍渲染过程中用到的各类三维空间中的工具, 具体几何形状的内容会在第6章详细介绍.\n","date":"2024 October 5","externalUrl":null,"permalink":"/render/1728092546418-pbrt-v4-episode-3/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. III: 几何与变换","type":"render"},{"content":" 随机模拟, 或者说Monte Carlo方法, 是很常用的统计学方法, 渲染任务往往通过大量采样来渲染方程积分结果. pbrt中基本都采用无偏采样器, SPPMIntegrator是个例外. Monte Carlo通用形式如下.\n$$ \\begin{equation} F \\approx F_n = \\frac{1}{n} \\sum_{i=1}^n \\frac{f(X_i)}{p(X_i)} \\end{equation} $$\n这部分可以结合北大的 统计计算, 想起来本科时还上过这个课, 一点都不记得, 很惭愧.\n效率优化 # 分层抽样 # 将样本空间划分为多份, 每个空间被称为“层”, 采样时从各层中分别采样. 每层的Monte Carlo积分值可用下式表示.\n$$ \\begin{equation} F_i = \\frac{1}{n} \\sum_{j=1}^{n_i} \\frac{f(X_{i,j})}{p(X_{i,j})} \\end{equation} $$\n由于分层, 各层的概率积分不再为1, 将第i层的概率积分值表示为\\(v_i\\). 此时\\(F_i\\)期望值的证明见下式.\n$$ \\begin{equation} \\begin{aligned} E(F_i) \u0026amp;= \\frac{1}{n_i} n_i E(\\frac{f(X_{i,j})}{p(X_{i,j})})\\\\ \u0026amp;= \\mu_i\\\\ \u0026amp;= \\int_{\\Lambda_i} \\frac{f(x)}{p(x)} \\frac{p(x)}{v_i} dx\\\\ \u0026amp;= \\frac{1}{v_i} \\int_{\\Lambda_i} f(x) dx \\end{aligned} \\end{equation} $$\n由此可得最终的Monte Carlo表示方式.\n$$ \\begin{equation} F = \\sum_{i=1}^n v_i F_i \\end{equation} $$\n分层抽样主要用于降低方差, 每一层的方差见下式.\n$$ \\begin{equation} \\begin{aligned} Var(F_i) \u0026amp;= \\frac{n_i}{n_i^2} Var(\\frac{f(X_{i,j})}{p(X_{i,j})})\\\\ \u0026amp;= \\frac{1}{n_i}\\sigma_{i}^2 \\end{aligned} \\end{equation} $$\n令层数为m, 可以得出Monte Carlo的方差为下式.\n$$ \\begin{equation} \\begin{aligned} Var(F) \u0026amp;= Var(\\sum_{i=1}^m v_i F_i)\\\\ \u0026amp;= \\sum_{i=1}^m Var(v_i F_i)\\\\ \u0026amp;= \\sum_{i=1}^m \\frac{v_i^2\\sigma_i^2}{n_i} \\end{aligned} \\end{equation} $$\n令每层的样本数与每层的样本范围线性正相关, 此时每层\\(n_i=nv_i\\), 方差可以简化为下式.\n$$ \\begin{equation} Var(F)=\\frac{1}{n} \\sum_{i=1}^m v_i\\sigma_i^2 \\end{equation} $$\n对于非分层抽样, 可以看作是先随机选择一个层, 然后在该层中随机抽样出一个值, 此时抽样出的值\\(X_i\\)是依赖于选择到该层\\(I_i\\)的概率的. 此时积分的方差可以表示为下式.\n$$ \\begin{equation} \\begin{aligned} Var(F) \u0026amp;= \\frac{1}{n^2} \\sum_{i=1}^n Var(\\frac{f(X_i)}{P(X_i)})\\\\ \u0026amp;= \\frac{1}{n} Var(\\frac{f(X)}{P(X)}) \\end{aligned} \\end{equation} $$\n记\\(G=\\frac{f(X)}{P(X)}\\), 后续证明会用到如下的性质.\n$$ \\begin{equation} Var(G) = E(Var(G|I)) + Var(E(G|I)) \\end{equation} $$\n已知落入某层的概率即为该层在积分中的占比, 即\\(p(I = v) = v\\), 此时可以解出下式.\n$$ \\begin{equation} \\begin{aligned} E(Var(G|I)) \u0026amp;= \\sum_{i=1}^m Var(G|I=v_i)p(I=v_i)\\\\ \u0026amp;= \\sum_{i=1}^m \\sigma_i^2 v_i \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} Var(E(G|I)) \u0026amp;= \\sum_{i=1}^m (E(G|I=v_i) - E(E(G|I)))^2 p(I=v_i)\\\\ \u0026amp;= \\sum_{i=1}^m (\\mu_i - E(G))^2 v_i\\\\ \u0026amp;= \\sum_{i=1}^m (\\mu_i - Q)^2 v_i \\end{aligned} \\end{equation} $$\n将上式结合即可得到非分层抽样下的方差.\n$$ \\begin{equation} \\begin{aligned} Var(F) \u0026amp;= \\frac{1}{n} Var(G) \u0026amp;= \\frac{1}{n} \\sum_{i=1}^m (\\sigma_i^2 v_i + (\\mu_i - Q)^2 v_i) \\end{aligned} \\end{equation} $$\n可以看到非分层抽样的方差是大于等于分层抽样的方差的, 但是需要估计每一层的积分和. 同时分层数量也随维度指数增加, 通常只会在某一维上增加层数, 其它维度只有少量的层.\n重要性抽样 # 重要性抽样的核心思想就是让采样点的分布与积分函数相似, 此时样本会集中在函数值较大处, 有利于积分计算的收敛. 根据Jensen不等式可以得到下式, 当且仅当\\(\\frac{|f(X)|}{p(X)}\\)时成立.\n$$ \\begin{equation} \\begin{aligned} Var(\\frac{f(X)}{p(X)}) \u0026amp;= E(\\frac{f^2(X)}{p^2(X)}) - E^2(\\frac{f(X)}{p(X)})\\\\ \u0026amp;\\geq E^2(\\frac{|f(X)|}{p(X)}) - F^2 \\end{aligned} \\end{equation} $$\n对于分层抽样, 可以在每一层内部使用重要性抽样来进一步降低方差. 但显然想找到这样的分布函数是比较困难的.\n多重重要性抽样 # 积分式往往是由多个方程组成的, 我们可以分别选取与各个方程相似的密度函数, 这被称为多重重要性抽样, 简称MIS, 其一般形式如下式, 若为无偏估计则其中\\(\\sum_{i=1}^n \\omega_i(x) = 1\\) 且当\\(p_i(x) = 0\\)时\\(\\omega_i(x) = 0\\).\n$$ \\begin{equation} F=\\sum_{i=1}^n \\frac{1}{n_i} \\sum_{j=1}^{n_i} \\omega_i(X_{i,j})\\frac{f(X_{i,j})}{p_i(X_{i,j})} \\end{equation} $$\n我们希望与函数形状相似的分布具有更高的权重, 我们通过平衡启发式来达到这一目的.\n$$ \\begin{equation} \\omega_i(x) = \\frac{n_i p_i(x)}{\\sum_{j=1}^{n} n_j p_j(x)} \\end{equation} $$\n实际使用中幂启发式也是常用的形式, pbrt中幂设置为2.\n$$ \\begin{equation} \\omega_i(x) = \\frac{(n_i p_i(x))^\\beta}{\\sum_{j=1}^{n} (n_j p_j(x))^\\beta} \\end{equation} $$\n令选择分布\\(p_i(x)\\)的概率为\\(q_i\\), 此时可以得到单抽样模型. pbrt说这也是无偏的, 没说怎么证明.\n$$ \\begin{equation} F=\\frac{w_i(X)}{q_i}\\frac{f(X)}{p_i(X)} \\end{equation} $$\n对于MIS, 若其中一个采样分布与函数式接近, MIS会略微提高方差.\nMIS补偿 # MIS中每个概率分布都可以单独用于Monte Carlo, 函数值非0处只需要有一个概率分布不为0即可. 将分布密度较小处调整为0可以进一步缩小方差, 这被称为MIS补偿, 一种补偿方法如下.\n$$ \\begin{equation} p\u0026rsquo;(x) = \\frac{\\max(0, p(x) - \\delta)}{\\int_\\Omega max(0, p(x) - \\delta) dx} \\end{equation} $$\n俄罗斯轮盘 # 俄罗斯轮盘主要用于跳过函数值较小处的计算, 提高效率的同时可以保持无偏. 选择概率值\\(q\\)与常数\\(c\\), 可以得到下式. \\(c\\)通常为0.\n$$ \\begin{equation} F\u0026rsquo; = \\begin{cases} \\frac{F-qc}{1-q} \u0026amp; \\xi \u0026gt; q\\\\ c \u0026amp; \\text{otherwise} \\end{cases} \\end{equation} $$\n可以证明它是无偏的.\n$$ \\begin{equation} E(F\u0026rsquo;) = (1 - q)\\frac{E(F) - qc}{1 - q} + qc = E(F) \\end{equation} $$\n分离法 # 对于多维积分, 在样本数不变的情况下提高某个维度的样本数被称为分离法, 可以提高采样效率.\n$$ \\begin{equation} \\begin{aligned} \u0026amp;\\frac{1}{nm} \\sum_{i=1}^{nm} \\frac{f(X_i, Y_i)}{p_x(X_i) p_y(Y_i)}\\\\ =\u0026gt;\u0026amp;\\frac{1}{n} \\sum_{i=1}^n \\frac{1}{m} \\sum_{j=1}^m \\frac{f(X_i, Y_{i, j})}{p_x(X_i) p_y(Y_{i, j})} \\end{aligned} \\end{equation} $$\n例如在渲染中, 初始光线方向与相交后的反射方向都是随机变量, 我们可以只发射一次然后对反射方向多次采样来减少初次发射的开销.\n逆变换法 # 逆变换法可以通过采样容易构造的均匀分布来得到选定分布中的样本. 在分布已知的情况下, 将均匀分布采样结果输入该分布CDF的逆函数即可获取该分布中的样本. 这里主要证明逆变换法得到的采样结果遵循选定的分布.\n$$ \\begin{equation} P(P_F^{-1}(U) \u0026lt; x) = P(U \u0026lt; P_F(x)) = P_F(x) \\end{equation} $$\n分布变换 # 为了使得变换后的CDF具有如下性质, 我们要求\\(Y=T(X)\\)在每个维度上都单调递增.\n$$ \\begin{equation} P(Y(X)) = P(X) \\end{equation} $$\n此时通过求导可以得到二者PDF的关系, 其中\\(|J_T(x)|\\)代表Jacobi矩阵的行列式.\n$$ \\begin{equation} p_T(y)=p_T(T(x))=\\frac{p(x)}{|J_T(x)|} \\end{equation} $$\n","date":"2024 October 2","externalUrl":null,"permalink":"/render/1727858234035-pbrt-v4-episode-2/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. II: 随机模拟","type":"render"},{"content":"国庆开坑pbrt-v4的学习, 主要想深入了解光谱渲染. pbrt是与pbr-v4这本书配套的渲染器实现. 大部分书只是有配套代码, 而非一个完整的开源软件, pbrt这一点确实不错.\n编译环境 # pbrt-v4的依赖项都写在git submodule里了, 安装cmake即可. 对于nix-darwin用户, 由于编译器不会包含impure的系统framework路径, 需要在flake中手动指定, 否则glfw会编不过.\n{ description = \u0026#34;pbrt devenv\u0026#34;; inputs.nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixpkgs-24.05-darwin\u0026#34;; outputs = { nixpkgs , ... }: let system = \u0026#34;aarch64-darwin\u0026#34;; pkgs = import nixpkgs { inherit system; }; in { devShells.\u0026#34;${system}\u0026#34;.default = pkgs.mkShell { packages = [] ++ (with pkgs; [ clang lldb cmake ]) ++ (with pkgs.darwin.apple_sdk.frameworks; [ Cocoa IOKit CoreFoundation Kernel ]); shellHook = \u0026#39;\u0026#39; exec zsh \u0026#39;\u0026#39;; }; }; } 程序结构 # pbrt-v4基于C++17, 遵循面向对象的结构(会有继承地狱的样子), 针对光线、相机、BxDF等设计了抽象接口. pbrt-v4在设计上同时支持CPU/GPU光追, 支持CUDA与OptiX(显然darwin跑不了GPU, 毕竟23年的M3/A17才加上光追单元).\n运行流程 # 读取参数 解析描述文件 创建场景 integrator渲染循环 一气呵成的结构, 这里把renderer类称作integrator是因为渲染的核心流程就是求解渲染方程这一积分式, 这个名字还是比较贴切的.\n场景中的物体通过Primitive存储, 其中包含Material与Shape, 整个场景都包含在aggregate这一Primitive的实现中. 除aggregate之外场景只会存储lights, pbrt将平行光这类无限距离的光源单独存储, 只考虑这些光源可以更高效的渲染出可以接受的结果. 部分光源需要获取场景的包围盒, 因此pbrt给光源添加了preprocess接口.\nIntegrator接口需要实现Render与Intersect函数. Intersect有一种特殊实现叫做IntersectP, 只考虑是否相交而非具体的相交信息, 通常用于阴影. 作者说这种命名方式来自于Lisp, 其实国庆本来想学SICP的, 可惜时间就这么点.\nImageTileIntegrator # ImageTileIntegrator实现了Integrator, 支持将渲染图像划分为tile来实现并行渲染, 该类的构造函数需要额外的Camera与Sampler, 最终渲染结果存储在Camera中的Film成员. ImageTileIntegrator渲染时会分为多次wave, 每次wave的sample数逐步增加, 以此来实现渲染图像的预览.\n由于需要分配大量小内存来存储光线求解过程中的表面散射信息, pbrt通过自定义的ScratchBuffer来提高效率. 该类通过address offset的递增来快速分配相同大小的内存, 但是释放时只能通过将offset设置为0来释放当前所有分配的小内存, 也因此每个thread都需要创建ScratchBuffer, pbrt通过ThreadLocal模板类来实现.\n虚函数EvaluatePixelSample负责调用Sampler生成采样点供Integrator发射光线. 由于需要存储像素位置等状态, Sampler也通过ThreadLocal来定义. 在每个采样点渲染完成后, 会调用ScratchBuffer::Reset()来统一释放光追过程中分配的内存.\nRayIntegrator # RayIntegrator继承自ImageTileIntegrator(继承链开始变长了, 有种不好的预感), 在划分tile的基础上通过实现EvaluatePixelSample提供光线路径相关的功能.\n不同于传统的RGB渲染, RayIntegrator会在有效光谱范围中均匀采样, 每个sample都具有不同的波长, 默认是4个sample. 按我的理解, RGB就是只有三个固定波长的特殊形式的光谱渲染, 这里是更一般化的形式. RGB是可以三种波长一次计算的, 通用光谱渲染应该是要各个波长单独走光追流程了, 开销更大.\nCamera接口负责实现GenerateRay与GenerateRayDifferential, GenerateRay负责生成光线, GenerateRayDifferential负责生成相邻像素的光线信息以支持抗锯齿. CameraSample用于存储采样点在Film的位置. 它还会包含用于非小孔成像的镜头位置以及样本权重, 主要用于实现非pinhole的camera. 这一章给出的示例图是有景深效果的, pbrt应该实现了透镜镜头.\nRayIntegrator声明了Li这一虚函数用于实现具体的光照过程, 返回值为SampledSpectrum, 即样本的光谱信息. 该函数的参数包含VisibleSurface指针, 对于需要存储物体表面几何信息的Film这会返回它所需要的信息.\nRandomWalkIntegrator # 上面的都是虚类, 这里终于到具体实现了, 继承吼可怕.\nRandomWalkIntegrator主要实现了Monte Carlo方法, 通过物体的自发光与用BSDF得到的反射光线返回的结果得到渲染样本. 这里没有考虑直接光源, 自然会缺少有阴影与高光项, 光线也几乎不会与场景里的光源相交. 按照作者的说法, 那张满是噪点的示例图是每个像素4096个样本的结果, 这里也可以窥见AI降噪缘何如此火热.\n代码使用 # 命名 # 类名采用大写开头camel case, 变量采用小写开头.\n指针 or 引用 # 可变的或者可以传入空值的用指针, 否则const引用.\n标准库 # pbrt尽量使用标准库来降低代码复杂度, 部分标准库的重新实现会放在pstd namespace下.\n内存分配 # pbrt使用std::pmr::polymorphic_allocator来分配对象, 这是c++17提供的内存管理器接口, 用于实现多态的内存管理器. 相比于new\u0026amp;delete, 通过函数调用显示分配内存方便pbrt收集内存分配情况并提高小对象分配效率, 同时也便于分配GPU可见的内存.\n动态分派 # pbrt不使用虚表来实现多态, 而是通过TaggedPointer来存储函数与类型信息, 主要是为了减少复杂场景下大量虚表指针带来的性能开销以及实现GPU代码的多态.\n代码优化 # 这里主要提到了pbrt会优化访存速度, 并未设计具体实现.\n调试 \u0026amp; 错误处理 # pbrt中包含大量单元测试来保证代码的正确性, 运行时通过assertion来报错. pbrt会报告具体哪个像素与样本发生错误, 并支持只重新执行这个样本来查找错误. pbrt中的类提供了toString类来实现类似于运行时反射的功能.\n多线程 # pbrt为了保证效率, 绝大部分数据结构都是非线程安全的, 基本也都是每个线程单独创建自己需要的或者是只读的.\n绝大部分工具类是线程安全的, 例如Camera、 BxDF. Light::Preprocess是非线程安全的, 因为场景的构建过程为单线程. Sampler是非线程安全的, 这是考虑到光线采样过程中的性能开销, 因此每个线程都会创建Sampler.\n所有全局函数都是线程安全的.\n可扩展性 # 教学用的软件可扩展性肯定要保证的, 后面我应该也会尝试实现新的渲染方法.\nBugs # (去pbrt.org提issue吧)\nPBR历史 # 这里我就不总结了, 按我自己的经历来说, 首次接触是在RTR4, 现在在实时渲染上GGX+Smith应该是绝对主流了.\n结语 # 这一章主要介绍pbrt的代码结构, 这对于后续的阅读与代码练习是很有意义的. 至于为什么要着重强调这次加入了GPU光追, 答案很显然: 2/3的作者是nVidia的. 后续章节这两天应该就会更新.\n","date":"2024 October 1","externalUrl":null,"permalink":"/render/1727763944120-pbrt-v4-episode-1/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. I: 代码实现","type":"render"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/cross-compilation/","section":"Tags","summary":"","title":"Cross-Compilation","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/darwin/","section":"Tags","summary":"","title":"Darwin","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/macos/","section":"Tags","summary":"","title":"Macos","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/nix/","section":"Tags","summary":"","title":"Nix","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/nix-darwin/","section":"Tags","summary":"","title":"Nix-Darwin","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/unix/","section":"Unix","summary":"","title":"Unix","type":"unix"},{"content":"Nix这边对交叉编译的支持是很不错的, 但它是用来通过stdenv编译nixpkgs中的某个包的. 浙软的高级操作系统Lab需要直接使用交叉编译器, 那么只能通过在环境中导入stdenv.cc来实现, 这一步是有坑的. Homebrew可以一键安装, 但我又无法抛弃通过nix develop来实现便捷的环境配置, 因此相关的解决方案今天记录在这里.\n系统配置 # Nix本身具有良好的交叉编译环境支持, 对于已经记录在lib.systems.examples中的系统, 可以通过pkgs.pkgsCross.[cross-env]直接导入. lib.systems.examples的部分定义如下:\n# ... { # ... aarch64-embedded = { config = \u0026#34;aarch64-none-elf\u0026#34;; libc = \u0026#34;newlib\u0026#34;; rustc.config = \u0026#34;aarch64-unknown-none\u0026#34;; }; # ... gnu64 = { config = \u0026#34;x86_64-unknown-linux-gnu\u0026#34;; }; gnu64_simplekernel = gnu64 // platforms.pc_simplekernel; # see test/cross/default.nix gnu32 = { config = \u0026#34;i686-unknown-linux-gnu\u0026#34;; }; # ... } 这里最核心的部分就是config里这个字符串, 如果没有指定libc等别的要求, 通常可以用这个字符串替代attribute set, 例如:\n# the following are the same system = \u0026#34;aarch64-darwin\u0026#34;; system = { config = \u0026#34;aarch64-darwin\u0026#34;; }; 系统字符串具有特定的格式:\narch-vendor-kernel-abi 该字符串可以包含其中的任意部分, 例如aarch64-darwin就只包含arch-kernel. nixpkgs会利用lib.systems.elaborate来补充省略的部分, 并扩展为一个attribute set来提供更多功能. 例如aarch64-darwin会被扩展为如下形式, 这里截取部分属性作为例子:\n{ # ... config = \u0026#34;aarch64-apple-darwin\u0026#34;; darwinArch = \u0026#34;arm64\u0026#34;; darwinMinVersion = \u0026#34;11.0\u0026#34;; darwinMinVersionVariable = \u0026#34;MACOSX_DEPLOYMENT_TARGET\u0026#34;; darwinPlatform = \u0026#34;macos\u0026#34;; darwinSdkVersion = \u0026#34;11.0\u0026#34;; # ... gcc = { ... }; hasSharedLibraries = true; is32bit = false; is64bit = true; isAarch = true; isAarch32 = false; isAarch64 = true; # ... isBigEndian = false; isCompatible = «lambda @ /Users/tsssni/nixpkgs/lib/systems/default.nix:82:22»; isDarwin = true; # ... isMacOS = true; isMacho = true; # ... libc = \u0026#34;libSystem\u0026#34;; linker = \u0026#34;cctools\u0026#34;; # ... system = \u0026#34;aarch64-darwin\u0026#34;; ubootArch = \u0026#34;arm64\u0026#34;; uname = { ... }; useAndroidPrebuilt = false; useLLVM = false; useiOSPrebuilt = false; } 可以看到系统信息得到了充分的补全, 给用户提供了足够的系统信息, 例如通过(if localSystem.isDarwin)即可判断当前交叉编译环境下的本地系统是否为Darwin.\n自定义系统 # 并非所有交叉编译环境都会在pkgsCross中提供, pkgsCross中的命名方式可能也不符合用户的要求. 例如Homebrew中提供的aarch64-embedded环境的前缀为aarch64-elf, Nix中为aarch64-none-elf. 两者编译出的二进制文件并无区别, 且都是符合gcc交叉编译器的传统命名方式的, 但是部分代码中可能直接指定编译器前缀, 例如我的OS Lab中使用的Unikraft的make文件中有如下定义:\n# set cross compile ifeq ($(call qstrip,$(CONFIG_CROSS_COMPILE)),) ifeq ($(HOSTOSENV),Darwin) CONFIG_CROSS_COMPILE := aarch64-elf- else ifneq ($(CONFIG_UK_ARCH),$(HOSTARCH)) CONFIG_CROSS_COMPILE := aarch64-linux-gnu- endif endif endif 显然它默认我们使用Homebrew(Nix-Darwin确实挺难用的\u0026hellip;), 可以参考Unikraft官方的Homebrew Tap. 此时我们可以自定义系统设置来解决该问题, 例如在我的NUR仓库参照aarch64-embedded定义了如下系统:\n{ aarch64-elf = { config = \u0026#34;aarch64-elf\u0026#34;; libc = \u0026#34;newlib\u0026#34;; rustc.config = \u0026#34;aarch64-unknown-none\u0026#34;; }; } 这会导致Nix编译出的cc-wrapper前缀的变化, 只有在交叉编译环境中才会使用带前缀的cc. 经过我的测试, aarch64-embedded并未存储于nixos cache中, 和aarch64-elf一样需要本地编译, 因此使用体验是相同的. 交叉编译器前缀与系统配置字符串是相同的, 影响交叉编译器前缀的代码如下:\n# pkgs/build-support/cc-wrapper/default.nix # ... let targetPrefix = optionalString (targetPlatform != hostPlatform) (targetPlatform.config + \u0026#34;-\u0026#34;); in: # ... 交叉编译stdenv # 想要在配置中导入自定义交叉编译系统对应的nixpkgs环境, 重新import nixpkgs即可. 例如我这里只需要在develop环境中使用交叉编译器, 可以这样编写mkShell:\nlet aarch64-elf-pkgs = import nixpkgs { localSystem = system; crossSystem = tsssni-lib.systems.aarch64-elf; }; in pkgs.mkShell { packages = [ aarch64-elf-pkgs.stdenv.cc ]; }; 然而此时编译出的aarch64-elf-gcc会报-iframework unknown option错误, 这是darwin平台特有的选项, 对于交叉编译器该选项是不支持的, 显然这是因为cc-wrapper在darwin平台上自动导入这个flag了. 开始我以为这是nixpkgs的bug, 但从cc-wrapper的setup-hook.sh可以看出, 这个flag是只在targetSystem.isDarwin时才会引入.\n归根结底, 这还是由于在一个环境中引入了不同的系统配置导致的. 除了aarch64-elf-gcc之外我还安装了其他darwin-native的包, 因此nix develop会导入darwin-native环境中cc-wrapper的setup-hooks. cc-wrapper是依赖setup-hooks中设置的NIX_CFLAGS_COMPILEF来引入flag的, darwin-native-gcc需要的flags也会被aarch64-elf-gcc使用, 从而导致报错.\n由于这些-isystem和-iframework对于我的OS LAB来说是无关紧要的, 此时在mkShell时可以参照simavr的setup-hook来把-iframework过滤掉, simavr中-isystem也是被过滤掉的, 这里我也一并过滤:\npkgs.mkShell { # ... shellHook = \u0026#39;\u0026#39; # Because it’s getting called from a Darwin stdenv, aarch64-elf-cc will pick up on # Darwin-specific flags, and it will barf and die on -iframework in # particular. Strip them out, so simavr can compile its test firmware. cflagsFilter=\u0026#39;s|-F[^ ]*||g;s|-iframework [^ ]*||g;s|-isystem [^ ]*||g;s| *| |g\u0026#39; # The `CoreFoundation` reference is added by `linkSystemCoreFoundationFramework` in the # Apple SDK’s setup hook. Remove that because aarch64-elf-cc will fail due to file not found. ldFlagsFilter=\u0026#39;s|/nix/store/[^-]*-apple-framework-CoreFoundation[^ ]*||g\u0026#39; # Make sure the global flags aren’t accidentally influencing the platform-specific flags. export NIX_CFLAGS_COMPILE=\u0026#34;$(sed \u0026#34;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_CFLAGS_COMPILE\u0026#34;)\u0026#34; export NIX_LDFLAGS=\u0026#34;$(sed \u0026#34;$ldFlagsFilter;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_LDFLAGS\u0026#34;)\u0026#34; exec zsh \u0026#39;\u0026#39;; } Flake # 此时交叉编译器就可以正常使用了, 完整的flake如下:\n{ description = \u0026#34;OSLAB devenv\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixpkgs-24.05-darwin\u0026#34;; tsssni-nur = { url = \u0026#34;github:tsssni/NUR\u0026#34;; inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; }; }; outputs = { nixpkgs, tsssni-nur, ... }: let system = \u0026#34;aarch64-darwin\u0026#34;; in { devShells.\u0026#34;${system}\u0026#34;.default = let pkgs = import nixpkgs { inherit system; }; tsssni-lib = tsssni-nur.lib; tsssni-pkgs = tsssni-nur.pkgs { localSystem = system; }; aarch64-elf-pkgs = import nixpkgs { localSystem = system; crossSystem = tsssni-lib.systems.aarch64-elf; }; in pkgs.mkShell { packages = [] ++ (with pkgs; [ clang lldb qemu coreutils-prefixed cmake ]) ++ (with tsssni-pkgs.gnu; [ ggrep gmake gsed ]) ++ (with aarch64-elf-pkgs; [ stdenv.cc ]); shellHook = \u0026#39;\u0026#39; # Because it’s getting called from a Darwin stdenv, aarch64-elf-cc will pick up on # Darwin-specific flags, and it will barf and die on -iframework in # particular. Strip them out, so simavr can compile its test firmware. cflagsFilter=\u0026#39;s|-F[^ ]*||g;s|-iframework [^ ]*||g;s|-isystem [^ ]*||g;s| *| |g\u0026#39; # The `CoreFoundation` reference is added by `linkSystemCoreFoundationFramework` in the # Apple SDK’s setup hook. Remove that because aarch64-elf-cc will fail due to file not found. ldFlagsFilter=\u0026#39;s|/nix/store/[^-]*-apple-framework-CoreFoundation[^ ]*||g\u0026#39; # Make sure the global flags aren’t accidentally influencing the platform-specific flags. export NIX_CFLAGS_COMPILE=\u0026#34;$(sed \u0026#34;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_CFLAGS_COMPILE\u0026#34;)\u0026#34; export NIX_LDFLAGS=\u0026#34;$(sed \u0026#34;$ldFlagsFilter;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_LDFLAGS\u0026#34;)\u0026#34; exec zsh \u0026#39;\u0026#39;; }; }; } ","date":"2024 September 14","externalUrl":null,"permalink":"/unix/1726280965789-nix-darwin-cross-compiler/","section":"Unix","summary":"","title":"在Nix-Darwin中使用交叉编译器","type":"unix"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/acgn/","section":"ACGN","summary":"","title":"ACGN","type":"acgn"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/tags/university/","section":"Tags","summary":"","title":"University","type":"tags"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/tags/youth/","section":"Tags","summary":"","title":"Youth","type":"tags"},{"content":"提笔时才发现闲时记录的照片已经不在现在的手机上了, 所幸仍未遗失. 全套的电子设备经过了一轮换代, 我过去四年的生活却宛如一张白纸, 亦不知我是否从未改变.\n在长春迎接我的第一场雪就伴随着一场冻雨, 漫天飞雪带来晶莹剔透, 太阳光在琉璃世界中折射出五彩的光芒. 这梦幻的场景或许这一生都不会在重复了, 因为疫情以及我自己性格上的原因我几乎从未出过校门, 但我想这样的景色无法通过刻意追寻求得. 这是我前1/4的人生里最美的一刻, 尽管它有着扑在脸上如烈火焚烧的寒风.\n凭着最初半年的努力顺利进入了唐班, 提前预订保研资格, 随之而来的却是迷惘. 离散数学出分的那个下午, 窗外大雨滂沱, 看着不到3的绩点愣在屏幕前不知所措; 得知操作系统课设没有满绩的那个夜晚, 在V3里麻木的操纵着普鲁士的市场, 乃至萌生了放弃保研的想法. 没有参加竞赛, 尝试参与科研也都是浅尝辄止, 我得过且过的度过自己的学术生涯. 不过窝在寝室里摆烂的日子我也看到了高纬度的冬季天空, 这夕阳刚刚落下时的蓝调色彩总是会给焦虑的我带来一点宽慰.\n如开头所言我的本科四年犹如白纸, 白的就像口罩与防护服. 2022年3月13日, 星期日, 睁开眼就得知封寝的消息. 除了寝室之外禁止踏足任何地点, 几步之遥的厕所也必须戴上口罩, 没有独卫使得整整一个月不能够洗澡. 前半段的餐食免费供应, 后半段需要每天自己预订, 口味重复寡淡且没有一份多余, 忘记订饭的那天靠着两包榨菜度过一整天, 晚上躺在床上肚痛难忍. 大白每天上门核酸, 麻木的开门捅嗓子, 在麻木的回到床上过着看不到头的日子. 2022年5月8日, 早上六点就来到人满为患的机场, 排到九点队伍都没有前进1/10, 靠着工作人员开放的加急通道成功回到家乡, 逃离这地狱一样的景象. 经历了如此严厉的封控, 疫情却不见好转, 下学期回来后对核酸的要求更是变本加厉. 我不想苛责任何人, 包括到现在都被调侃的许婧文同学, 大家都是照章办事. 不像上海封城, 这件事情早已被遗忘, 尽管它们的烈度不相上下. 希望我所说的这些未来不会再发生, 希望世界和平.\n闲暇之余沉迷3D势的VUP A-SOUL, 尤其是珈乐Carol, 她510毕业风波之后第一次有失恋的感觉, 后续的撕皮直播也断断续续看了一年. 当然, 也是因此机缘巧合了解了计算机图形学这一领域. 靠着Introduction to 3D Game Programming with DirectX® 12以及Real-Time Rendering 4th Edition 两本书不断迭代自己的carol-engine, 现在想来这是本科生活里唯一能影响我未来人生的经历. 靠着这股热爱联系了浙大CAD\u0026amp;CG实验室的老师, 进入了对于985学校来说相对容易的浙大软院, 现在在图形相关的岗位上实习, 也算对的起每天打开Visual Studio 2022坐着写一整天C++和HLSL的自己了.\n我的保研之路并没有多坎坷, 很早就选好导师并且开始给老板干活, 从一开始就想好要all in浙软. 不过真的到了夏令营和预推免还是会很紧张, 毕竟政策随时在变化. 当时夏令营的内容是两周复现NeRF并优化, 有一点CG与DL基础的我并没有遇到很多困难, 了解了NeRF的体渲染实现方式后比较顺利的完成了Instant-NGP的复现, 并与Mip-NeRF 360的distortion loss结合以实现unbound场景的降噪. 做项目的时候顺手用python给NeRF写了一个实时渲染器, 不过性能不怎么样, 也没空再优化了. 浙软夏令营的优营只会给一个预推免的入场券, 后面真的快要预推免的时候整个人焦虑的不行, 每天疯狂的复习408, 刷PAT题库, 好在机试的成绩比我预想的高很多, 面试主要问了计网, 数据库以及carol-engine的项目, 回答的很流利, 最后推免排名十分靠前. 说真的高考远没有保研结束的那一刻舒畅, 大概是因为保研时对于结束后的生活有了明确的规划: 学习NeoVim, 双十一组一台光追性能强劲的电脑, 通关往日之影. 最后这些规划也都一一实现, 活着还是很幸福的.\n说是实习, 其实是在导师公司, 相当于提前给老板打工了. 这里最神奇的是开发系统是Arch Linux, 尽管大二大三有着使用Ubuntu与Deepin的基础, 但把Linux作为工作环境还是第一次. 接触Arch就很难不被它高度自定义化的特性所感染, 双十一装机后我也在自己的电脑上安装了Arch, 更进一步的我开始自定义桌面环境, 用Hyprland, ElKowars wacky widges, rofi与dunst搭起一套桌面环境, 成为一名Unix Ricer, 现在这套配置已经迁移到了NixOS上. Rice确实给人一种光阴虚度的感觉, 但我作为一位程序员, 去接触不同的开源软件并了解它们的设计, 尝试掌控自己的电脑, 这是很有意义的.\n中学时家里配置最高的电脑是拥有GT 630M的笔记本, 到了2016年甚至魔兽世界7.0最低画质也只有个位数帧数了. 我在初一的寒假拥有了PS4, 我的第一台游戏主机, 也正因此我更偏爱主机游戏. 上了大学后的我拥有了游戏自由, 我在八十稻羽驱散天之狭雾, 在辰巳人工岛静静倾听神木秋成的粉色鳄鱼, 在初始之火的火炉继承乌薪王的传火遗志, 在黑雾之塔的底部与烟之骑士雷姆鏖战四天四夜, 在1992年的洛圣都的K-DST电台里听着Young Turks, 在黑门34年重回艾泽拉斯\u0026hellip; 我在大学里完成了游戏生涯补完计划, 以至于有些电子ED. 最近对JRPG颇有兴趣, 618靠着工资买了一台Steam Deck, 希望未来三年能完成JRPG的补完.\n多年以后,\n面对倒下的烟之骑士,\n他会回想起在天空的渔村\n第一次遇见科斯孤儿的\n那个遥远的下午.\n文学作品的阅读量远不如高中了, 毕竟无需再为作文而刻意去搜罗素材, 仔细想来其实只读了英语课上了解到的乔伊斯的都柏林人这一本短篇集, 捧着实体书读着都柏林众生的故事会给我一种莫名的温馨感. 之后也试着去读乔伊斯的尤利西斯, 很遗憾没有对意识流的品鉴能力, 几页过后就草草收场. 文学造诣一天天倒退, 对ACGN作品的兴趣却一天天的浓郁, 尤其是大四开始实习之后, 架不住公司里浓郁的二次元氛围被成功传染. 不过本科期间最令我动容的作品是2022年10月的赛博朋克: 边缘行者, 作为游戏预购玩家的我对2077的剧情并没有多感冒, I really want to stay at you house也只是体温电台里纪念威尔斯的一首歌, 但扳机社在边缘行者里悲剧般的描写让我在之后的两个星期里不断循环着它, 犹如一个赛博精神病, 为大卫与露西的爱情而感伤. 之后再去玩往日之影时竟被追求自由的百灵鸟所打动, 是CDPR的剧本进步了, 还是我的脑子变了呢? 二次元很煞笔, 我也是.\n子弹杯里伏特加加冰,\n兑小可可乐.\n生得伟大,\n死的光荣.\n写到这里也该有个结尾了, 本以为会是对废物一样的自己的嘲讽, 总结下来却发现并没有太多的失魂落魄. 祝愿我的未来三年一帆风顺, 祝愿我的人生前程似锦.\n","date":"2024 June 29","externalUrl":null,"permalink":"/acgn/1719632945386-changchun-memory/","section":"ACGN","summary":"","title":"长春回忆录","type":"acgn"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/lua/","section":"Tags","summary":"","title":"Lua","type":"tags"},{"content":"配置仓库见nix-config, fork自SketchyBar作者的配置, 由home-manager管理, 当前效果如下.\nRice一词来自于Race Inspired Cosmetic Enhancements, 即通过改装提高廉价赛车的性能(我看到的说法是日本赛车为主), 在程序员这里Rice被引申为对系统外观的美化, 以Unix系系统为主, 很多人会将自己的Rice分享到Reddit上的unixporn社区.\n原本计划端午节学习Yabai与SketchyBar的配置文件并将整体配色由Sonokai修改为我的 NixOS配置中的自定义配色方案, 然而不论是使用体验还是视觉观感这三个月来当前的桌面配置对我而言都是一个完美的状态, 所以今天只记录一下配置方式以及Nix配置中踩过的坑. 当然, 记录和感想为主, 并不是教程与技术分析.\nYabai # 毕竟不是Linux, Yabai的功能依赖于MacOS使用的Aqua WM, 在闭源代码上做一层套娃效果自然是无法与Linux上的Hyprland、Sway等开源WM相比的, 而Apple对兼容性的忽视也是名声在外, 每次系统更新Yabai都会伴随着部分功能的失效.\n也正是如此我对Yabai的作者koekeishiya是很钦佩的, 根据github的数据可以说他是以一己之力推进着Yabai的维护. 在写这篇文章时我一直都在为假期的流逝而焦虑, 来自峡湾之国的他会不会为此烦恼呢?\n晚上熬大夜看完了WWDC 2024, 大部分时间都在Apple Intelligence, 不过MacOS Sequoia部分提到了自动Window Tiling和快捷键, 对于第三方WM是利是弊还有待观察, 期待未来的MacOS实现原生的Yabai体验.\n写到这里才发现自己对MacOS上的WM知之甚少, 不妨在这里多探讨一些. 这个链接基本囊括了MacOS上的所有WM了, 这个reddit贴子里还提到了 Lasso和Raycast Window Management Extension. 最让我新奇的是里付费闭源WM占据了MacOS的半壁江山, 在我的印象(刻板印象?)里WM都是Geeker们折腾的开源玩具. 其实还挺想体验一下的, 可惜没钱, 估计我8+256的丐版Air也经不起这折腾.\n最终找到的比较流行的开源WM比我想象中要多不少, MacOS的开源生态实际上还是不错的. 有哪个程序员会不喜欢Unix呢, 在我买Mac时这是除了续航之外最重要的原因了. 简单浏览了一下各个项目的README和Wiki, 我这里大致梳理一下各自的特色.\nAmethyst是遵循xmonad标准的WM, 距今已经11年了. Amethyst是紫水晶, 而MacOS的图形层Quartz是水晶, 很有意思的名字. Yabai只支持BSP、Float与Stack布局, 而Amethyst Wiki中一共介绍了14种布局, 大部分都是固定一个主要窗口, 其余窗口按需排列与切换. Amethyst的布局使用js配置, 就在去年Amethyst支持了自定义布局, 可以用户自定义窗口状态变化以及扩展现有布局. Amethyst的所有功能都不需要关闭SIP, 但也因此功能上没有Yabai丰富, 例如透明度、移动工作区等功能都是缺失的.\nYabai是2019年的项目, 但是和Amethyst都是用Objective-C写出来的老东西, 与Yabai同时代的Rectangle已经用上Swift了. Rectangle基于已经archvie的Spectacle, 集成MAShortcut作为快捷键系统, 支持图形化快捷键配置. Rectangle只支持修改窗口的位置与大小, 并不会管理布局, 可以通过鼠标拖拽自动执行Window Tiling, 例如左右拖动让窗口占据半个屏幕, 朝上拖动让窗口最大化. 显然这没有Sequoia引入的Window Tiling智能, 后续可能会跟进官方的新API.\nRectang是自由软件, 但是Rectangle Pro是收费的, 支持管理布局、更丰富的快捷键、云端配置存储等功能. 私以为管理布局是WM最核心的功能, 这么定义的话Rectangle这个残血版可能都不能称之为WM了.\nLoop是2023年的新项目, 着重强调风格化的window resize, 从下面的官方示例中可以看出来对鼠标的支持非常丝滑. Loop仍然处于beta测试阶段, 只支持Ventura以上的版本. 随着使用时间增加Loop的图标会发生变化, 很酷炫的功能.\nAeroSpace同样诞生于2023, 但是要更传统一些, 主要目标是为用户带来类似于i3的窗口管理体验. AeroSpace不需要关闭SIP, 拥有自定义的虚拟工作区, 不依赖于Auqa的工作区系统. 但是从官方Demo来看动画支持是几乎没有的, 配置文件是我很不喜欢的toml格式(说起来Hugo也是toml为主, 但是也支持json, json赛高!), 没有给我什么眼前一亮的感觉.\n说回正题, 粗略浏览了Yabai的源代码, Yabai主要通过C/S结构的进程间通信实现WM配置, 即server进程监听socket, client向socket中写入message. 因此Yabai可以通过shell实现动态配置, Yabai的默认配置文件也只是shell script, 窗口外观配置以及移动窗口、创建工作区等操作都可以通过message来实现. Yabai message格式写在下面. Yabai Wiki中只介绍了一小部分配置, 需要阅读man page才能一览全貌, 我这里不会介绍具体配置选项, man page中有很详细的说明.\nyabai -m \u0026lt;message\u0026gt; \u0026lt;settings\u0026gt; 与其他WM不同, Yabai本身不包括快捷键系统. Yabai作者的另一个项目skhd提供了快捷键配置, 其他第三方软件也是可行的, 支持通过快捷键执行shell script即可. 在我的Hyprland配置中WM的快捷键以super作为基础键, 但MacOS中的大量快捷键已经占据了super(command), 而control和option被我的neovim配置占用, 无奈之下只好通过control + command / option + command来实现, 单手操作会很扭曲. skhd示例如下, 实现了切换工作区的功能:\n# Space Navigation lalt + lcmd - 1 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[1] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[1] lalt + lcmd - 2 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[2] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[2] lalt + lcmd - 3 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[3] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[3] lalt + lcmd - 4 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[4] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[4] lalt + lcmd - 5 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[5] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[5] Linux WM中常见的border在Yabai中也是缺失的, 我使用的是JankyBorders, 只提供了颜色、宽度、边缘形状、黑白名单等最基础的功能, 比微信要小而美就是了. 我的配置放在下面.\n#!/bin/bash options=( style=round width=6.0 hidpi=off active_color=0xc0e2e2e3 inactive_color=0xc02c2e34 background_color=0x302c2e34 ) borders \u0026#34;${options[@]}\u0026#34; SketchyBar # 接触Unix Rice时往往最先考虑使用哪一个WM, MacOS上还好, Linux上没有WM的话可就得对着Terminal敲代码了, 当然如果会VIM、Emacs这类Editor的话体验也还可以. 但WM管理的仅仅只是窗口而已, 重点在快捷方便而不是美观, 私以为每时每刻都能见到的Status Bar才是Rice的核心部分. 各类开源Status Bar往往具有极高的可定制性, 不像chrome这类商业应用只提供有限的外观选项. 选好WM与壁纸, 写好Status Bar, 配置好terminal, 这就是一次完整的Rice.\nSketchyBar fork自spacebar, 启发自Yabai已经移除的内置Status Bar. 也正因如此SketchyBar的配置方式与Yabai是一脉相承的, 与Yabai配合的很好. SketchyBar官网上列出了很多示例Status Bar, 可以看出定制能力是非常强悍的. MacOS Ricer们真的很喜欢在Status Bar上放一个Apple Logo.\n当然SketchyBar仍然只提供Status Bar相关的功能, 和Linux上的EWW以及AGS等自定义Widget相比定制化能力还是差了一截的. 阅读Yabai文档时我才了解到MacOS上也有个叫Übersicht的自定义Widget, 支持使用CoffeeScript或JavaScript来编写配置, 底层是React. 挺后悔刚接触Rice时学的是EWW, EWW的配置语言是一门叫yuck的lisp方言, 不是很适合编写Widget. 但如果我是作者, 拥有一门自己的语言真的很酷, 还是一门函数式语言, 更酷了.\nSketchyBar官方文档比Yabai的要好很多, 各类配置都可以查到. SketchyBar将Status Bar分为Bar与Item两个部分, Bar是轮船, Item是集装箱, 各个Item具有独立的功能与样式(就像Docker的logo一样). 或者可以这样理解, Bar是一个特殊的Item, 可以自定义样式但是不能自定义功能, 只负责为其他Item提供绘制区域.\nSketchyBar通过注册事件与用户提供的shell script实现Item属性的自动化修改, 支持用户自定义事件. SketchyBar有内置的动画系统, 支持通过动画曲线修改任意通过颜色与整数定义的属性, 十分甚至九分的灵活.\n此外SketchyBar支持数据图、滑条等特殊组件, 支持额外的弹出菜单, 甚至支持将MacOS中各个应用的Menu Bar直接映射到SketchyBar上, 这是最令我印象深刻的功能, 让SketchyBar可以真正的融入到日常工作流中. 但是通过点击触发系统自带的弹出菜单的功能仍在开发中, 在作者自己的配置里通过一个小程序实现了这个功能.\nSketchyBar作者最近有个新项目叫SbarLua, 是SketchyBar的一个插件, 支持用Lua写配置. 这算是我与SketchyBar深入交流的一次契机, 给SbarLua打Nix包让我第一次从源码层面去了解一个开源项目并解决冲突.\n首先聊一下打包过程, 打包代码放在下面. 参数里有Lua包, 但是Nix似乎并不支持将手动指定的依赖暴露在$PATH中, Nix的依赖系统只是会自动修改动态库的路径. 这导致无法直接执行Lua命令, 我目前没有找到解决办法, 需要用户自己在Nix配置中手动安装Lua. 我这里指定的编译器是gcc而不是clang, 因为SbarLua编译过程中需要使用gcc指令. 在MacOS上gcc是被alias到clang的, 但是Nix的编译环境是与系统无关的, 不包含任何预设的环境变量的, 指定clang作为编译器会导致编译过程中找不到gcc. 当然, 就算我指定使用clang, Nix使用的也是nixpkgs中的clang而非系统中的clang, 通常来说版本会新很多.\n{ lib , stdenv , fetchFromGitHub , CoreFoundation , readline , gcc , lua }: stdenv.mkDerivation { pname = \u0026#34;sketchybar-lua\u0026#34;; version = \u0026#34;dev\u0026#34;; src = fetchFromGitHub { owner = \u0026#34;FelixKratz\u0026#34;; repo = \u0026#34;SbarLua\u0026#34;; rev = \u0026#34;29395b1\u0026#34;; sha256 = \u0026#34;sha256-C2tg1mypz/CdUmRJ4vloPckYfZrwHxc4v8hsEow4RZs=\u0026#34;; }; nativeBuildInputs = [ gcc ]; buildInputs = [ CoreFoundation readline ]; enableParallelBuilding = true; buildPhase = \u0026#39;\u0026#39; make bin/sketchybar.so \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; mkdir -p $out/share cp bin/sketchybar.so $out/share/sketchybar.so \u0026#39;\u0026#39;; meta = with lib; { description = \u0026#34;A Lua API for SketchyBar\u0026#34;; homepage = \u0026#34;https://github.com/FelixKratz/SbarLua\u0026#34;; license = licenses.gpl3; platforms = platforms.darwin; }; } SbarLua基本上是对原有配置方式的封装, 但SketchyBar为执行配置文件的进程添加了SIGALRM信号, 使得配置文件的执行时间不超过60s. 代码放在这里:\nstatic inline bool fork_exec(char *command, struct env_vars* env_vars) { int pid = vfork(); if (pid == -1) return false; if (pid != 0) return true; alarm(FORK_TIMEOUT); exit(sync_exec(command, env_vars)); } 对于原本的shell script这是没有问题的, 但是SbarLua是包括了事件监听功能的, 需要lua进程持续运行, 因此作者在SbarLua中取消了SIGALRM(代码中的alarm(0)):\nint event_loop(lua_State* state) { g_state = state; struct stack* stack = stack_create(); stack_init(stack); stack_push(stack, UPDATE); sketchybar_call_log_and_cleanup(stack); alarm(0); mach_server_begin(\u0026amp;g_mach_server, callback_function); CFRunLoopTimerRef orphan_timer = CFRunLoopTimerCreate(kCFAllocatorDefault, CFAbsoluteTimeGetCurrent() + 1.0, 1.0, 0, 0, orphan_check, NULL ); CFRunLoopAddTimer(CFRunLoopGetMain(), orphan_timer, kCFRunLoopDefaultMode); CFRelease(orphan_timer); CFRunLoopRun(); return 0; } 显然作者期望的是直接执行配置文件, 比如作者本人是通过shebang执行sketchybarrc的:\n#!/usr/bin/env lua -- Load the sketchybar-package and prepare the helper binaries require(\u0026#34;helpers\u0026#34;) require(\u0026#34;init\u0026#34;) 然而我们是Nix, 如果Home-Manager是这样写的, 那很抱歉, 它没有执行权限!\n{ ... }: { home.file.\u0026#34;.config/sketchybar/sketchybarrc\u0026#34;.source = .config/sketchybar/sketchybarrc; } 我们可以通过Nix编写配置文件并执行, 代码放在下面. 我这里封装了一层, 因为还需要手动设置SbarLua动态库的路径. 此外代码里还手动trap了SIGALRM信号, 因为SbarLua代码中只能取消父进程的SIGALRM信号, 经过封装后SbarLua现在是sketchybar的孙子进程, 若我没有在配置文件里trap SIGALRM, 60s后执行配置文件的进程就会被杀死, SbarLua位于的孙子进程自然也不再执行. 这个问题困扰了我很久, 它会导致sketchybar运行60s后卡住, 在源码中捕获子进程的信号才终于发现了真相. 这就是自由软件的意义吧.\n{ pkgs, ... }: { services = { # other services sketchybar = { enable = true; extraPackages = [ pkgs.lua5_4_compat pkgs.sketchybar-lua ]; config = \u0026#39;\u0026#39; trap \u0026#34;\u0026#34; SIGALRM export LUA_CPATH=\u0026#34;$LUA_CPATH;${pkgs.sketchybar-lua}/share/?.so\u0026#34; export CONFIG_DIR=$HOME/.config/sketchybar cd $CONFIG_DIR lua init.lua \u0026#39;\u0026#39;; }; # other services }; } End # 写了这么多, 突然萌生出学习Apple技术栈的想法, 或许会很有趣?\n","date":"2024 June 10","externalUrl":null,"permalink":"/unix/1718005170522-macos-rice/","section":"Unix","summary":"","title":"MacOS Rice杂记","type":"unix"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/rice/","section":"Tags","summary":"","title":"Rice","type":"tags"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/sketchybar/","section":"Tags","summary":"","title":"SketchyBar","type":"tags"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/yabai/","section":"Tags","summary":"","title":"Yabai","type":"tags"},{"content":"","date":"2024 June 4","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"吉大唐班本科，浙软硕士，现在\u0026amp;未来从事图形学与游戏开发工作。\nNix/Neovim/Hyprland/Aylur\u0026rsquo;s GTK Shell探索中。\n喜欢JRPG！\n","date":"2024 June 4","externalUrl":null,"permalink":"/about/1717500731146-about/","section":"About","summary":"","title":"关于","type":"about"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/","section":"tsssni's blowfish blog","summary":"","title":"tsssni's blowfish blog","type":"page"}]