[{"content":"","date":"2024 October 1","externalUrl":null,"permalink":"/tags/graphics/","section":"Tags","summary":"","title":"Graphics","type":"tags"},{"content":"","date":"2024 October 1","externalUrl":null,"permalink":"/tags/pbrt/","section":"Tags","summary":"","title":"Pbrt","type":"tags"},{"content":"国庆开坑pbrt-v4的学习, 主要想深入了解光谱渲染. pbrt是与pbr-v4这本书配套的渲染器实现. 大部分书只是有配套代码, 而非一个完整的开源软件, pbrt这一点确实不错.\n编译环境 # pbrt-v4的依赖项都写在git submodule里了, 安装cmake即可. 对于nix-darwin用户, 由于编译器不会包含impure的系统framework路径, 需要在flake中手动指定, 否则glfw会编不过.\n{ description = \u0026#34;pbrt devenv\u0026#34;; inputs.nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixpkgs-24.05-darwin\u0026#34;; outputs = { nixpkgs , ... }: let system = \u0026#34;aarch64-darwin\u0026#34;; pkgs = import nixpkgs { inherit system; }; in { devShells.\u0026#34;${system}\u0026#34;.default = pkgs.mkShell { packages = [] ++ (with pkgs; [ clang lldb cmake ]) ++ (with pkgs.darwin.apple_sdk.frameworks; [ Cocoa IOKit CoreFoundation Kernel ]); shellHook = \u0026#39;\u0026#39; exec zsh \u0026#39;\u0026#39;; }; }; } 程序结构 # pbrt-v4基于C++17, 遵循面向对象的结构(会有继承地狱的样子), 针对光线、相机、BxDF等设计了抽象接口. pbrt-v4在设计上同时支持CPU/GPU光追, 支持CUDA与OptiX(显然darwin跑不了GPU, 毕竟23年的M3/A17才加上光追单元).\n运行流程 # 读取参数 解析描述文件 创建场景 integrator渲染循环 一气呵成的结构, 这里把renderer类称作integrator是因为渲染的核心流程就是求解渲染方程这一积分式, 这个名字还是比较贴切的.\n场景中的物体通过Primitive存储, 其中包含Material与Shape, 整个场景都包含在aggregate这一Primitive的实现中. 除aggregate之外场景只会存储lights, pbrt将平行光这类无限距离的光源单独存储, 只考虑这些光源可以更高效的渲染出可以接受的结果. 部分光源需要获取场景的包围盒, 因此pbrt给光源添加了preprocess接口.\nIntegrator接口需要实现Render与Intersect函数. Intersect有一种特殊实现叫做IntersectP, 只考虑是否相交而非具体的相交信息, 通常用于阴影. 作者说这种命名方式来自于Lisp, 其实国庆本来想学SICP的, 可惜时间就这么点.\nImageTileIntegrator # ImageTileIntegrator实现了Integrator, 支持将渲染图像划分为tile来实现并行渲染, 该类的构造函数需要额外的Camera与Sampler, 最终渲染结果存储在Camera中的Film成员. ImageTileIntegrator渲染时会分为多次wave, 每次wave的sample数逐步增加, 以此来实现渲染图像的预览.\n由于需要分配大量小内存来存储光线求解过程中的表面散射信息, pbrt通过自定义的ScratchBuffer来提高效率. 该类通过address offset的递增来快速分配相同大小的内存, 但是释放时只能通过将offset设置为0来释放当前所有分配的小内存, 也因此每个thread都需要创建ScratchBuffer, pbrt通过ThreadLocal模板类来实现.\n虚函数EvaluatePixelSample负责调用Sampler生成采样点供Integrator发射光线. 由于需要存储像素位置等状态, Sampler也通过ThreadLocal来定义. 在每个采样点渲染完成后, 会调用ScratchBuffer::Reset()来统一释放光追过程中分配的内存.\nRayIntegrator # RayIntegrator继承自ImageTileIntegrator(继承链开始变长了, 有种不好的预感), 在划分tile的基础上通过实现EvaluatePixelSample提供光线路径相关的功能.\n不同于传统的RGB渲染, RayIntegrator会在有效光谱范围中均匀采样, 每个sample都具有不同的波长, 默认是4个sample. 按我的理解, RGB就是只有三个固定波长的特殊形式的光谱渲染, 这里是更一般化的形式. RGB是可以三种波长一次计算的, 通用光谱渲染应该是要各个波长单独走光追流程了, 开销更大.\nCamera接口负责实现GenerateRay与GenerateRayDifferential, GenerateRay负责生成光线, GenerateRayDifferential负责生成相邻像素的光线信息以支持抗锯齿. CameraSample用于存储采样点在Film的位置. 它还会包含用于非小孔成像的镜头位置以及样本权重, 主要用于实现非pinhole的camera. 这一章给出的示例图是有景深效果的, pbrt应该实现了透镜镜头.\nRayIntegrator声明了Li这一虚函数用于实现具体的光照过程, 返回值为SampledSpectrum, 即样本的光谱信息. 该函数的参数包含VisibleSurface指针, 对于需要存储物体表面几何信息的Film这会返回它所需要的信息.\nRandomWalkIntegrator # 上面的都是虚类, 这里终于到具体实现了, 继承吼可怕.\nRandomWalkIntegrator主要实现了Monte Carlo方法, 通过物体的自发光与用BSDF得到的反射光线返回的结果得到渲染样本. 这里没有考虑直接光源, 自然会缺少有阴影与高光项, 光线也几乎不会与场景里的光源相交. 按照作者的说法, 那张满是噪点的示例图是每个像素4096个样本的结果, 这里也可以窥见AI降噪缘何如此火热.\n代码使用 # 命名 # 类名采用大写开头camel case, 变量采用小写开头.\n指针 or 引用 # 可变的或者可以传入空值的用指针, 否则const引用.\n标准库 # pbrt尽量使用标准库来降低代码复杂度, 部分标准库的重新实现会放在pstd namespace下.\n内存分配 # pbrt使用std::pmr::polymorphic_allocator来分配对象, 这是c++17提供的内存管理器接口, 用于实现多态的内存管理器. 相比于new\u0026amp;delete, 通过函数调用显示分配内存方便pbrt收集内存分配情况并提高小对象分配效率, 同时也便于分配GPU可见的内存.\n动态分派 # pbrt不使用虚表来实现多态, 而是通过TaggedPointer来存储函数与类型信息, 主要是为了减少复杂场景下大量虚表指针带来的性能开销以及实现GPU代码的多态.\n代码优化 # 这里主要提到了pbrt会优化访存速度, 并未设计具体实现.\n调试 \u0026amp; 错误处理 # pbrt中包含大量单元测试来保证代码的正确性, 运行时通过assertion来报错. pbrt会报告具体哪个像素与样本发生错误, 并支持只重新执行这个样本来查找错误. pbrt中的类提供了toString类来实现类似于运行时反射的功能.\n多线程 # pbrt为了保证效率, 绝大部分数据结构都是非线程安全的, 基本也都是每个线程单独创建自己需要的或者是只读的.\n绝大部分工具类是线程安全的, 例如Camera、 BxDF. Light::Preprocess是非线程安全的, 因为场景的构建过程为单线程. Sampler是非线程安全的, 这是考虑到光线采样过程中的性能开销, 因此每个线程都会创建Sampler.\n所有全局函数都是线程安全的.\n可扩展性 # 教学用的软件可扩展性肯定要保证的, 后面我应该也会尝试实现新的渲染方法.\nBugs # (去pbrt.org提issue吧)\nPBR历史 # 这里我就不总结了, 按我自己的经历来说, 首次接触是在RTR4, 现在在实时渲染上GGX+Smith应该是绝对主流了.\n结语 # 这一章主要介绍pbrt的代码结构, 这对于后续的阅读与代码练习是很有意义的. 至于为什么要着重强调这次加入了GPU光追, 答案很显然: 2/3的作者是nVidia的. 后续章节这两天应该救会更新.\n","date":"2024 October 1","externalUrl":null,"permalink":"/render/1727763944120-pbrt-v4-episode-1/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. I: 代码实现","type":"render"},{"content":"","date":"2024 October 1","externalUrl":null,"permalink":"/tags/rendering/","section":"Tags","summary":"","title":"Rendering","type":"tags"},{"content":"","date":"2024 October 1","externalUrl":null,"permalink":"/render/","section":"Rendering","summary":"","title":"Rendering","type":"render"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/cross-compilation/","section":"Tags","summary":"","title":"Cross-Compilation","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/darwin/","section":"Tags","summary":"","title":"Darwin","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/macos/","section":"Tags","summary":"","title":"Macos","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/nix/","section":"Tags","summary":"","title":"Nix","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/nix-darwin/","section":"Tags","summary":"","title":"Nix-Darwin","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/unix/","section":"Unix","summary":"","title":"Unix","type":"unix"},{"content":"Nix这边对交叉编译的支持是很不错的, 但它是用来通过stdenv编译nixpkgs中的某个包的. 浙软的高级操作系统Lab需要直接使用交叉编译器, 那么只能通过在环境中导入stdenv.cc来实现, 这一步是有坑的. Homebrew可以一键安装, 但我又无法抛弃通过nix develop来实现便捷的环境配置, 因此相关的解决方案今天记录在这里.\n系统配置 # Nix本身具有良好的交叉编译环境支持, 对于已经记录在lib.systems.examples中的系统, 可以通过pkgs.pkgsCross.[cross-env]直接导入. lib.systems.examples的部分定义如下:\n# ... { # ... aarch64-embedded = { config = \u0026#34;aarch64-none-elf\u0026#34;; libc = \u0026#34;newlib\u0026#34;; rustc.config = \u0026#34;aarch64-unknown-none\u0026#34;; }; # ... gnu64 = { config = \u0026#34;x86_64-unknown-linux-gnu\u0026#34;; }; gnu64_simplekernel = gnu64 // platforms.pc_simplekernel; # see test/cross/default.nix gnu32 = { config = \u0026#34;i686-unknown-linux-gnu\u0026#34;; }; # ... } 这里最核心的部分就是config里这个字符串, 如果没有指定libc等别的要求, 通常可以用这个字符串替代attribute set, 例如:\n# the following are the same system = \u0026#34;aarch64-darwin\u0026#34;; system = { config = \u0026#34;aarch64-darwin\u0026#34;; }; 系统字符串具有特定的格式:\narch-vendor-kernel-abi 该字符串可以包含其中的任意部分, 例如aarch64-darwin就只包含arch-kernel. nixpkgs会利用lib.systems.elaborate来补充省略的部分, 并扩展为一个attribute set来提供更多功能. 例如aarch64-darwin会被扩展为如下形式, 这里截取部分属性作为例子:\n{ # ... config = \u0026#34;aarch64-apple-darwin\u0026#34;; darwinArch = \u0026#34;arm64\u0026#34;; darwinMinVersion = \u0026#34;11.0\u0026#34;; darwinMinVersionVariable = \u0026#34;MACOSX_DEPLOYMENT_TARGET\u0026#34;; darwinPlatform = \u0026#34;macos\u0026#34;; darwinSdkVersion = \u0026#34;11.0\u0026#34;; # ... gcc = { ... }; hasSharedLibraries = true; is32bit = false; is64bit = true; isAarch = true; isAarch32 = false; isAarch64 = true; # ... isBigEndian = false; isCompatible = «lambda @ /Users/tsssni/nixpkgs/lib/systems/default.nix:82:22»; isDarwin = true; # ... isMacOS = true; isMacho = true; # ... libc = \u0026#34;libSystem\u0026#34;; linker = \u0026#34;cctools\u0026#34;; # ... system = \u0026#34;aarch64-darwin\u0026#34;; ubootArch = \u0026#34;arm64\u0026#34;; uname = { ... }; useAndroidPrebuilt = false; useLLVM = false; useiOSPrebuilt = false; } 可以看到系统信息得到了充分的补全, 给用户提供了足够的系统信息, 例如通过(if localSystem.isDarwin)即可判断当前交叉编译环境下的本地系统是否为Darwin.\n自定义系统 # 并非所有交叉编译环境都会在pkgsCross中提供, pkgsCross中的命名方式可能也不符合用户的要求. 例如Homebrew中提供的aarch64-embedded环境的前缀为aarch64-elf, Nix中为aarch64-none-elf. 两者编译出的二进制文件并无区别, 且都是符合gcc交叉编译器的传统命名方式的, 但是部分代码中可能直接指定编译器前缀, 例如我的OS Lab中使用的Unikraft的make文件中有如下定义:\n# set cross compile ifeq ($(call qstrip,$(CONFIG_CROSS_COMPILE)),) ifeq ($(HOSTOSENV),Darwin) CONFIG_CROSS_COMPILE := aarch64-elf- else ifneq ($(CONFIG_UK_ARCH),$(HOSTARCH)) CONFIG_CROSS_COMPILE := aarch64-linux-gnu- endif endif endif 显然它默认我们使用Homebrew(Nix-Darwin确实挺难用的\u0026hellip;), 可以参考Unikraft官方的Homebrew Tap. 此时我们可以自定义系统设置来解决该问题, 例如在我的NUR仓库参照aarch64-embedded定义了如下系统:\n{ aarch64-elf = { config = \u0026#34;aarch64-elf\u0026#34;; libc = \u0026#34;newlib\u0026#34;; rustc.config = \u0026#34;aarch64-unknown-none\u0026#34;; }; } 这会导致Nix编译出的cc-wrapper前缀的变化, 只有在交叉编译环境中才会使用带前缀的cc. 经过我的测试, aarch64-embedded并未存储于nixos cache中, 和aarch64-elf一样需要本地编译, 因此使用体验是相同的. 交叉编译器前缀与系统配置字符串是相同的, 影响交叉编译器前缀的代码如下:\n# pkgs/build-support/cc-wrapper/default.nix # ... let targetPrefix = optionalString (targetPlatform != hostPlatform) (targetPlatform.config + \u0026#34;-\u0026#34;); in: # ... 交叉编译stdenv # 想要在配置中导入自定义交叉编译系统对应的nixpkgs环境, 重新import nixpkgs即可. 例如我这里只需要在develop环境中使用交叉编译器, 可以这样编写mkShell:\nlet aarch64-elf-pkgs = import nixpkgs { localSystem = system; crossSystem = tsssni-lib.systems.aarch64-elf; }; in pkgs.mkShell { packages = [ aarch64-elf-pkgs.stdenv.cc ]; }; 然而此时编译出的aarch64-elf-gcc会报-iframework unknown option错误, 这是darwin平台特有的选项, 对于交叉编译器该选项是不支持的, 显然这是因为cc-wrapper在darwin平台上自动导入这个flag了. 开始我以为这是nixpkgs的bug, 但从cc-wrapper的setup-hook.sh可以看出, 这个flag是只在targetSystem.isDarwin时才会引入.\n归根结底, 这还是由于在一个环境中引入了不同的系统配置导致的. 除了aarch64-elf-gcc之外我还安装了其他darwin-native的包, 因此nix develop会导入darwin-native环境中cc-wrapper的setup-hooks. cc-wrapper是依赖setup-hooks中设置的NIX_CFLAGS_COMPILEF来引入flag的, darwin-native-gcc需要的flags也会被aarch64-elf-gcc使用, 从而导致报错.\n由于这些-isystem和-iframework对于我的OS LAB来说是无关紧要的, 此时在mkShell时可以参照simavr的setup-hook来把-iframework过滤掉, simavr中-isystem也是被过滤掉的, 这里我也一并过滤:\npkgs.mkShell { # ... shellHook = \u0026#39;\u0026#39; # Because it’s getting called from a Darwin stdenv, aarch64-elf-cc will pick up on # Darwin-specific flags, and it will barf and die on -iframework in # particular. Strip them out, so simavr can compile its test firmware. cflagsFilter=\u0026#39;s|-F[^ ]*||g;s|-iframework [^ ]*||g;s|-isystem [^ ]*||g;s| *| |g\u0026#39; # The `CoreFoundation` reference is added by `linkSystemCoreFoundationFramework` in the # Apple SDK’s setup hook. Remove that because aarch64-elf-cc will fail due to file not found. ldFlagsFilter=\u0026#39;s|/nix/store/[^-]*-apple-framework-CoreFoundation[^ ]*||g\u0026#39; # Make sure the global flags aren’t accidentally influencing the platform-specific flags. export NIX_CFLAGS_COMPILE=\u0026#34;$(sed \u0026#34;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_CFLAGS_COMPILE\u0026#34;)\u0026#34; export NIX_LDFLAGS=\u0026#34;$(sed \u0026#34;$ldFlagsFilter;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_LDFLAGS\u0026#34;)\u0026#34; exec zsh \u0026#39;\u0026#39;; } Flake # 此时交叉编译器就可以正常使用了, 完整的flake如下:\n{ description = \u0026#34;OSLAB devenv\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixpkgs-24.05-darwin\u0026#34;; tsssni-nur = { url = \u0026#34;github:tsssni/NUR\u0026#34;; inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; }; }; outputs = { nixpkgs, tsssni-nur, ... }: let system = \u0026#34;aarch64-darwin\u0026#34;; in { devShells.\u0026#34;${system}\u0026#34;.default = let pkgs = import nixpkgs { inherit system; }; tsssni-lib = tsssni-nur.lib; tsssni-pkgs = tsssni-nur.pkgs { localSystem = system; }; aarch64-elf-pkgs = import nixpkgs { localSystem = system; crossSystem = tsssni-lib.systems.aarch64-elf; }; in pkgs.mkShell { packages = [] ++ (with pkgs; [ clang lldb qemu coreutils-prefixed cmake ]) ++ (with tsssni-pkgs.gnu; [ ggrep gmake gsed ]) ++ (with aarch64-elf-pkgs; [ stdenv.cc ]); shellHook = \u0026#39;\u0026#39; # Because it’s getting called from a Darwin stdenv, aarch64-elf-cc will pick up on # Darwin-specific flags, and it will barf and die on -iframework in # particular. Strip them out, so simavr can compile its test firmware. cflagsFilter=\u0026#39;s|-F[^ ]*||g;s|-iframework [^ ]*||g;s|-isystem [^ ]*||g;s| *| |g\u0026#39; # The `CoreFoundation` reference is added by `linkSystemCoreFoundationFramework` in the # Apple SDK’s setup hook. Remove that because aarch64-elf-cc will fail due to file not found. ldFlagsFilter=\u0026#39;s|/nix/store/[^-]*-apple-framework-CoreFoundation[^ ]*||g\u0026#39; # Make sure the global flags aren’t accidentally influencing the platform-specific flags. export NIX_CFLAGS_COMPILE=\u0026#34;$(sed \u0026#34;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_CFLAGS_COMPILE\u0026#34;)\u0026#34; export NIX_LDFLAGS=\u0026#34;$(sed \u0026#34;$ldFlagsFilter;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_LDFLAGS\u0026#34;)\u0026#34; exec zsh \u0026#39;\u0026#39;; }; }; } ","date":"2024 September 14","externalUrl":null,"permalink":"/unix/1726280965789-nix-darwin-cross-compiler/","section":"Unix","summary":"","title":"在Nix-Darwin中使用交叉编译器","type":"unix"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/acgn/","section":"ACGN","summary":"","title":"ACGN","type":"acgn"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/tags/university/","section":"Tags","summary":"","title":"University","type":"tags"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/tags/youth/","section":"Tags","summary":"","title":"Youth","type":"tags"},{"content":"提笔时才发现闲时记录的照片已经不在现在的手机上了, 所幸仍未遗失. 全套的电子设备经过了一轮换代, 我过去四年的生活却宛如一张白纸, 亦不知我是否从未改变.\n在长春迎接我的第一场雪就伴随着一场冻雨, 漫天飞雪带来晶莹剔透, 太阳光在琉璃世界中折射出五彩的光芒. 这梦幻的场景或许这一生都不会在重复了, 因为疫情以及我自己性格上的原因我几乎从未出过校门, 但我想这样的景色无法通过刻意追寻求得. 这是我前1/4的人生里最美的一刻, 尽管它有着扑在脸上如烈火焚烧的寒风.\n凭着最初半年的努力顺利进入了唐班, 提前预订保研资格, 随之而来的却是迷惘. 离散数学出分的那个下午, 窗外大雨滂沱, 看着不到3的绩点愣在屏幕前不知所措; 得知操作系统课设没有满绩的那个夜晚, 在V3里麻木的操纵着普鲁士的市场, 乃至萌生了放弃保研的想法. 没有参加竞赛, 尝试参与科研也都是浅尝辄止, 我得过且过的度过自己的学术生涯. 不过窝在寝室里摆烂的日子我也看到了高纬度的冬季天空, 这夕阳刚刚落下时的蓝调色彩总是会给焦虑的我带来一点宽慰.\n如开头所言我的本科四年犹如白纸, 白的就像口罩与防护服. 2022年3月13日, 星期日, 睁开眼就得知封寝的消息. 除了寝室之外禁止踏足任何地点, 几步之遥的厕所也必须戴上口罩, 没有独卫使得整整一个月不能够洗澡. 前半段的餐食免费供应, 后半段需要每天自己预订, 口味重复寡淡且没有一份多余, 忘记订饭的那天靠着两包榨菜度过一整天, 晚上躺在床上肚痛难忍. 大白每天上门核酸, 麻木的开门捅嗓子, 在麻木的回到床上过着看不到头的日子. 2022年5月8日, 早上六点就来到人满为患的机场, 排到九点队伍都没有前进1/10, 靠着工作人员开放的加急通道成功回到家乡, 逃离这地狱一样的景象. 经历了如此严厉的封控, 疫情却不见好转, 下学期回来后对核酸的要求更是变本加厉. 我不想苛责任何人, 包括到现在都被调侃的许婧文同学, 大家都是照章办事. 不像上海封城, 这件事情早已被遗忘, 尽管它们的烈度不相上下. 希望我所说的这些未来不会再发生, 希望世界和平.\n闲暇之余沉迷3D势的VUP A-SOUL, 尤其是珈乐Carol, 她510毕业风波之后第一次有失恋的感觉, 后续的撕皮直播也断断续续看了一年. 当然, 也是因此机缘巧合了解了计算机图形学这一领域. 靠着Introduction to 3D Game Programming with DirectX® 12以及Real-Time Rendering 4th Edition 两本书不断迭代自己的carol-engine, 现在想来这是本科生活里唯一能影响我未来人生的经历. 靠着这股热爱联系了浙大CAD\u0026amp;CG实验室的老师, 进入了对于985学校来说相对容易的浙大软院, 现在在图形相关的岗位上实习, 也算对的起每天打开Visual Studio 2022坐着写一整天C++和HLSL的自己了.\n我的保研之路并没有多坎坷, 很早就选好导师并且开始给老板干活, 从一开始就想好要all in浙软. 不过真的到了夏令营和预推免还是会很紧张, 毕竟政策随时在变化. 当时夏令营的内容是两周复现NeRF并优化, 有一点CG与DL基础的我并没有遇到很多困难, 了解了NeRF的体渲染实现方式后比较顺利的完成了Instant-NGP的复现, 并与Mip-NeRF 360的distortion loss结合以实现unbound场景的降噪. 做项目的时候顺手用python给NeRF写了一个实时渲染器, 不过性能不怎么样, 也没空再优化了. 浙软夏令营的优营只会给一个预推免的入场券, 后面真的快要预推免的时候整个人焦虑的不行, 每天疯狂的复习408, 刷PAT题库, 好在机试的成绩比我预想的高很多, 面试主要问了计网, 数据库以及carol-engine的项目, 回答的很流利, 最后推免排名十分靠前. 说真的高考远没有保研结束的那一刻舒畅, 大概是因为保研时对于结束后的生活有了明确的规划: 学习NeoVim, 双十一组一台光追性能强劲的电脑, 通关往日之影. 最后这些规划也都一一实现, 活着还是很幸福的.\n说是实习, 其实是在导师公司, 相当于提前给老板打工了. 这里最神奇的是开发系统是Arch Linux, 尽管大二大三有着使用Ubuntu与Deepin的基础, 但把Linux作为工作环境还是第一次. 接触Arch就很难不被它高度自定义化的特性所感染, 双十一装机后我也在自己的电脑上安装了Arch, 更进一步的我开始自定义桌面环境, 用Hyprland, ElKowars wacky widges, rofi与dunst搭起一套桌面环境, 成为一名Unix Ricer, 现在这套配置已经迁移到了NixOS上. Rice确实给人一种光阴虚度的感觉, 但我作为一位程序员, 去接触不同的开源软件并了解它们的设计, 尝试掌控自己的电脑, 这是很有意义的.\n中学时家里配置最高的电脑是拥有GT 630M的笔记本, 到了2016年甚至魔兽世界7.0最低画质也只有个位数帧数了. 我在初一的寒假拥有了PS4, 我的第一台游戏主机, 也正因此我更偏爱主机游戏. 上了大学后的我拥有了游戏自由, 我在八十稻羽驱散天之狭雾, 在辰巳人工岛静静倾听神木秋成的粉色鳄鱼, 在初始之火的火炉继承乌薪王的传火遗志, 在黑雾之塔的底部与烟之骑士雷姆鏖战四天四夜, 在1992年的洛圣都的K-DST电台里听着Young Turks, 在黑门34年重回艾泽拉斯\u0026hellip; 我在大学里完成了游戏生涯补完计划, 以至于有些电子ED. 最近对JRPG颇有兴趣, 618靠着工资买了一台Steam Deck, 希望未来三年能完成JRPG的补完.\n多年以后,\n面对倒下的烟之骑士,\n他会回想起在天空的渔村\n第一次遇见科斯孤儿的\n那个遥远的下午.\n文学作品的阅读量远不如高中了, 毕竟无需再为作文而刻意去搜罗素材, 仔细想来其实只读了英语课上了解到的乔伊斯的都柏林人这一本短篇集, 捧着实体书读着都柏林众生的故事会给我一种莫名的温馨感. 之后也试着去读乔伊斯的尤利西斯, 很遗憾没有对意识流的品鉴能力, 几页过后就草草收场. 文学造诣一天天倒退, 对ACGN作品的兴趣却一天天的浓郁, 尤其是大四开始实习之后, 架不住公司里浓郁的二次元氛围被成功传染. 不过本科期间最令我动容的作品是2022年10月的赛博朋克: 边缘行者, 作为游戏预购玩家的我对2077的剧情并没有多感冒, I really want to stay at you house也只是体温电台里纪念威尔斯的一首歌, 但扳机社在边缘行者里悲剧般的描写让我在之后的两个星期里不断循环着它, 犹如一个赛博精神病, 为大卫与露西的爱情而感伤. 之后再去玩往日之影时竟被追求自由的百灵鸟所打动, 是CDPR的剧本进步了, 还是我的脑子变了呢? 二次元很煞笔, 我也是.\n子弹杯里伏特加加冰,\n兑小可可乐.\n生得伟大,\n死的光荣.\n写到这里也该有个结尾了, 本以为会是对废物一样的自己的嘲讽, 总结下来却发现并没有太多的失魂落魄. 祝愿我的未来三年一帆风顺, 祝愿我的人生前程似锦.\n","date":"2024 June 29","externalUrl":null,"permalink":"/acgn/1719632945386-changchun-memory/","section":"ACGN","summary":"","title":"长春回忆录","type":"acgn"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/lua/","section":"Tags","summary":"","title":"Lua","type":"tags"},{"content":"配置仓库见nix-config, fork自SketchyBar作者的配置, 由home-manager管理, 当前效果如下.\nRice一词来自于Race Inspired Cosmetic Enhancements, 即通过改装提高廉价赛车的性能(我看到的说法是日本赛车为主), 在程序员这里Rice被引申为对系统外观的美化, 以Unix系系统为主, 很多人会将自己的Rice分享到Reddit上的unixporn社区.\n原本计划端午节学习Yabai与SketchyBar的配置文件并将整体配色由Sonokai修改为我的 NixOS配置中的自定义配色方案, 然而不论是使用体验还是视觉观感这三个月来当前的桌面配置对我而言都是一个完美的状态, 所以今天只记录一下配置方式以及Nix配置中踩过的坑. 当然, 记录和感想为主, 并不是教程与技术分析.\nYabai # 毕竟不是Linux, Yabai的功能依赖于MacOS使用的Aqua WM, 在闭源代码上做一层套娃效果自然是无法与Linux上的Hyprland、Sway等开源WM相比的, 而Apple对兼容性的忽视也是名声在外, 每次系统更新Yabai都会伴随着部分功能的失效.\n也正是如此我对Yabai的作者koekeishiya是很钦佩的, 根据github的数据可以说他是以一己之力推进着Yabai的维护. 在写这篇文章时我一直都在为假期的流逝而焦虑, 来自峡湾之国的他会不会为此烦恼呢?\n晚上熬大夜看完了WWDC 2024, 大部分时间都在Apple Intelligence, 不过MacOS Sequoia部分提到了自动Window Tiling和快捷键, 对于第三方WM是利是弊还有待观察, 期待未来的MacOS实现原生的Yabai体验.\n写到这里才发现自己对MacOS上的WM知之甚少, 不妨在这里多探讨一些. 这个链接基本囊括了MacOS上的所有WM了, 这个reddit贴子里还提到了 Lasso和Raycast Window Management Extension. 最让我新奇的是里付费闭源WM占据了MacOS的半壁江山, 在我的印象(刻板印象?)里WM都是Geeker们折腾的开源玩具. 其实还挺想体验一下的, 可惜没钱, 估计我8+256的丐版Air也经不起这折腾.\n最终找到的比较流行的开源WM比我想象中要多不少, MacOS的开源生态实际上还是不错的. 有哪个程序员会不喜欢Unix呢, 在我买Mac时这是除了续航之外最重要的原因了. 简单浏览了一下各个项目的README和Wiki, 我这里大致梳理一下各自的特色.\nAmethyst是遵循xmonad标准的WM, 距今已经11年了. Amethyst是紫水晶, 而MacOS的图形层Quartz是水晶, 很有意思的名字. Yabai只支持BSP、Float与Stack布局, 而Amethyst Wiki中一共介绍了14种布局, 大部分都是固定一个主要窗口, 其余窗口按需排列与切换. Amethyst的布局使用js配置, 就在去年Amethyst支持了自定义布局, 可以用户自定义窗口状态变化以及扩展现有布局. Amethyst的所有功能都不需要关闭SIP, 但也因此功能上没有Yabai丰富, 例如透明度、移动工作区等功能都是缺失的.\nYabai是2019年的项目, 但是和Amethyst都是用Objective-C写出来的老东西, 与Yabai同时代的Rectangle已经用上Swift了. Rectangle基于已经archvie的Spectacle, 集成MAShortcut作为快捷键系统, 支持图形化快捷键配置. Rectangle只支持修改窗口的位置与大小, 并不会管理布局, 可以通过鼠标拖拽自动执行Window Tiling, 例如左右拖动让窗口占据半个屏幕, 朝上拖动让窗口最大化. 显然这没有Sequoia引入的Window Tiling智能, 后续可能会跟进官方的新API.\nRectang是自由软件, 但是Rectangle Pro是收费的, 支持管理布局、更丰富的快捷键、云端配置存储等功能. 私以为管理布局是WM最核心的功能, 这么定义的话Rectangle这个残血版可能都不能称之为WM了.\nLoop是2023年的新项目, 着重强调风格化的window resize, 从下面的官方示例中可以看出来对鼠标的支持非常丝滑. Loop仍然处于beta测试阶段, 只支持Ventura以上的版本. 随着使用时间增加Loop的图标会发生变化, 很酷炫的功能.\nAeroSpace同样诞生于2023, 但是要更传统一些, 主要目标是为用户带来类似于i3的窗口管理体验. AeroSpace不需要关闭SIP, 拥有自定义的虚拟工作区, 不依赖于Auqa的工作区系统. 但是从官方Demo来看动画支持是几乎没有的, 配置文件是我很不喜欢的toml格式(说起来Hugo也是toml为主, 但是也支持json, json赛高!), 没有给我什么眼前一亮的感觉.\n说回正题, 粗略浏览了Yabai的源代码, Yabai主要通过C/S结构的进程间通信实现WM配置, 即server进程监听socket, client向socket中写入message. 因此Yabai可以通过shell实现动态配置, Yabai的默认配置文件也只是shell script, 窗口外观配置以及移动窗口、创建工作区等操作都可以通过message来实现. Yabai message格式写在下面. Yabai Wiki中只介绍了一小部分配置, 需要阅读man page才能一览全貌, 我这里不会介绍具体配置选项, man page中有很详细的说明.\nyabai -m \u0026lt;message\u0026gt; \u0026lt;settings\u0026gt; 与其他WM不同, Yabai本身不包括快捷键系统. Yabai作者的另一个项目skhd提供了快捷键配置, 其他第三方软件也是可行的, 支持通过快捷键执行shell script即可. 在我的Hyprland配置中WM的快捷键以super作为基础键, 但MacOS中的大量快捷键已经占据了super(command), 而control和option被我的neovim配置占用, 无奈之下只好通过control + command / option + command来实现, 单手操作会很扭曲. skhd示例如下, 实现了切换工作区的功能:\n# Space Navigation lalt + lcmd - 1 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[1] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[1] lalt + lcmd - 2 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[2] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[2] lalt + lcmd - 3 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[3] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[3] lalt + lcmd - 4 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[4] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[4] lalt + lcmd - 5 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[5] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[5] Linux WM中常见的border在Yabai中也是缺失的, 我使用的是JankyBorders, 只提供了颜色、宽度、边缘形状、黑白名单等最基础的功能, 比微信要小而美就是了. 我的配置放在下面.\n#!/bin/bash options=( style=round width=6.0 hidpi=off active_color=0xc0e2e2e3 inactive_color=0xc02c2e34 background_color=0x302c2e34 ) borders \u0026#34;${options[@]}\u0026#34; SketchyBar # 接触Unix Rice时往往最先考虑使用哪一个WM, MacOS上还好, Linux上没有WM的话可就得对着Terminal敲代码了, 当然如果会VIM、Emacs这类Editor的话体验也还可以. 但WM管理的仅仅只是窗口而已, 重点在快捷方便而不是美观, 私以为每时每刻都能见到的Status Bar才是Rice的核心部分. 各类开源Status Bar往往具有极高的可定制性, 不像chrome这类商业应用只提供有限的外观选项. 选好WM与壁纸, 写好Status Bar, 配置好terminal, 这就是一次完整的Rice.\nSketchyBar fork自spacebar, 启发自Yabai已经移除的内置Status Bar. 也正因如此SketchyBar的配置方式与Yabai是一脉相承的, 与Yabai配合的很好. SketchyBar官网上列出了很多示例Status Bar, 可以看出定制能力是非常强悍的. MacOS Ricer们真的很喜欢在Status Bar上放一个Apple Logo.\n当然SketchyBar仍然只提供Status Bar相关的功能, 和Linux上的EWW以及AGS等自定义Widget相比定制化能力还是差了一截的. 阅读Yabai文档时我才了解到MacOS上也有个叫Übersicht的自定义Widget, 支持使用CoffeeScript或JavaScript来编写配置, 底层是React. 挺后悔刚接触Rice时学的是EWW, EWW的配置语言是一门叫yuck的lisp方言, 不是很适合编写Widget. 但如果我是作者, 拥有一门自己的语言真的很酷, 还是一门函数式语言, 更酷了.\nSketchyBar官方文档比Yabai的要好很多, 各类配置都可以查到. SketchyBar将Status Bar分为Bar与Item两个部分, Bar是轮船, Item是集装箱, 各个Item具有独立的功能与样式(就像Docker的logo一样). 或者可以这样理解, Bar是一个特殊的Item, 可以自定义样式但是不能自定义功能, 只负责为其他Item提供绘制区域.\nSketchyBar通过注册事件与用户提供的shell script实现Item属性的自动化修改, 支持用户自定义事件. SketchyBar有内置的动画系统, 支持通过动画曲线修改任意通过颜色与整数定义的属性, 十分甚至九分的灵活.\n此外SketchyBar支持数据图、滑条等特殊组件, 支持额外的弹出菜单, 甚至支持将MacOS中各个应用的Menu Bar直接映射到SketchyBar上, 这是最令我印象深刻的功能, 让SketchyBar可以真正的融入到日常工作流中. 但是通过点击触发系统自带的弹出菜单的功能仍在开发中, 在作者自己的配置里通过一个小程序实现了这个功能.\nSketchyBar作者最近有个新项目叫SbarLua, 是SketchyBar的一个插件, 支持用Lua写配置. 这算是我与SketchyBar深入交流的一次契机, 给SbarLua打Nix包让我第一次从源码层面去了解一个开源项目并解决冲突.\n首先聊一下打包过程, 打包代码放在下面. 参数里有Lua包, 但是Nix似乎并不支持将手动指定的依赖暴露在$PATH中, Nix的依赖系统只是会自动修改动态库的路径. 这导致无法直接执行Lua命令, 我目前没有找到解决办法, 需要用户自己在Nix配置中手动安装Lua. 我这里指定的编译器是gcc而不是clang, 因为SbarLua编译过程中需要使用gcc指令. 在MacOS上gcc是被alias到clang的, 但是Nix的编译环境是与系统无关的, 不包含任何预设的环境变量的, 指定clang作为编译器会导致编译过程中找不到gcc. 当然, 就算我指定使用clang, Nix使用的也是nixpkgs中的clang而非系统中的clang, 通常来说版本会新很多.\n{ lib , stdenv , fetchFromGitHub , CoreFoundation , readline , gcc , lua }: stdenv.mkDerivation { pname = \u0026#34;sketchybar-lua\u0026#34;; version = \u0026#34;dev\u0026#34;; src = fetchFromGitHub { owner = \u0026#34;FelixKratz\u0026#34;; repo = \u0026#34;SbarLua\u0026#34;; rev = \u0026#34;29395b1\u0026#34;; sha256 = \u0026#34;sha256-C2tg1mypz/CdUmRJ4vloPckYfZrwHxc4v8hsEow4RZs=\u0026#34;; }; nativeBuildInputs = [ gcc ]; buildInputs = [ CoreFoundation readline ]; enableParallelBuilding = true; buildPhase = \u0026#39;\u0026#39; make bin/sketchybar.so \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; mkdir -p $out/share cp bin/sketchybar.so $out/share/sketchybar.so \u0026#39;\u0026#39;; meta = with lib; { description = \u0026#34;A Lua API for SketchyBar\u0026#34;; homepage = \u0026#34;https://github.com/FelixKratz/SbarLua\u0026#34;; license = licenses.gpl3; platforms = platforms.darwin; }; } SbarLua基本上是对原有配置方式的封装, 但SketchyBar为执行配置文件的进程添加了SIGALRM信号, 使得配置文件的执行时间不超过60s. 代码放在这里:\nstatic inline bool fork_exec(char *command, struct env_vars* env_vars) { int pid = vfork(); if (pid == -1) return false; if (pid != 0) return true; alarm(FORK_TIMEOUT); exit(sync_exec(command, env_vars)); } 对于原本的shell script这是没有问题的, 但是SbarLua是包括了事件监听功能的, 需要lua进程持续运行, 因此作者在SbarLua中取消了SIGALRM(代码中的alarm(0)):\nint event_loop(lua_State* state) { g_state = state; struct stack* stack = stack_create(); stack_init(stack); stack_push(stack, UPDATE); sketchybar_call_log_and_cleanup(stack); alarm(0); mach_server_begin(\u0026amp;g_mach_server, callback_function); CFRunLoopTimerRef orphan_timer = CFRunLoopTimerCreate(kCFAllocatorDefault, CFAbsoluteTimeGetCurrent() + 1.0, 1.0, 0, 0, orphan_check, NULL ); CFRunLoopAddTimer(CFRunLoopGetMain(), orphan_timer, kCFRunLoopDefaultMode); CFRelease(orphan_timer); CFRunLoopRun(); return 0; } 显然作者期望的是直接执行配置文件, 比如作者本人是通过shebang执行sketchybarrc的:\n#!/usr/bin/env lua -- Load the sketchybar-package and prepare the helper binaries require(\u0026#34;helpers\u0026#34;) require(\u0026#34;init\u0026#34;) 然而我们是Nix, 如果Home-Manager是这样写的, 那很抱歉, 它没有执行权限!\n{ ... }: { home.file.\u0026#34;.config/sketchybar/sketchybarrc\u0026#34;.source = .config/sketchybar/sketchybarrc; } 我们可以通过Nix编写配置文件并执行, 代码放在下面. 我这里封装了一层, 因为还需要手动设置SbarLua动态库的路径. 此外代码里还手动trap了SIGALRM信号, 因为SbarLua代码中只能取消父进程的SIGALRM信号, 经过封装后SbarLua现在是sketchybar的孙子进程, 若我没有在配置文件里trap SIGALRM, 60s后执行配置文件的进程就会被杀死, SbarLua位于的孙子进程自然也不再执行. 这个问题困扰了我很久, 它会导致sketchybar运行60s后卡住, 在源码中捕获子进程的信号才终于发现了真相. 这就是自由软件的意义吧.\n{ pkgs, ... }: { services = { # other services sketchybar = { enable = true; extraPackages = [ pkgs.lua5_4_compat pkgs.sketchybar-lua ]; config = \u0026#39;\u0026#39; trap \u0026#34;\u0026#34; SIGALRM export LUA_CPATH=\u0026#34;$LUA_CPATH;${pkgs.sketchybar-lua}/share/?.so\u0026#34; export CONFIG_DIR=$HOME/.config/sketchybar cd $CONFIG_DIR lua init.lua \u0026#39;\u0026#39;; }; # other services }; } End # 写了这么多, 突然萌生出学习Apple技术栈的想法, 或许会很有趣?\n","date":"2024 June 10","externalUrl":null,"permalink":"/unix/1718005170522-macos-rice/","section":"Unix","summary":"","title":"MacOS Rice杂记","type":"unix"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/rice/","section":"Tags","summary":"","title":"Rice","type":"tags"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/sketchybar/","section":"Tags","summary":"","title":"SketchyBar","type":"tags"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/yabai/","section":"Tags","summary":"","title":"Yabai","type":"tags"},{"content":"","date":"2024 June 4","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"吉大唐班本科，浙软硕士，现在\u0026amp;未来从事图形学与游戏开发工作。\nNix/Neovim/Hyprland/Aylur\u0026rsquo;s GTK Shell探索中。\n喜欢JRPG！\n","date":"2024 June 4","externalUrl":null,"permalink":"/about/1717500731146-about/","section":"About","summary":"","title":"关于","type":"about"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"January 1 0001","externalUrl":null,"permalink":"/en/","section":"tsssni's blowfish blog","summary":"","title":"tsssni's blowfish blog","type":"page"}]