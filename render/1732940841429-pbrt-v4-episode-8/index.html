<!doctype html><html lang=zh-cn dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><title>pbrt-v4 Ep. VIII: 图像重建 &#183; tsssni's blowfish blog</title>
<meta name=title content="pbrt-v4 Ep. VIII: 图像重建 &#183; tsssni's blowfish blog"><meta name=description content="pbrt-v4 episode 8"><meta name=keywords content="graphics,rendering,pbrt,"><link rel=canonical href=https://tsssni.github.io/render/1732940841429-pbrt-v4-episode-8/><link type=text/css rel=stylesheet href=/css/main.bundle.min.3c451cff13adc9f03ed84ad472bed71f3ce32af0a5a02c86a92488a46f39d2132c8b77415cba5d090209aa152c39f494955da5508be718dd24dee647d4a5eb5f.css integrity="sha512-PEUc/xOtyfA+2ErUcr7XHzzjKvCloCyGqSSIpG850hMsi3dBXLpdCQIJqhUsOfSUlV2lUIvnGN0k3uZH1KXrXw=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.b6411b5d4cd56c0068d34c4acbce043846adad56b824e3d486a06d3459aed2eb7f7413874b7871cc2c822c8c8834cbed944022918bcc8cca710a962167c36d32.js integrity="sha512-tkEbXUzVbABo00xKy84EOEatrVa4JOPUhqBtNFmu0ut/dBOHS3hxzCyCLIyINMvtlEAikYvMjMpxCpYhZ8NtMg==" data-copy data-copied></script><script src=/lib/zoom/zoom.min.f592a181a15d2a5b042daa7f746c3721acf9063f8b6acd175d989129865a37d400ae0e85b640f9ad42cd98d1f8ad30931718cf8811abdcc5fcb264400d1a2b0c.js integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj+Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://tsssni.github.io/render/1732940841429-pbrt-v4-episode-8/"><meta property="og:site_name" content="tsssni's blowfish blog"><meta property="og:title" content="pbrt-v4 Ep. VIII: 图像重建"><meta property="og:description" content="pbrt-v4 episode 8"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="render"><meta property="article:published_time" content="2024-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-30T00:00:00+00:00"><meta property="article:tag" content="Graphics"><meta property="article:tag" content="Rendering"><meta property="article:tag" content="Pbrt"><meta property="og:image" content="https://tsssni.github.io/render/1732940841429-pbrt-v4-episode-8/featured.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tsssni.github.io/render/1732940841429-pbrt-v4-episode-8/featured.png"><meta name=twitter:title content="pbrt-v4 Ep. VIII: 图像重建"><meta name=twitter:description content="pbrt-v4 episode 8"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Rendering","name":"pbrt-v4 Ep. VIII: 图像重建","headline":"pbrt-v4 Ep. VIII: 图像重建","description":"pbrt-v4 episode 8","inLanguage":"zh-cn","url":"https:\/\/tsssni.github.io\/render\/1732940841429-pbrt-v4-episode-8\/","author":{"@type":"Person","name":""},"copyrightYear":"2024","dateCreated":"2024-11-30T00:00:00\u002b00:00","datePublished":"2024-11-30T00:00:00\u002b00:00","dateModified":"2024-11-30T00:00:00\u002b00:00","keywords":["graphics","rendering","pbrt"],"mainEntityOfPage":"true","wordCount":"14023"}]</script><script src=/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj+KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script><link type=text/css rel=stylesheet href=/lib/katex/katex.min.8fee1bb91734542a6701c61b7be516ff2eb2df248bf4e4591aacc8f4e9df40c7ca9e9c0b3f657b166f5f13e69a8fb50a139b3babcef20aeeea18f0fbcd4169fb.css integrity="sha512-j+4buRc0VCpnAcYbe+UW/y6y3ySL9ORZGqzI9OnfQMfKnpwLP2V7Fm9fE+aaj7UKE5s7q87yCu7qGPD7zUFp+w=="><script defer src=/lib/katex/katex.min.8c68eaeb75cfdcfac071717a969e1b9d9230ad52c6a2ac21ff846eaf6a258364cbb79e5e3552e32c280faeb4f4eda4d7c5bd1492e30a961c737e1e5305300281.js integrity="sha512-jGjq63XP3PrAcXF6lp4bnZIwrVLGoqwh/4Rur2olg2TLt55eNVLjLCgPrrT07aTXxb0UkuMKlhxzfh5TBTACgQ=="></script><script defer src=/lib/katex/auto-render.min.e9b2833d28623d18c071d78ef13e9c79d695122d296af3dbcee7bf1bf6518b0565bab59939267fbc8f5faf696193c20f5caef3e7501969cfb306f6738032730d.js integrity="sha512-6bKDPShiPRjAcdeO8T6cedaVEi0pavPbzue/G/ZRiwVlurWZOSZ/vI9fr2lhk8IPXK7z51AZac+zBvZzgDJzDQ==" onload=renderMathInElement(document.body)></script><script data-id=umami-script async src=https://analytics.umami.is/script.js data-website-id=e54a34b7-b153-41c0-a794-bb050c0c1abc></script><script type=text/javascript>document.querySelector('script[data-id="umami-script"]').addEventListener("load",function(){const e=document.head.querySelector('meta[property = "og:type"]').getAttribute("content");let t=document.head.querySelector('meta[property = "og:title"]').getAttribute("content"),n=document.head.querySelector('meta[property = "og:url"]').getAttribute("content");umami.track(e+":"+t,{url:n})})</script><meta name=theme-color><script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js></script><script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js></script><script src=https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js></script><script>const firebaseConfig={apiKey:"AIzaSyAB04I5m3aWYDSR1j8C79UeKrBzVRF90Qg",authDomain:"AIzaSyAB04I5m3aWYDSR1j8C79UeKrBzVRF90Qg",projectId:"tsssni-s-blowfish-blog",storageBucket:"tsssni-s-blowfish-blog.appspot.com",messagingSenderId:"1044986167854",appId:"1:1044986167854:web:d5234c7787ec0a86e215bf",measurementId:"G-S2WG8P11SW"};var app=firebase.initializeApp(firebaseConfig),db=firebase.firestore(),auth=firebase.auth()</script></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">tsssni&rsquo;s blowfish blog</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/render/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=Rendering>渲染</p></a><a href=/unix/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=Unix>Unix</p></a><a href=/acgn/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=ACGN>ACGN</p></a><a href=/about/1717500731146-about/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=关于>关于</p></a><a href class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title></p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><label id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/render/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=Rendering>渲染</p></a></li><li class=mt-1><a href=/unix/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=Unix>Unix</p></a></li><li class=mt-1><a href=/acgn/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=ACGN>ACGN</p></a></li><li class=mt-1><a href=/about/1717500731146-about/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=关于>关于</p></a></li><li class=mt-1><a href class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title></p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div class="w-full rounded-md h-36 md:h-56 lg:h-72 single_hero_basic nozoom" style=background-image:url(/render/1732940841429-pbrt-v4-episode-8/featured_hu_89f47c5067c46d7c.png)></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/plana-hero_hu_c87777a65a22491f.png)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-30 dark:opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">pbrt-v4 Ep. VIII: 图像重建</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2024-11-30T00:00:00+00:00>2024 November 30</time><span class="px-2 text-primary-500">&#183;</span><span>14023 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>28 分钟</span><span class="px-2 text-primary-500">&#183;</span><span>
<span id=views_render/1732940841429-pbrt-v4-episode-8/index.md class="animate-pulse inline-block text-transparent max-h-3 rounded-full mt-[-2px] align-middle bg-neutral-300 dark:bg-neutral-400" title=views>loading</span>
<span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 576 512"><path fill="currentcolor" d="M288 32c-80.8.0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7.0 24.6C17.3 304 48.6 356 95.4 399.4 142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7.0-24.6-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144 64.5-144 144-144 144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64-11.5.0-22.3-3-31.6-8.4-.2 2.8-.4 5.5-.4 8.4.0 53 43 96 96 96s96-43 96-96-43-96-96-96c-2.8.0-5.6.1-8.4.4 5.3 9.3 8.4 20.1 8.4 31.6z"/></svg>
</span></span></span><span class="px-2 text-primary-500">&#183;</span><span>
<span id=likes_render/1732940841429-pbrt-v4-episode-8/index.md class="animate-pulse inline-block text-transparent max-h-3 rounded-full mt-[-2px] align-middle bg-neutral-300 dark:bg-neutral-400" title=likes>loading</span>
<span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M47.6 300.4 228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6.0 115.2.0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg>
</span></span></span><span class="px-2 text-primary-500">&#183;</span><span>
<button id=button_likes class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400" onclick=process_article()>
<span id=button_likes_heart style=display:none class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M47.6 300.4 228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6.0 115.2.0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"/></svg>
</span></span><span id=button_likes_emtpty_heart class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M244 84l11.1 12 12-11.98C300.6 51.37 347 36.51 392.6 44.1 461.5 55.58 512 115.2 512 185.1V190.9c0 41.5-17.2 81.2-47.6 109.5L283.7 469.1c-7.5 7-17.4 10.9-27.7 10.9S235.8 476.1 228.3 469.1L47.59 300.4C17.23 272.1.0 232.4.0 190.9V185.1c0-69.9 50.52-129.52 119.4-141 44.7-7.59 92 7.27 124.6 39.9C243.1 84 244 84.01 244 84zm11.1 79.9-45-46.8c-21.7-20.82-52.5-30.7-82.8-25.66C81.55 99.07 48 138.7 48 185.1V190.9c0 28.2 11.71 55.2 32.34 74.4L256 429.3l175.7-164c20.6-19.2 32.3-46.2 32.3-74.4V185.1c0-46.4-33.6-86.03-79.3-93.66C354.4 86.4 323.6 96.28 301.9 117.1l-46.8 46.8z"/></svg>
</span></span><span id=button_likes_text>&nbsp;Like</span></button></span></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='return window.open("/tags/graphics/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Graphics
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='return window.open("/tags/rendering/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Rendering
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='return window.open("/tags/pbrt/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Pbrt</span></span></span></div></div><div class="flex author"><div class=place-self-center><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#采样理论>采样理论</a><ul><li><a href=#频域与fourier变换>频域与Fourier变换</a><ul><li><a href=#fourier级数>Fourier级数</a></li><li><a href=#fourier变换>Fourier变换</a></li></ul></li><li><a href=#理想采样与重建>理想采样与重建</a><ul><li><a href=#冲激函数列>冲激函数列</a></li><li><a href=#卷积>卷积</a></li><li><a href=#滤波>滤波</a></li></ul></li><li><a href=#离散fourier变换>离散Fourier变换</a></li><li><a href=#快速fourier变换>快速Fourier变换</a><ul><li><a href=#cooley-tukey-fft>Cooley-Tukey FFT</a></li><li><a href=#stockham-fft>Stockham FFT</a></li></ul></li><li><a href=#采样模式的频谱分析>采样模式的频谱分析</a></li></ul></li><li><a href=#采样与积分>采样与积分</a><ul><li><a href=#方差的fourier分析>方差的Fourier分析</a></li><li><a href=#低差异性与准monte-carlo>低差异性与准Monte Carlo</a></li></ul></li><li><a href=#采样接口>采样接口</a></li><li><a href=#独立采样器>独立采样器</a></li><li><a href=#分层采样器>分层采样器</a></li><li><a href=#halton采样器>Halton采样器</a><ul><li><a href=#hammersley与halton序列>Hammersley与Halton序列</a></li><li><a href=#扰动随机化>扰动随机化</a></li><li><a href=#halton采样器实现>Halton采样器实现</a></li><li><a href=#效果求解>效果求解</a></li></ul></li><li><a href=#sobol采样器>Sobol&rsquo;采样器</a><ul><li><a href=#元素区间的分层>元素区间的分层</a></li><li><a href=#随机化与扰动>随机化与扰动</a></li><li><a href=#样本生成>样本生成</a></li><li><a href=#全局sobol采样器>全局Sobol&rsquo;采样器</a></li><li><a href=#填充sobol采样器>填充Sobol&rsquo;采样器</a></li><li><a href=#蓝噪声sobol采样器>蓝噪声Sobol&rsquo;采样器</a></li><li><a href=#效果求解-1>效果求解</a></li></ul></li><li><a href=#图像重建>图像重建</a><ul><li><a href=#滤波器接口>滤波器接口</a></li><li><a href=#滤波器采样器>滤波器采样器</a><ul><li><a href=#一维分段函数>一维分段函数</a></li><li><a href=#二维分段函数>二维分段函数</a></li><li><a href=#窗口二维分段函数>窗口二维分段函数</a></li></ul></li><li><a href=#盒形滤波器>盒形滤波器</a></li><li><a href=#三角形滤波器>三角形滤波器</a></li><li><a href=#gaussian滤波器>Gaussian滤波器</a></li><li><a href=#mitchell滤波器>Mitchell滤波器</a></li><li><a href=#lanczos滤波器>Lanczos滤波器</a></li></ul></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#采样理论>采样理论</a><ul><li><a href=#频域与fourier变换>频域与Fourier变换</a><ul><li><a href=#fourier级数>Fourier级数</a></li><li><a href=#fourier变换>Fourier变换</a></li></ul></li><li><a href=#理想采样与重建>理想采样与重建</a><ul><li><a href=#冲激函数列>冲激函数列</a></li><li><a href=#卷积>卷积</a></li><li><a href=#滤波>滤波</a></li></ul></li><li><a href=#离散fourier变换>离散Fourier变换</a></li><li><a href=#快速fourier变换>快速Fourier变换</a><ul><li><a href=#cooley-tukey-fft>Cooley-Tukey FFT</a></li><li><a href=#stockham-fft>Stockham FFT</a></li></ul></li><li><a href=#采样模式的频谱分析>采样模式的频谱分析</a></li></ul></li><li><a href=#采样与积分>采样与积分</a><ul><li><a href=#方差的fourier分析>方差的Fourier分析</a></li><li><a href=#低差异性与准monte-carlo>低差异性与准Monte Carlo</a></li></ul></li><li><a href=#采样接口>采样接口</a></li><li><a href=#独立采样器>独立采样器</a></li><li><a href=#分层采样器>分层采样器</a></li><li><a href=#halton采样器>Halton采样器</a><ul><li><a href=#hammersley与halton序列>Hammersley与Halton序列</a></li><li><a href=#扰动随机化>扰动随机化</a></li><li><a href=#halton采样器实现>Halton采样器实现</a></li><li><a href=#效果求解>效果求解</a></li></ul></li><li><a href=#sobol采样器>Sobol&rsquo;采样器</a><ul><li><a href=#元素区间的分层>元素区间的分层</a></li><li><a href=#随机化与扰动>随机化与扰动</a></li><li><a href=#样本生成>样本生成</a></li><li><a href=#全局sobol采样器>全局Sobol&rsquo;采样器</a></li><li><a href=#填充sobol采样器>填充Sobol&rsquo;采样器</a></li><li><a href=#蓝噪声sobol采样器>蓝噪声Sobol&rsquo;采样器</a></li><li><a href=#效果求解-1>效果求解</a></li></ul></li><li><a href=#图像重建>图像重建</a><ul><li><a href=#滤波器接口>滤波器接口</a></li><li><a href=#滤波器采样器>滤波器采样器</a><ul><li><a href=#一维分段函数>一维分段函数</a></li><li><a href=#二维分段函数>二维分段函数</a></li><li><a href=#窗口二维分段函数>窗口二维分段函数</a></li></ul></li><li><a href=#盒形滤波器>盒形滤波器</a></li><li><a href=#三角形滤波器>三角形滤波器</a></li><li><a href=#gaussian滤波器>Gaussian滤波器</a></li><li><a href=#mitchell滤波器>Mitchell滤波器</a></li><li><a href=#lanczos滤波器>Lanczos滤波器</a></li></ul></li></ul></nav></div></details><script>var margin=200,marginError=50;(function(){var t=$(window),e=$("#TOCView"),s=e.height();function n(){var n=t.height()-margin;s>=n?(e.css("overflow-y","scroll"),e.css("max-height",n+marginError+"px")):(e.css("overflow-y","hidden"),e.css("max-height","9999999px"))}t.on("resize",n),$(document).ready(n)})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><p>本章主要介绍采样理论与图像滤波, 利用图像处理技术可以有效降低渲染所需的样本量.</p><h2 class="relative group">采样理论<div id=%E9%87%87%E6%A0%B7%E7%90%86%E8%AE%BA class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%87%87%E6%A0%B7%E7%90%86%E8%AE%BA aria-label=锚点>#</a></span></h2><h3 class="relative group">频域与Fourier变换<div id=%E9%A2%91%E5%9F%9F%E4%B8%8Efourier%E5%8F%98%E6%8D%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%A2%91%E5%9F%9F%E4%B8%8Efourier%E5%8F%98%E6%8D%A2 aria-label=锚点>#</a></span></h3><p>样本空间通常位于空间中, 利用Fourier变换可以转换到频域中.</p><h4 class="relative group">Fourier级数<div id=fourier%E7%BA%A7%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#fourier%E7%BA%A7%E6%95%B0 aria-label=锚点>#</a></span></h4><p>对于一个函数集合中任意不同的函数\(f(x),g(x)\)若满足\(\int_{-\infty}^{\infty} f(x)g(x) dx = 0\), 则该集合被称为正交函数系. 根据Hilbert空间理论, 可以证明三角函数系\(\lbrace\cos 0, \sin 0, \cos(\omega x), \sin(\omega x), \cos(2 \omega x), \sin(2 \omega x), &mldr;\rbrace\)为完备的正交函数系, 可以用于表示任意函数.</p><p>由此可得周期函数Fourier分解的一般形式, 频率采用\(\omega = \frac{1}{T}\)表示.</p><p>$$
\begin{equation}
f(x) = \sum_{n = 0}^{\infty} \left(a_n \cos n 2\pi \omega x + b_n \sin n 2\pi \omega x \right)
\end{equation}
$$</p><p>各项系数可以基于正交理论得到.</p><p>$$
\begin{equation}
\begin{aligned}
\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x)dx &= Ta_0\\
\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) \cos n 2\pi \omega x dx &= \int_{-\frac{T}{2}}^{\frac{T}{2}} a_n \cos^2 n 2\pi \omega x dx = \frac{T}{2}a_n\\
\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) \sin n 2\pi \omega x dx &= \int_{-\frac{T}{2}}^{\frac{T}{2}} b_n \sin^2 n 2\pi \omega x dx = \frac{T}{2}b_n
\end{aligned}
\end{equation}
$$</p><p>系数转为极坐标可获取相位.</p><p>$$
\begin{equation}
\begin{aligned}
f(x)
&= \sum_{n = 0}^{\infty} \left(c_n \cos\phi_n \cos n 2\pi \omega x + c_n\sin\phi_n \sin n 2\pi \omega x \right)\\
&= \sum_{n = 0}^{\infty} c_n \cos(n 2\pi \omega x + \phi_n)
\end{aligned}
\end{equation}
$$</p><p>基于Euler公式\(e^{ix} = \cos x + i\sin x \)可以进一步转换Fourier展开.</p><p>$$
\begin{equation}
\begin{aligned}
f(x)
&= \sum_{n=0}^{\infty} \left(a_n \frac{e^{i n 2\pi \omega x} + e^{-i n 2\pi \omega x}}{2} + b_n \frac{-i(e^{i n 2\pi \omega x} - e^{-i n 2\pi \omega x})}{2}\right)\\
&= \sum_{n=0}^{\infty} \frac{e^{i n 2\pi \omega x}(a_n - i b_n) + e^{-i n 2\pi \omega x}(a_n + i b_n)}{2}\\
&= a_0 + \sum_{n=1}^{\infty} \frac{e^{i n 2\pi \omega x}(a_n - i b_n)}{2} + \sum_{n=-\infty}^{-1} \frac{e^{i n 2\pi \omega x}(a_{-n} - i b_{-n})}{2}\\
&= \sum_{n=-\infty}^{\infty} d_n e^{i n 2\pi \omega x}
\end{aligned}
\end{equation}
$$</p><p>对于分段系数\(d_n\)分别证明可以得到如下的结论.</p><p>$$
\begin{equation}
\begin{aligned}
d_{n=0}
&= \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x)dx\\
&= \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) e^{-i n 2\pi \omega x} dx\\
d_{n > 0}
&= \frac{a_n - i b_n}{2}\\
&= \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) (\cos n 2\pi \omega x - i\sin n 2\pi \omega x) dx\\
&= \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) e^{-i n 2\pi \omega x} dx\\
d_{n &lt; 0}
&= \frac{a_{-n} + i b_{-n}}{2}\\
&= \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) (\cos (-n 2\pi \omega x) + i\sin (-n 2\pi \omega x)) dx\\
&= \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) e^{-i n 2\pi \omega x} dx\\
d_n &= \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) e^{-i n 2\pi \omega x} dx
\end{aligned}
\end{equation}
$$</p><p>经整理得到较为常用的Fourier级数的形式.</p><p>$$
\begin{equation}
F_i(x) = \frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(x) e^{-i n 2\pi \omega x} dx
\end{equation}
$$</p><h4 class="relative group">Fourier变换<div id=fourier%E5%8F%98%E6%8D%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#fourier%E5%8F%98%E6%8D%A2 aria-label=锚点>#</a></span></h4><p>Fourier级数针对周期函数, 对于非周期函数可以看作\(T \to +\infty\)的周期函数, 此时各项频率\(\frac{n}{T}\)转化为连续变化的频率\(\omega\), \(\frac{1}{T}\)转化为无穷小\(d\omega\), 由此可得下式.</p><p>$$
\begin{equation}
f(x) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(y) e^{-i 2 \pi \omega y}dy\ e^{i 2\pi \omega x} d\omega
\end{equation}
$$</p><p>从中可以提取出Fourier变换, 对于实数域其结果为偶函数.</p><p>$$
\begin{equation}
F(\omega) = \int_{-\infty}^{\infty} f(x) e^{-i 2 \pi \omega x} dx
\end{equation}
$$</p><h3 class="relative group">理想采样与重建<div id=%E7%90%86%E6%83%B3%E9%87%87%E6%A0%B7%E4%B8%8E%E9%87%8D%E5%BB%BA class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%90%86%E6%83%B3%E9%87%87%E6%A0%B7%E4%B8%8E%E9%87%8D%E5%BB%BA aria-label=锚点>#</a></span></h3><h4 class="relative group">冲激函数列<div id=%E5%86%B2%E6%BF%80%E5%87%BD%E6%95%B0%E5%88%97 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%86%B2%E6%BF%80%E5%87%BD%E6%95%B0%E5%88%97 aria-label=锚点>#</a></span></h4><p>利用Dirac方程构建周期为T的冲激函数列, 用于表示采样点分布.</p><p>$$
\begin{equation}
III_T(x) = T \sum_{n = -\infty}^{\infty} \delta(x - n T)
\end{equation}
$$</p><p>冲激函数列的Fourier展开与Fourier变换如下, Fourier变换后周期变为倒数, 在空间上较远的样本在频域上较近.</p><p>$$
\begin{equation}
\begin{aligned}
III_T(x)
&= \sum_{n=-\infty}^{\infty} e^{i n 2\pi \omega x} \int_{-\frac{T}{2}}^{\frac{T}{2}} \sum_{j = -\infty}^{\infty} \delta(x - jT) e^{-i n 2\pi \omega x} dx\\
&= \sum_{n=-\infty}^{\infty} e^{i n 2\pi \omega x} \int_{-\frac{T}{2}}^{\frac{T}{2}} \delta(x) e^{-i n 2\pi \omega x} dx\\
&= \sum_{n=-\infty}^{\infty} e^{i n 2\pi \omega x}\\
F_{III}(\omega)
&= \sum_{j=-\infty}^{\infty} \int_{-\infty}^{\infty} T \delta(x - jT) e^{-i 2\pi \omega x} dx\\
&= \sum_{n=-\infty}^{\infty} T e^{-i n 2\pi \omega T}\\
&= \frac{1}{\frac{1}{T}} \sum_{n=-\infty}^{\infty} e^{i \frac{2\pi}{\frac{1}{T}} n (-\omega)}\\
&= III_{\frac{1}{T}}(-\omega)\\
&= III_{\frac{1}{T}}(\omega)
\end{aligned}
\end{equation}
$$</p><h4 class="relative group">卷积<div id=%E5%8D%B7%E7%A7%AF class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%8D%B7%E7%A7%AF aria-label=锚点>#</a></span></h4><p>卷积定义如下.</p><p>$$
\begin{equation}
f(x) \otimes g(x) = \int_{-\infty}^{\infty} f(y)g(x-y) dy
\end{equation}
$$</p><p>通过调整积分顺序, Fourier变换具有如下的卷积定理.</p><p>$$
\begin{equation}
\begin{aligned}
\mathcal{F} \lbrace f(x) \otimes g(x) \rbrace
&= \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x)g(y-x)dx\ e^{-i 2\pi \omega y} dy\\
&= \int_{-\infty}^{\infty} f(x) \int_{-\infty}^{\infty} g(y - x) e^{-i 2\pi \omega (y - x + x)} dy dx\\
&= \int_{-\infty}^{\infty} f(x) \int_{-\infty}^{\infty} g(z) e^{-i 2\pi \omega (z + x)} dz dx\\
&= \int_{-\infty}^{\infty} f(x) e^{-i 2\pi \omega x} dx \int_{-\infty}^{\infty} g(z) e^{-i 2\pi \omega z } dz\\
&= \mathcal{F} \lbrace f(x) \rbrace \mathcal{F} \lbrace g(x) \rbrace
\end{aligned}
\end{equation}
$$</p><p>$$
\begin{equation}
\begin{aligned}
&\mathcal{F}^{-1} \lbrace \mathcal{F} \lbrace f(x) \rbrace \otimes \mathcal{F} \lbrace g(x) \rbrace \rbrace\\
&= \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(\omega) G(\phi - \omega) d\omega \ e^{i 2\pi \phi x} d\phi\\
&= \int_{-\infty}^{\infty} F(\omega) \int_{-\infty}^{\infty} G(\phi - \omega) e^{i 2\pi (\phi - \omega + \omega) x} d\phi d\omega\\
&= \int_{-\infty}^{\infty} F(\omega) e^{i 2\pi \omega x} d\omega \int_{-\infty}^{\infty} G(\theta) e^{i 2\pi \theta x} d\theta\\
&= f(x)g(x)
\end{aligned}
\end{equation}
$$</p><h4 class="relative group">滤波<div id=%E6%BB%A4%E6%B3%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%BB%A4%E6%B3%A2 aria-label=锚点>#</a></span></h4><p>对某个函数的采样结果添加滤波形式如下.</p><p>$$
\begin{equation}
\begin{aligned}
\tilde{f}(x)
&= (III_T(x)f(x))\otimes r(x)\\
&= T \sum_{i=-\infty}^{\infty} f(iT)r(x - iT)
\end{aligned}
\end{equation}
$$</p><p>Fourier变换形式如下, 可见\(\omega_{III} = \frac{1}{T} \rightarrow +\infty\), \(\mathcal{F} \lbrace f(x) \rbrace \otimes III_{\frac{1}{T}}(\omega) \rightarrow \mathcal{F} \lbrace f(x) \rbrace\), \(\omega_{III} \rightarrow 0\)导致\(\mathcal{F} \lbrace \omega \rbrace\)被复制到\(\mathcal{F} \lbrace \omega + n\omega_{III} \rbrace\). 令\(\omega_f\)为\(f(x)\)的最高频率, \(\omega_{III} &lt; 2 \omega_f\)会导致混叠, 即渲染中常见的走样现象, 系数2来自于实函数Fourier变换后为偶函数的对称性质. 由此可得Nyquist采样定理: 采样频率高于原函数频率的两倍, 即高于Nyquist频率, 可消除混叠.</p><p>$$
\begin{equation}
\begin{aligned}
\mathcal{F} \lbrace \tilde{f}(x) \rbrace
&= \mathcal{F} \lbrace III_T(x)f(x) \otimes r(x) \rbrace\\
&= \mathcal{F} \lbrace III_T(x)f(x) \rbrace \mathcal{F} \lbrace r(x) \rbrace\\
&= (\mathcal{F} \lbrace f(x) \rbrace \otimes III_{\frac{1}{T}}(\omega)) \mathcal{F} \lbrace r(x) \rbrace
\end{aligned}
\end{equation}
$$</p><p>当\(\omega_{III}\)大于Nyquist频率, 若有如下\(\mathcal{F} \lbrace r(x) \rbrace\), 可使\(\mathcal{F} \lbrace \tilde{f}(x) \rbrace = \mathcal{F} \lbrace {f}(x) \rbrace\). \(\text{sinc}_T(x)\)与\(\Pi_\frac{1}{T}(x)\)可在空域与频率相互转化, 基于\(\text{sinc}_T(x)\)设计滤波器可接近理想情况. 同样的若在空域使用\(\Pi_T\)会导致高频无法消除, 但优势在于计算量小.</p><p>$$
\begin{equation}
\begin{aligned}
\mathcal{F} \lbrace r(x) \rbrace= \Pi_{\frac{1}{T}} =
\begin{cases}
T &|\omega| &lt; \frac{1}{2T}\\
0 &\text{otherwise}
\end{cases}
\end{aligned}
\end{equation}
$$</p><h3 class="relative group">离散Fourier变换<div id=%E7%A6%BB%E6%95%A3fourier%E5%8F%98%E6%8D%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%A6%BB%E6%95%A3fourier%E5%8F%98%E6%8D%A2 aria-label=锚点>#</a></span></h3><p>实际信号多为离散采样, 按\(T\)的间隔采样\(N\)次信号. 我们认为信号的周期为\(T_f=NT\), 此时信号的Fourier变换如下.</p><p>$$
\begin{equation}
\begin{aligned}
F(\omega)
&= \int_{-\infty}^{\infty} \sum_{n = -\infty}^{\infty} f(x) \sigma(x - nT) e^{-i 2 \pi \omega x}dx\\
&= \sum_{n = -\infty}^{\infty} f(nT) e^{-i 2 \pi \omega n T}
\end{aligned}
\end{equation}
$$</p><p>根据采样定理可假设\(|\omega| &lt; \frac{1}{2T}\). 由于采样后\(F(\omega)\)周期为\(\frac{1}{T}\), 可映射\((-\frac{1}{2T}, \frac{1}{2T})\)到\((0, \frac{1}{T})\). \(f(x)\)最低频率为\(\frac{1}{T_f}=\frac{1}{NT}\), 频谱只含\(\frac{n}{NT},n \in [1, N]\), 等价于\(n \in [0, N-1]\). 根据Euler公式\(e^{-i\frac{2\pi}{N}kn}=e^{-i\frac{2\pi}{N}k(n + jN)}, j \in \mathbb{Z}\). 此时离散采样结果形式如下.</p><p>$$
\begin{equation}
F(\frac{k}{NT}) = \sum_{j = -\infty}^{\infty} \sum_{n = 0}^{N - 1} f(nT) e^{-i \frac{2\pi}{N} k n}
\end{equation}
$$</p><p>抽取出其中有效的部分即为离散Fourier变换(DFT). 从线性代数的视角看, DFT变换为\(N \times N\)方阵\(M_{ij}=e^{-i\frac{2\pi}{N}ij}\), 因此可逆且有唯一解.</p><p>$$
\begin{equation}
F[k] = \sum_{n=0}^{N-1} f[n] e^{-i \frac{2\pi}{N}nk}
\end{equation}
$$</p><p>逆离散Fourier变换(IDFT)推导结果如下, 与DFT结果相似, 因此可用类似的算法处理.</p><p>$$
\begin{equation}
\begin{aligned}
f[n]
&= \frac{1}{N} \sum_{k=0}^{N-1} F[k] e^{i \frac{2\pi}{N}nk}\\
&= \frac{1}{N} \sum_{k=0}^{N-1} \sum_{m=0}^{N-1} f[m] e^{-i \frac{2\pi}{N}(n-m)k}\\
&= \frac{1}{N} \sum_{m=0}^{N-1} f[m] \sum_{k=0}^{N-1} e^{-i \frac{2\pi}{N}(n-m)k}\\
&= f[n] + \frac{1}{N} \sum_{m=0,m \ne n}^{N-1} f[m] \frac{1 - e^{-i \frac{2\pi}{N}(n-m)N}}{1 - e^{-i \frac{2\pi}{N}(n-m)}}\\
&= f[n]
\end{aligned}
\end{equation}
$$</p><p>若有多个实信号需执行DFT, 可将其作为复数的实部与虚部, 根据三角函数处理FFT结果后可分离两项, 形式如下, 其中\(F^*\)代表共轭复数. 这个过程是可逆的, 若IDFT时已知DFT输入为实数, 将IDFT结果的实部与虚部分离即可.</p><p>$$
\begin{equation}
\begin{aligned}
H[k] &= \sum_{n=0}^{N-1} (f[n] + i g[n]) e^{-i\frac{2\pi}{N}nk}\\
F[k]
&= \frac{H[k] + \bar{H}[N - k]}{2}\\
&= \frac{1}{2}\sum_{n=0}^{N-1} (f[n] + i g[n])(c_k-i s_k)+(f[n] - i g[n])(c_{N-k}+i s_{N-k})\\
&= \frac{1}{2}\sum_{n=0}^{N-1} (f[n] + i g[n])(c_k-i s_k)+(f[n] - i g[n])(c_k-i s_k)\\
&= \sum_{n=0}^{N-1} f[n](c_k - i s_k)\\
G[k]
&= -i\frac{H[k] - \bar{H}[N - k]}{2}\\
&= \frac{1}{2}\sum_{n=0}^{N-1} (-i f[n] + g[n])(c_k-i s_k)-(-i f[n] - g[n])(c_{N-k}+i s_{N-k})\\
&= \frac{1}{2}\sum_{n=0}^{N-1} (-i f[n] + g[n])(c_k-i s_k)-(-i f[n] - g[n])(c_k-i s_k)\\
&= \sum_{n=0}^{N-1} g[n](c_k - i s_k)
\end{aligned}
\end{equation}
$$</p><h3 class="relative group">快速Fourier变换<div id=%E5%BF%AB%E9%80%9Ffourier%E5%8F%98%E6%8D%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%BF%AB%E9%80%9Ffourier%E5%8F%98%E6%8D%A2 aria-label=锚点>#</a></span></h3><h4 class="relative group">Cooley-Tukey FFT<div id=cooley-tukey-fft class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#cooley-tukey-fft aria-label=锚点>#</a></span></h4><p>将N分解为\(N=\prod_{i=0}^{s}R_i\), 特别的\(R_s=1\). 抽取DFT每项系数为\(W_N^{kn} = e^{-i \frac{2\pi}{N}kn}\), 将DFT划分为\(R_0\)份, 得到如下结果.</p><p>$$
\begin{equation}
F[k] = \sum_{r_0=0}^{R_0 - 1} \sum_{n=0}^{\frac{N}{R_0}-1}f[R_0n+r]e^{-i\frac{2\pi}{N}(R_0n+r)k}
\end{equation}
$$</p><p>令\(k=k_0+t\frac{N}{R_0},k_0\in[0,\frac{N}{R_0}-1],t_0\in[0,R_0-1]\), 重新组织上式.</p><p>$$
\begin{equation}
\begin{aligned}
&amp;F[k_0+t_0\frac{N}{R_0}]\\
&=\sum_{r_0=0}^{R_0-1}\sum_{n_0=0}^{\frac{N}{R_0}-1}f[R_0n_0+r_0]e^{-i\frac{2\pi}{N}(R_0n_0+r_0)(k_0+t_0\frac{N}{R_0})}\\
&=\sum_{r_0=0}^{R_0-1}e^{-i\frac{2\pi}{N}r_0k_0}e^{-i\frac{2\pi}{R_0}r_0t_0}\sum_{n_0=0}^{\frac{N}{R_0}-1}f[R_0n_0+r]e^{-i\frac{2\pi}{\frac{N}{R_0}}n_0k_0}
\end{aligned}
\end{equation}
$$</p><p>可以看到DFT可由\(R_0\)个子DFT组合而来, 若子DFT已知, 生成所有\(F[k]\)复杂度为\(O(n)\). 我们认为\(k_0\)所需的第\(r_0\)个子DFT结果存储在\(k_0+r_0\frac{N}{R_0}\), 上式被表示为如下形式.</p><p>$$
\begin{equation}
F[k_0+t_0\frac{N}{R_0}]
=\sum_{r_0=0}^{R_0 - 1}W_N^{r_0k_0}W_{R_0}^{r_0t_0}F_{R_0}[k_0+r_0\frac{N}{R_0}]
\end{equation}
$$</p><p>令\(k_1\in[0,\frac{N}{R_0R_1}-1],t_1\in[0,R_1-1]\), 继续分解子问题, 结果如下.</p><p>$$
\begin{equation}
\begin{aligned}
&amp;F_{R_0}[k_1+t_1\frac{N}{R_0R_1}+r_0\frac{N}{R_0}]\\
&=\sum_{r_1=0}^{R_1-1}\sum_{n_1=0}^{\frac{N}{R_0R_1}-1}f[R_0R_1n_1+R_0r_1+r_0]e^{-i\frac{2\pi}{\frac{N}{R_0}}(R_1n_1+r_1)(k_1+t_1\frac{N}{R_0R_1})}\\
&=\sum_{r_1=0}^{R_1-1}\sum_{n_1=0}^{\frac{N}{R_0R_1}-1}W_{\frac{N}{R_0}}^{r_1k_1}W_{R_1}^{r_1t_1}F_{R_1}[k_1+r_1\frac{N}{R_0R_1}+r_0\frac{N}{R_0}]
\end{aligned}
\end{equation}
$$</p><p>令\(k_s\in[0,\frac{N}{\prod_{i=0}^sR_i}-1],t_s\in[0,R_s-1]\), 分解到最底层可得如下结果.</p><p>$$
\begin{equation}
\begin{aligned}
&amp;F_{R_{s-1}}[k_s+t_s\frac{N}{\prod_{i=0}^sR_i}+\sum_{i=0}^{s-1}\frac{N}{\prod_{j=0}^iR_j}r_i]\\
&=\sum_{r_s=0}^{R_s-1}\sum_{n_s=0}^{\frac{N}{\prod_{i=0}^sR_i}-1}W_{\frac{N}{\prod_{i=0}^{s-1}R_i}}^{r_sk_s}W_{R_s}^{r_st_s}\sum_{n_s=0}^{\frac{N}{\prod_{i=0}^sR_i}-1}f[(\prod_{i=0}^sR_i)n_s+\sum_{i=0}^{s}(\prod_{j=0}^{i-1}R_j)r_i]W_{\frac{N}{\prod_{i=0}^sR_i}}^{n_sk_s}
\end{aligned}
\end{equation}
$$</p><p>由于我们定义了\(R_s=1\), 此时\(k_s=t_s=n_s=0\), \(W\)均为1, 求和均只有一项, 因此相当于将\(f[\sum_{i=0}^{s-1}(\prod_{j=0}^{i-1}R_j)r_i]\)映射到\(F_{R_{s-1}}[\sum_{i=0}^{s-1}\frac{N}{\prod_{j=0}^iR_j}r_i]\). 将第\(s-1\)层的序号表示为\(K_{s-1}\), 可得如下映射关系.</p><p>$$
\begin{equation}
F_{R_{s-1}}[K_{s-1}]=f[\sum_{i=0}^{s-1}\frac{K_{s-1}\bmod\frac{N}{\prod_{j=0}^{i-1}R_j}}{\left\lfloor \frac{N}{\prod_{j=0}^iR_j} \right\rfloor}\prod_{j=0}^{i-1}R_j]
\end{equation}
$$</p><p>令\(i\in[0,s-1]\), 对于第\(i\)层的第\(K_i\)项, 我们已经确定要读取子DFT中的第\(K_i-K_i\bmod\frac{N}{\prod_{j=0}^{i-1}R_j}+n\frac{N}{\prod_{j=0}^{i}R_j}\)项, \(n\in[0,R_i-1]\), 因此最底层映射完成后即可逐层求解, 得到Cooley-Tukey FFT.</p><p>特别的, 若对任意\(i\)满足\(R_i=2^n\), 则最底层的映射过程相当于将二进制每\(n\)为打包为\(1\)组, 以组为单位逆向排序得到新的序号, 对于\(n=1\)则表现为位反转.</p><h4 class="relative group">Stockham FFT<div id=stockham-fft class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#stockham-fft aria-label=锚点>#</a></span></h4><p>将\(R_0\)对应的子DFT存储在\(R_0k_0+r_0\), 得到如下形式.</p><p>$$
\begin{equation}
F[k_0+t_0\frac{N}{R_0}]
=\sum_{r_0=0}^{R_0 - 1}W_N^{r_0k_0}W_{R_0}^{r_0t_0}F_{R_0}[R_0k_0+r_0]
\end{equation}
$$</p><p>分解为\(R_1\)子DFT, 结果如下.</p><p>$$
\begin{equation}
\begin{aligned}
&amp;F_{R_0}[R_0(k_1+t_1\frac{N}{R_0R_1})+r_0]\\
&=F_{R_0}[R_0k_1+t_1\frac{N}{R_1}+r_0]\\
&=\sum_{r_1=0}^{R_1 - 1}W_\frac{N}{R_0}^{r_1k_1}W_{R_1}^{r_1t_1}F_{R_1}[R_0R_1k_1+R_0r_1+r_0]
\end{aligned}
\end{equation}
$$</p><p>最底层结果如下, \(f[\sum_{i=0}^{s-1}(\prod_{j=0}^{i-1}R_j)r_i]\)与\(F_{R_{s-1}}[\sum_{i=0}^{s-1}(\prod_{j=0}^{i-1})R_jr_i]\)等价, 无需映射及重排.</p><p>$$
\begin{equation}
\begin{aligned}
&amp;F_{R_{s-1}}[(\prod_{i=0}^{s-1}R_i)k_s+t_s\frac{N}{R_s}+\sum_{i=0}^{s-1}(\prod_{j=0}^{i-1}R_j)r_i]\\
&=\sum_{r_s=0}^{R_s - 1}W_\frac{N}{\prod_{i=0}^{s-1}R_i}^{r_sk_s}W_{R_s}^{r_st_s}\sum_{n_s=0}^{\frac{N}{\prod_{i=0}^sR_i}-1}f[(\prod_{i=0}^sR_i)n_s+\sum_{i=0}^{s}(\prod_{j=0}^{i-1}R_j)r_i]W_{\frac{N}{\prod_{i=0}^sR_i}}^{n_sk_s}
\end{aligned}
\end{equation}
$$</p><p>此时已知\(K_i\)需要读取\(\left\lfloor\frac{K_i\bmod\frac{N}{R_{i+1}}}{\prod_{j=0}^iR_j}\right\rfloor\prod_{j=0}^{i+1}R_j+K_i\bmod\prod_{j=0}^iR_j+n\prod_{j=0}^iR_j\)项, \(n\in[0,R_{i+1}-1]\), 得到Stockham FFT.</p><p>\(K_i\)需读取的各项的距离为\(\prod_{j=0}^iR_j\), 但共享子问题的\(K_i\)的距离为\(\frac{N}{R_{i+1}}\), 若保持二者对齐则映射关系如下.</p><p>$$
\begin{equation}
\begin{aligned}
&amp;K^&rsquo;_{i+1}\\
&=k_{i+1}\prod_{j=0}^iR_j+r_{i+1}\frac{N}{R_{i+1}}+K_{i+1}\bmod\prod_{j=0}^iR_j\\
&=\left\lfloor\frac{K_{i+1}}{\prod_{j=0}^{i+1}R_j}\right\rfloor\prod_{j=0}^iR_j+\left\lfloor\frac{K_{i+1}\bmod\prod_{j=0}^{i+1}R_j}{\prod_{j=0}^iR_j}\right\rfloor\frac{N}{R_{i+1}}+K_{i+1}\bmod\prod_{j=0}^iR_j\\
\end{aligned}
\end{equation}
$$</p><h3 class="relative group">采样模式的频谱分析<div id=%E9%87%87%E6%A0%B7%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%87%87%E6%A0%B7%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90 aria-label=锚点>#</a></span></h3><p>采样率固定时需分析采样点的分布对质量的影响, 对于难以分析频域特征的随机性采样模式, 需要针对每次生成的样本分析频谱特征.</p><p>数学上信号功率为由信号函数的平方, 功率谱密度(PSD)可用于频谱分析. 根据Wiener-Khinchin定理它可通过自相关函数的Fourier变换计算, 整理后为Fourier变换结果与其共轭函数的乘积. 由卷积定理可得不同函数乘积的PSD为二者PSD的卷积.</p><p>$$
\begin{equation}
\begin{aligned}
\mathcal{F}[\mathcal{R}(\chi)]
&= \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x) f(x + \chi) e^{-i 2\pi \omega \chi} d\chi dx\\
&= \int_{-\infty}^{\infty} f(x) \int_{-\infty}^{\infty} f(x + \chi) e^{-i 2\pi \omega \chi} d\chi dx\\
&= \int_{-\infty}^{\infty} f(x) e^{i 2\pi \omega x} \int_{-\infty}^{\infty} f(x + \chi) e^{-i 2\pi \omega (x + \chi)} d(x + \chi) dx\\
&= F(\omega) \overline{F(\omega)}
\end{aligned}
\end{equation}
$$</p><p>对于采样密度为无穷的理想采样, 其PSD为位于原点的Dirac delta函数. 对于随机采样可以通过数值方法计算PSD, 将每个采样点视为一个Dirac delta函数, 从而将积分转为求和. 通过对均匀采样添加均匀分布的抖动\(\epsilon\)获得的PSD的期望如下, 此时在原点为Dirac delta, 低频下功率接近0, 高频下接近1. 基于图片的能量都集中在低频的假设, 此时通过图片PSD与抖动采样PSD之间的卷积高频能量被分散到低频中, 形成高频噪声, 与低频走样相比人类视觉对噪声的接受程度更高.</p><p>$$
\begin{equation}
\begin{aligned}
s_T(x) &= \sum_{n = -\infty}^{\infty} \delta(x - (i + \frac{1}{2} - \epsilon)T)\\
P_s(\omega) &= 1 - \text{sinc}^2(\frac{T\omega}{2}) + \delta(\omega)
\end{aligned}
\end{equation}
$$</p><p>PSD有时通过颜色描述, 例如白噪声是功率均匀分布的, 蓝噪声则集中在高频, 这与对应颜色的光的性质是相似的. 渲染中通常会使用预计算的噪声贴图, 可以观察到蓝噪声像素之前差异性更大, 白噪声则有相似像素聚集的现象.</p><h2 class="relative group">采样与积分<div id=%E9%87%87%E6%A0%B7%E4%B8%8E%E7%A7%AF%E5%88%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%87%87%E6%A0%B7%E4%B8%8E%E7%A7%AF%E5%88%86 aria-label=锚点>#</a></span></h2><h3 class="relative group">方差的Fourier分析<div id=%E6%96%B9%E5%B7%AE%E7%9A%84fourier%E5%88%86%E6%9E%90 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%96%B9%E5%B7%AE%E7%9A%84fourier%E5%88%86%E6%9E%90 aria-label=锚点>#</a></span></h3><p>图形学中的Monte Carlo采样通常位于\([0,1]^d\)中, 因此后续Fourier分析都在此基础上简化.</p><p>与Fourier变换后的PSD类似, 函数的PSD可以分解为Fourier级数每项的PSD, 对于实偶函数这相当于Fourier系数的平方.</p><p>$$
\begin{equation}
\begin{aligned}
P_f(n)
&= f_n e^{-i n 2\pi x} \overline{f_n} e^{i n 2\pi x}\\
&= f_n \overline{f_n}
\end{aligned}
\end{equation}
$$</p><p>对于Monte Carlo, 可将其看作多次采样的平均, 可以将这个过程用Dirac delta函数表示.</p><p>$$
\begin{equation}
\begin{aligned}
s(x) &= \frac{1}{n} \sum_{i=1}^{n} \delta(x - x_i)\\
\int_0^1 f(x) dx
&\approx \frac{1}{n} \sum_{i=1}^n f(x_i)\\
&= \int_0^1 f(x) s(x) dx\\
&= \int_0^1 \sum_{n = -\infty}^{\infty} s_n e^{i n 2\pi x} f(x) dx\\
&= \sum_{n = -\infty}^{\infty} \int_0^1 f(x) e^{i n 2\pi x} dx \int_0^1 s(y) e^{-i n 2\pi y} dy\\
&= \sum_{n = -\infty}^{\infty} \overline{f_n} s_n
\end{aligned}
\end{equation}
$$</p><p>由于\(f_0 = \int_0^1 f(x) dx\), Monte Carlo的误差分析可以转为如下形式.</p><p>$$
\begin{equation}
\left|\int_0^1 f(x) dx - \int_0^1 f(x) s(x) dx\right| = \left|f_0 - \sum_{n = -\infty}^{\infty} \overline{f_n} s_n\right| = \sum_{n = -\infty, n \ne 0}^{\infty} \overline{f_n} s_n
\end{equation}
$$</p><p>由于Fourier系数的正交性, 在实函数下方差即为二者PSD的乘积. 可以看出当二者的功率谱分布为负相关时可以取得最小的方差. 对于均匀分布采样或者白噪声采样, 此时Fourier系数为\(\frac{1}{n}\), 由此可得方差为\(O(\frac{1}{n})\). 同样的, 对于Possion圆盘采样进行Fourier分析后可以看出它的方差是劣于抖动采样的.</p><p>$$
\begin{equation}
\begin{aligned}
Var[\frac{1}{n} \sum_{i=1}^n f(x_i)]
&= (\sum_{n = -\infty, n \ne 0}^{\infty} \overline{f_n} s_n)^2\\
&= \sum_{n = -\infty, n \ne 0}^{\infty} \overline{f_n}^2 s_n^2\\
&= \sum_{n = -\infty, n \ne 0}^{\infty} P_f(n) P_s(n)
\end{aligned}
\end{equation}
$$</p><h3 class="relative group">低差异性与准Monte Carlo<div id=%E4%BD%8E%E5%B7%AE%E5%BC%82%E6%80%A7%E4%B8%8E%E5%87%86monte-carlo class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%BD%8E%E5%B7%AE%E5%BC%82%E6%80%A7%E4%B8%8E%E5%87%86monte-carlo aria-label=锚点>#</a></span></h3><p>采样点的质量可以通过差异性来度量. 我们将固定数量的一些采样点称为采样点集, 由某种算法去生成的任意数量采样点被称为采样点序列. 通过比较每个采样点实际所占的体积与平均分配给每个点的体积可以评估这个采样序列的差异性.</p><p>令P为采样点集, \(B\)为\([0,1]^d\)的子集区域即\([0, v_0] \times [0, v_1] \times \dots \times [0, v_d]\), \(b\)为\(B\)这一集合中的某个元素, \(V(b)\)为\(b\)所占的体积, \(\sharp{x_i \in b}\)为落在\(b\)中的采样点的数量, \(\sup\)为上确界, 此时差异性可以按如下方式定义.</p><p>$$
\begin{equation}
D_n(B, P) = \sup_{b \in B} \left| \frac{\sharp{x_i \in b}}{n} - V(b) \right|
\end{equation}
$$</p><p>在一维上\(x_i = \frac{i - \frac{1}{2}}{n}\)可以获得最小的差异性. 对于大部分低差异性序列在高维下是具有更弱的均匀性的, 因此可以缓解出现前文所说的均匀采样带来的走样问题, 当然其固有的均匀性还是会使得它比伪随机序列更易产生走样. 低差异性序列所具有的差异性小于\(O(\frac{(log\ n)^d}{n})\)即可认为是低差异性序列.</p><p>低差异性序列通常通过确定的算法生成, 采用低差异性序列执行Monte Carlo即为准Monte Carlo(quasi-Monte Carlo, QMC). 根据Koksma-Hlawka不等式可以得到低差异性序列采样的误差上界, 其中\(V_f\)代表总变差. 随着维数增加, 差异性会趋向于\(n^{-1}\), 这使得QMC的误差小于MC的\(n^{-\frac{1}{2}}\), 尤其是样本较少的情况. 由于低差异性序列是确定的, 以方差作为度量手段是不适用的, 可以通过在不影响差异性的情况下对序列进行随机化来执行随机准Monte Carlo(randomized quasi-Monte Carlo, RQMC), 这会加速积分的收敛, 后面的部分会介绍.</p><p>$$
\begin{equation}
\begin{aligned}
\left| \int_0^1 f(x) dx - \frac{1}{n} \sum_{i = 1}^n f(x_i) \right| \le D_n(B, P) V_f\\
V_f = \sup_{0 = y_1 &lt; y_2 &lt; \dots &lt; y_n = 1} \sum_{i=1}^{m} |f(y_i) - f(y_{i + 1})|
\end{aligned}
\end{equation}
$$</p><h2 class="relative group">采样接口<div id=%E9%87%87%E6%A0%B7%E6%8E%A5%E5%8F%A3 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%87%87%E6%A0%B7%E6%8E%A5%E5%8F%A3 aria-label=锚点>#</a></span></h2><p><code>Sampler</code>的实现需要支持生成在任意维数上的任意数量的样本. 由于低差异性序列确定性的特征, 采样失败时可以快速定位到样本序号并调试, 当然分支代码可能导致运行时的样本编号是不同的, 需要尽量避免分支. 渲染任务只需要使用最高二维的样本, 因此没有提供相关接口, 更高维的样本可以通过组合低维样本实现.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sampler</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=k>public</span> <span class=n>TaggedPointer</span><span class=o>&lt;</span>  <span class=c1>// Sampler Types
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>PMJ02BNSampler</span><span class=p>,</span> <span class=n>IndependentSampler</span><span class=p>,</span> <span class=n>StratifiedSampler</span><span class=p>,</span> <span class=n>HaltonSampler</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>PaddedSobolSampler</span><span class=p>,</span> <span class=n>SobolSampler</span><span class=p>,</span> <span class=n>ZSobolSampler</span><span class=p>,</span> <span class=n>MLTSampler</span><span class=p>,</span> <span class=n>DebugMLTSampler</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Sampler Interface
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>TaggedPointer</span><span class=o>::</span><span class=n>TaggedPointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Sampler</span> <span class=nf>Create</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=n>ParameterDictionary</span> <span class=o>&amp;</span><span class=n>parameters</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=n>Point2i</span> <span class=n>fullResolution</span><span class=p>,</span> <span class=k>const</span> <span class=n>FileLoc</span> <span class=o>*</span><span class=n>loc</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>SamplesPerPixel</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>StartPixelSample</span><span class=p>(</span><span class=n>Point2i</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sampleIndex</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                              <span class=kt>int</span> <span class=n>dimension</span> <span class=o>=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Float</span> <span class=nf>Get1D</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Point2f</span> <span class=nf>Get2D</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Point2f</span> <span class=nf>GetPixel2D</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Sampler</span> <span class=nf>Clone</span><span class=p>(</span><span class=n>Allocator</span> <span class=n>alloc</span> <span class=o>=</span> <span class=p>{});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 class="relative group">独立采样器<div id=%E7%8B%AC%E7%AB%8B%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%8B%AC%E7%AB%8B%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h2><p><code>IndependentSampler</code>用于生成伪随机样本, 可以在构造函数中设置随机数种子, 通常用于baseline来与其它采样器比较.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>IndependentSampler</span><span class=p>(</span><span class=kt>int</span> <span class=n>samplesPerPixel</span><span class=p>,</span> <span class=kt>int</span> <span class=n>seed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>samplesPerPixel</span><span class=p>(</span><span class=n>samplesPerPixel</span><span class=p>),</span> <span class=n>seed</span><span class=p>(</span><span class=n>seed</span><span class=p>)</span> <span class=p>{}</span>
</span></span></code></pre></div><p>在设置初始采样位置时<code>IndependentSampler</code>会根据像素位置, 样本序号与当前维度决定初始偏移. <code>rng</code>是<code>RNG</code>类型的成员变量, 即随机数生成器(random number generator).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>StartPixelSample</span><span class=p>(</span><span class=n>Point2i</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sampleIndex</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dimension</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rng</span><span class=p>.</span><span class=n>SetSequence</span><span class=p>(</span><span class=n>Hash</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>seed</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>rng</span><span class=p>.</span><span class=n>Advance</span><span class=p>(</span><span class=n>sampleIndex</span> <span class=o>*</span> <span class=mi>65536ull</span> <span class=o>+</span> <span class=n>dimension</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 class="relative group">分层采样器<div id=%E5%88%86%E5%B1%82%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%88%86%E5%B1%82%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h2><p><code>StratifiedSampler</code>负责分层抽样, 会在每层的中心点添加均匀分布的抖动, 如前文所述这会将走样转为噪声.</p><p>在高维下分层抽样会产生过多的样本, 例如包括镜头位置和时间时共有五个维度, 若分为四层则有\(4^5 = 1024\)个样本. 可以通过减少某些维度的层数来缓解这一问题, 同样这也会降低渲染质量. pbrt通过填充(padding)方法来解决这一问题, 即低维完整分层, 高层随机选择, 例如在像素位置与镜头位置上使用分层后的所有样本, 而时间则随机选择某一层的样本, 这可以较好的覆盖样本空间.</p><p>每个维度上的样本都需要进行混排(shuffle), 以避免不同维度相同序号的样本的相关性. 在pbrt中这通过随机化当前层的序号来实现, 通过向<code>PermutationElement</code>输入当前序号, 样本数以及随机种子来实现. 这里维度是递增的, 因此需要为每个样本序号都执行<code>StartPixelSample</code>来生成下一组采样点.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>Get1D</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute _stratum_ index for current pixel and dimension
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>hash</span> <span class=o>=</span> <span class=n>Hash</span><span class=p>(</span><span class=n>pixel</span><span class=p>,</span> <span class=n>dimension</span><span class=p>,</span> <span class=n>seed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>stratum</span> <span class=o>=</span> <span class=n>PermutationElement</span><span class=p>(</span><span class=n>sampleIndex</span><span class=p>,</span> <span class=n>SamplesPerPixel</span><span class=p>(),</span> <span class=n>hash</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>dimension</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>delta</span> <span class=o>=</span> <span class=n>jitter</span> <span class=o>?</span> <span class=n>rng</span><span class=p>.</span><span class=n>Uniform</span><span class=o>&lt;</span><span class=n>Float</span><span class=o>&gt;</span><span class=p>()</span> <span class=o>:</span> <span class=mf>0.5f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>stratum</span> <span class=o>+</span> <span class=n>delta</span><span class=p>)</span> <span class=o>/</span> <span class=n>SamplesPerPixel</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>分层采样器的差异性为\(O(\frac{\sqrt{d log\ n}}{n^{\frac{1}{2} + \frac{1}{2d}}})\), 不符合低差异性序列的要求.</p><h2 class="relative group">Halton采样器<div id=halton%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#halton%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h2><p><code>HaltonSampler</code>通过Halton低差异性序列来在各个维度上生成分布良好的采样点.</p><h3 class="relative group">Hammersley与Halton序列<div id=hammersley%E4%B8%8Ehalton%E5%BA%8F%E5%88%97 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#hammersley%E4%B8%8Ehalton%E5%BA%8F%E5%88%97 aria-label=锚点>#</a></span></h3><p>Hammersley与Halton序列都通过基反演生成, 即将整数数转化为\(b\)进制后映射到小数位上. van der Corput序列即为一维上递增序号的基2反演, 差异性为\(O(\frac{log\ n}{n})\).</p><p>$$
\begin{equation}
\begin{aligned}
a &= \sum_{i=1}^{n} d_i(a) b^{i - 1}\\
\phi_b(a) &= \sum_{i=1}^{n} d_i(a) b^{-i}
\end{aligned}
\end{equation}
$$</p><p>在每个维度上使用互质的基数即可得到Halton序列, 通常选用递增的质数, 差异性为\(O(\frac{(log\ n)^d}{n})\).</p><p>$$
\begin{equation}
x_a = (\phi_2(a), \phi_3(a), \phi_5(a),\dots, \phi_{p_d}(a))
\end{equation}
$$</p><p>若样本数是确定的, 可以使用Hammersley序列, 同样需要基数互质, Hammersley的差异性比Halton略小.</p><p>$$
\begin{equation}
x_a = (\frac{a}{n}, \phi_{b_1}(a), \phi_{b_2}(a), \dots, \phi_{b_{d-1}}(a))
\end{equation}
$$</p><p>pbrt通过<code>RadicalInverse</code>计算基反演, 同样也支持其逆过程.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Low Discrepancy Inline Functions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Float</span> <span class=nf>RadicalInverse</span><span class=p>(</span><span class=kt>int</span> <span class=n>baseIndex</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>base</span> <span class=o>=</span> <span class=n>Primes</span><span class=p>[</span><span class=n>baseIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We have to stop once reversedDigits is &gt;= limit since otherwise the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// next digit of |a| may cause reversedDigits to overflow.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>limit</span> <span class=o>=</span> <span class=o>~</span><span class=mi>0ull</span> <span class=o>/</span> <span class=n>base</span> <span class=o>-</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>invBase</span> <span class=o>=</span> <span class=p>(</span><span class=n>Float</span><span class=p>)</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>Float</span><span class=p>)</span><span class=n>base</span><span class=p>,</span> <span class=n>invBaseM</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>reversedDigits</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>a</span> <span class=o>&amp;&amp;</span> <span class=n>reversedDigits</span> <span class=o>&lt;</span> <span class=n>limit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Extract least significant digit from _a_ and update _reversedDigits_
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint64_t</span> <span class=n>next</span> <span class=o>=</span> <span class=n>a</span> <span class=o>/</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>digit</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-</span> <span class=n>next</span> <span class=o>*</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>reversedDigits</span> <span class=o>=</span> <span class=n>reversedDigits</span> <span class=o>*</span> <span class=n>base</span> <span class=o>+</span> <span class=n>digit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>invBaseM</span> <span class=o>*=</span> <span class=n>invBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>reversedDigits</span> <span class=o>*</span> <span class=n>invBaseM</span><span class=p>,</span> <span class=n>OneMinusEpsilon</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=kt>uint64_t</span> <span class=nf>InverseRadicalInverse</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>inverse</span><span class=p>,</span> <span class=kt>int</span> <span class=n>base</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                   <span class=kt>int</span> <span class=n>nDigits</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nDigits</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>digit</span> <span class=o>=</span> <span class=n>inverse</span> <span class=o>%</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>inverse</span> <span class=o>/=</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>index</span> <span class=o>=</span> <span class=n>index</span> <span class=o>*</span> <span class=n>base</span> <span class=o>+</span> <span class=n>digit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">扰动随机化<div id=%E6%89%B0%E5%8A%A8%E9%9A%8F%E6%9C%BA%E5%8C%96 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%89%B0%E5%8A%A8%E9%9A%8F%E6%9C%BA%E5%8C%96 aria-label=锚点>#</a></span></h3><p>确定性序列使得方差无法被估计, 且Halton序列在高维下会呈现一定的规则, 不利于收敛. 通过对采样点的每一位进行扰动可以解决这一问题, 这种情况下基反演之前的每一位都需要被考虑, 原本对于较小的数高位上的0是可以省略的, 且每一位都需要采用不同的扰动, 否则扰动前后的数仍然具有相似的特征.</p><p>pbrt通过<code>DigitPermutation</code>实现数位的扰动, 在构造函数中计算出需要的位数以及所有扰动结果, 为了节省空间采用<code>uint16_t</code>存储扰动结果. 若1减去当前位的最大值仍为1, 则后续位的计算已经小于最高精度, 不需要再计算. <code>pbrt</code>的<code>PermutationElement</code>采用伪随机.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>DigitPermutation</span><span class=p>(</span><span class=kt>int</span> <span class=n>base</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>seed</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>)</span> <span class=o>:</span> <span class=n>base</span><span class=p>(</span><span class=n>base</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CHECK_LT</span><span class=p>(</span><span class=n>base</span><span class=p>,</span> <span class=mi>65536</span><span class=p>);</span>  <span class=c1>// uint16_t
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Compute number of digits needed for _base_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>nDigits</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>invBase</span> <span class=o>=</span> <span class=p>(</span><span class=n>Float</span><span class=p>)</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>Float</span><span class=p>)</span><span class=n>base</span><span class=p>,</span> <span class=n>invBaseM</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=p>(</span><span class=n>base</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>invBaseM</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>nDigits</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>invBaseM</span> <span class=o>*=</span> <span class=n>invBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>permutations</span> <span class=o>=</span> <span class=n>alloc</span><span class=p>.</span><span class=n>allocate_object</span><span class=o>&lt;</span><span class=kt>uint16_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>nDigits</span> <span class=o>*</span> <span class=n>base</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute random permutations for all digits
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>digitIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>digitIndex</span> <span class=o>&lt;</span> <span class=n>nDigits</span><span class=p>;</span> <span class=o>++</span><span class=n>digitIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>dseed</span> <span class=o>=</span> <span class=n>Hash</span><span class=p>(</span><span class=n>base</span><span class=p>,</span> <span class=n>digitIndex</span><span class=p>,</span> <span class=n>seed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>digitValue</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>digitValue</span> <span class=o>&lt;</span> <span class=n>base</span><span class=p>;</span> <span class=o>++</span><span class=n>digitValue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>digitIndex</span> <span class=o>*</span> <span class=n>base</span> <span class=o>+</span> <span class=n>digitValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>permutations</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>PermutationElement</span><span class=p>(</span><span class=n>digitValue</span><span class=p>,</span> <span class=n>base</span><span class=p>,</span> <span class=n>dseed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Owen扰动通过考虑当前处理的位之前的所有位上的数字来实现更优的扰动, 这通过将之前位的扰动结果加入到Hash中来实现.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Float</span> <span class=nf>OwenScrambledRadicalInverse</span><span class=p>(</span><span class=kt>int</span> <span class=n>baseIndex</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>a</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=kt>uint32_t</span> <span class=n>hash</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>base</span> <span class=o>=</span> <span class=n>Primes</span><span class=p>[</span><span class=n>baseIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We have to stop once reversedDigits is &gt;= limit since otherwise the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// next digit of |a| may cause reversedDigits to overflow.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>limit</span> <span class=o>=</span> <span class=o>~</span><span class=mi>0ull</span> <span class=o>/</span> <span class=n>base</span> <span class=o>-</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>invBase</span> <span class=o>=</span> <span class=p>(</span><span class=n>Float</span><span class=p>)</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>Float</span><span class=p>)</span><span class=n>base</span><span class=p>,</span> <span class=n>invBaseM</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>reversedDigits</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>digitIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>invBaseM</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>reversedDigits</span> <span class=o>&lt;</span> <span class=n>limit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Compute Owen-scrambled digit for _digitIndex_
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint64_t</span> <span class=n>next</span> <span class=o>=</span> <span class=n>a</span> <span class=o>/</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>digitValue</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-</span> <span class=n>next</span> <span class=o>*</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>digitHash</span> <span class=o>=</span> <span class=n>MixBits</span><span class=p>(</span><span class=n>hash</span> <span class=o>^</span> <span class=n>reversedDigits</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>digitValue</span> <span class=o>=</span> <span class=n>PermutationElement</span><span class=p>(</span><span class=n>digitValue</span><span class=p>,</span> <span class=n>base</span><span class=p>,</span> <span class=n>digitHash</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reversedDigits</span> <span class=o>=</span> <span class=n>reversedDigits</span> <span class=o>*</span> <span class=n>base</span> <span class=o>+</span> <span class=n>digitValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>invBaseM</span> <span class=o>*=</span> <span class=n>invBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>digitIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>invBaseM</span> <span class=o>*</span> <span class=n>reversedDigits</span><span class=p>,</span> <span class=n>OneMinusEpsilon</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">Halton采样器实现<div id=halton%E9%87%87%E6%A0%B7%E5%99%A8%E5%AE%9E%E7%8E%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#halton%E9%87%87%E6%A0%B7%E5%99%A8%E5%AE%9E%E7%8E%B0 aria-label=锚点>#</a></span></h3><p>Halton采样器会根据当前采样点编号的基反演结果的缩放取整确定其所位于的像素, 然后在对基反演结果进行扰动, 这使得相邻像素之间的样本不会相距过近. pbrt中缩放的最大值是128, 所以只保证图像某个区域内点不会过于集中, 同时也防止过大的缩放导致的浮点精度问题. 缩放值是基数的幂, 这使得缩放与位的左移保持一致.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>HaltonSampler</span><span class=o>::</span><span class=n>HaltonSampler</span><span class=p>(</span><span class=kt>int</span> <span class=n>samplesPerPixel</span><span class=p>,</span> <span class=n>Point2i</span> <span class=n>fullRes</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=n>RandomizeStrategy</span> <span class=n>randomize</span><span class=p>,</span> <span class=kt>int</span> <span class=n>seed</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>samplesPerPixel</span><span class=p>(</span><span class=n>samplesPerPixel</span><span class=p>),</span> <span class=n>randomize</span><span class=p>(</span><span class=n>randomize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>randomize</span> <span class=o>==</span> <span class=n>RandomizeStrategy</span><span class=o>::</span><span class=n>PermuteDigits</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>digitPermutations</span> <span class=o>=</span> <span class=n>ComputeRadicalInversePermutations</span><span class=p>(</span><span class=n>seed</span><span class=p>,</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Find radical inverse base scales and exponents that cover sampling area
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>base</span> <span class=o>=</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=mi>2</span> <span class=o>:</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>scale</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>exp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>scale</span> <span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>fullRes</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>MaxHaltonResolution</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>scale</span> <span class=o>*=</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>exp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>baseScales</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>baseExponents</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>exp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute multiplicative inverses for _baseScales_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>multInverse</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>multiplicativeInverse</span><span class=p>(</span><span class=n>baseScales</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>baseScales</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>multInverse</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>multiplicativeInverse</span><span class=p>(</span><span class=n>baseScales</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>baseScales</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以通过计算像素的<code>InverseRadicalInverse</code>获取当前像素对应的采样点序号, 令计算结果为\((x_r, y_r)\), 二维Halton下\((x, y)\)上的缩放分别为\((2^j, 3^k)\), 只要序号i满足\(x_r \equiv i \pmod {2^j}\)和\(y_r \equiv i \pmod {3^k}\)即可, 这里构成了一个一元线性同余方程, 可以通过中国剩余定理求解. 此时可以实现<code>StartPixelSample</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>StartPixelSample</span><span class=p>(</span><span class=n>Point2i</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sampleIndex</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dim</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>haltonIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sampleStride</span> <span class=o>=</span> <span class=n>baseScales</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>baseScales</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute Halton sample index for first sample in pixel _p_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sampleStride</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Point2i</span> <span class=n>pm</span><span class=p>(</span><span class=n>Mod</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>MaxHaltonResolution</span><span class=p>),</span> <span class=n>Mod</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>MaxHaltonResolution</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>uint64_t</span> <span class=n>dimOffset</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>InverseRadicalInverse</span><span class=p>(</span><span class=n>pm</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=mi>2</span><span class=p>,</span> <span class=n>baseExponents</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                            <span class=o>:</span> <span class=n>InverseRadicalInverse</span><span class=p>(</span><span class=n>pm</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=mi>3</span><span class=p>,</span> <span class=n>baseExponents</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=n>haltonIndex</span> <span class=o>+=</span>
</span></span><span class=line><span class=cl>                <span class=n>dimOffset</span> <span class=o>*</span> <span class=p>(</span><span class=n>sampleStride</span> <span class=o>/</span> <span class=n>baseScales</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>*</span> <span class=n>multInverse</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>haltonIndex</span> <span class=o>%=</span> <span class=n>sampleStride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>haltonIndex</span> <span class=o>+=</span> <span class=n>sampleIndex</span> <span class=o>*</span> <span class=n>sampleStride</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>dimension</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>dim</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">效果求解<div id=%E6%95%88%E6%9E%9C%E6%B1%82%E8%A7%A3 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%95%88%E6%9E%9C%E6%B1%82%E8%A7%A3 aria-label=锚点>#</a></span></h3><p>Owen扰动后的Halton采样器的PSD与一维抖动采样的PSD类似, 低频接近0, 高频接近1. 未随机化的Halton采样器则在高频上具有较大的方差, 某些高频点的功率较大, 这会造成走样. 随机扰动的PSD则介于二者之间.</p><h2 class="relative group">Sobol&rsquo;采样器<div id=sobol%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#sobol%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h2><p><code>HaltonSampler</code>需要用到除法来生成采样点, 在大部分处理器上这是最慢的操作. Sobol&rsquo;序列完全通过基2反演生成, 在计算机上具有更高的效率. Sobol&rsquo;将基反演的过程矩阵化, 若为单位矩阵则与基反演的结果是相同的.
$$
\begin{equation}
\begin{aligned}
x_a =
\begin{bmatrix}
b^{-1} & b^{-2} & \cdots & b^{-n}
\end{bmatrix}
\begin{bmatrix}
c_{1,1} & c_{1,2} & \cdots & c_{1,n}\\
c_{2,1} & \ddots & & c_{2,n}\\
\vdots & & \ddots & \vdots\\
c_{n,1} & \cdots & \cdots & c_{n,n}
\end{bmatrix}
\begin{bmatrix}
d_1(a)\\
d_2(a)\\
\vdots\\
d_n(a)
\end{bmatrix}
\end{aligned}
\end{equation}
$$</p><p>本节中的Sobol‘序列\(b=2\),\(n=32\), 此时矩阵中每一项都为0或1, 每列可以用<code>uint32_t</code>来表示, 最终转换结果相当于把\(a\)为1的位对应的列相加, 这可以通过异或实现. 由于基反演的特性, 列在存储时会按照逆序存储. pbrt不讨论Sobol‘矩阵的生成.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=kt>uint32_t</span> <span class=nf>MultiplyGenerator</span><span class=p>(</span><span class=n>pstd</span><span class=o>::</span><span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>C</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>a</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>,</span> <span class=n>a</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>v</span> <span class=o>^=</span> <span class=n>C</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">元素区间的分层<div id=%E5%85%83%E7%B4%A0%E5%8C%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B1%82 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%85%83%E7%B4%A0%E5%8C%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B1%82 aria-label=锚点>#</a></span></h3><p>对于pbrt采用的前两个维度的Sobol&rsquo;序列, 任意\(2^{l_1 + l_2}\)个采样点都分层分布在如下的区间中, 其中\(a_i = 0,1,2,3,\dots,2^{l_i - 1}\).</p><p>$$
\begin{equation}
E = \left\lbrace \left[ \frac{a_1}{2^{l_1}}, \frac{a_1 + 1}{2^{l_1}} \right), \left[ \frac{a_2}{2^{l_2}}, \frac{a_2 + 1}{2^{l_2}} \right) \right\rbrace
\end{equation}
$$</p><h3 class="relative group">随机化与扰动<div id=%E9%9A%8F%E6%9C%BA%E5%8C%96%E4%B8%8E%E6%89%B0%E5%8A%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%9A%8F%E6%9C%BA%E5%8C%96%E4%B8%8E%E6%89%B0%E5%8A%A8 aria-label=锚点>#</a></span></h3><p>扰动过程同样可以采用二进制计算来加速, pbrt通过functor使用随机化类的对象.</p><p>最简单的<code>NoRandomizer</code>不做任何扰动.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>NoRandomizer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>uint32_t</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>v</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>BinaryPermuteScrambler</code>通过与某个整数异或实现扰动.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>BinaryPermuteScrambler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BinaryPermuteScrambler</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>perm</span><span class=p>)</span> <span class=o>:</span> <span class=n>permutation</span><span class=p>(</span><span class=n>perm</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>uint32_t</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>permutation</span> <span class=o>^</span> <span class=n>v</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>permutation</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Sobol&rsquo;同样可以采用二进制话的Owen扰动, pbrt中定义在<code>OwenScrambler</code>中, 翻转后的第\(n - i\)位是否反转由高\(i - 1\)位生成的随机数决定. 由于\(n-1\)位之前没有其它高位, pbrt通过种子的第一位来判断是否反转</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>OwenScrambler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>OwenScrambler</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>seed</span><span class=p>)</span> <span class=o>:</span> <span class=n>seed</span><span class=p>(</span><span class=n>seed</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// OwenScrambler Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>uint32_t</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>seed</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>v</span> <span class=o>^=</span> <span class=mi>1u</span> <span class=o>&lt;&lt;</span> <span class=mi>31</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>b</span> <span class=o>&lt;</span> <span class=mi>32</span><span class=p>;</span> <span class=o>++</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Apply Owen scrambling to binary digit _b_ in _v_
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>uint32_t</span> <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=o>~</span><span class=mi>0u</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>32</span> <span class=o>-</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=n>MixBits</span><span class=p>((</span><span class=n>v</span> <span class=o>&amp;</span> <span class=n>mask</span><span class=p>)</span> <span class=o>^</span> <span class=n>seed</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1u</span> <span class=o>&lt;&lt;</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>v</span> <span class=o>^=</span> <span class=mi>1u</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>31</span> <span class=o>-</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>seed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这一过程可以进一步二进制化, pbrt实现在<code>FastOwenSampler</code>中.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FastOwenScrambler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>FastOwenScrambler</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>seed</span><span class=p>)</span> <span class=o>:</span> <span class=n>seed</span><span class=p>(</span><span class=n>seed</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// FastOwenScrambler Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>uint32_t</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>=</span> <span class=n>ReverseBits32</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>^=</span> <span class=n>v</span> <span class=o>*</span> <span class=mh>0x3d20adea</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>+=</span> <span class=n>seed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>*=</span> <span class=p>(</span><span class=n>seed</span> <span class=o>&gt;&gt;</span> <span class=mi>16</span><span class=p>)</span> <span class=o>|</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>^=</span> <span class=n>v</span> <span class=o>*</span> <span class=mh>0x05526c56</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>^=</span> <span class=n>v</span> <span class=o>*</span> <span class=mh>0x53a22864</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ReverseBits32</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>seed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">样本生成<div id=%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%A0%B7%E6%9C%AC%E7%94%9F%E6%88%90 aria-label=锚点>#</a></span></h3><p>由于随机类都实现了functor, 这里采用泛型.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>R</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Float</span> <span class=n>SobolSample</span><span class=p>(</span><span class=kt>int64_t</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dimension</span><span class=p>,</span> <span class=n>R</span> <span class=n>randomizer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DCHECK_LT</span><span class=p>(</span><span class=n>dimension</span><span class=p>,</span> <span class=n>NSobolDimensions</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>DCHECK</span><span class=p>(</span><span class=n>a</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=p>(</span><span class=mi>1ull</span> <span class=o>&lt;&lt;</span> <span class=n>SobolMatrixSize</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute initial Sobol\+$&#39;$ sample _v_ using generator matrices
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>dimension</span> <span class=o>*</span> <span class=n>SobolMatrixSize</span><span class=p>;</span> <span class=n>a</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>a</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>v</span> <span class=o>^=</span> <span class=n>SobolMatrices32</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Randomize Sobol\+$&#39;$ sample and return floating-point value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>v</span> <span class=o>=</span> <span class=n>randomizer</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>v</span> <span class=o>*</span> <span class=mh>0x1</span><span class=n>p</span><span class=o>-</span><span class=mf>32f</span><span class=p>,</span> <span class=n>FloatOneMinusEpsilon</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">全局Sobol&rsquo;采样器<div id=%E5%85%A8%E5%B1%80sobol%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%85%A8%E5%B1%80sobol%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h3><p><code>SobolSampler</code>的缩放通过可以覆盖屏幕的最小的2的幂来确定, 即长边的2底对数. 对高位与像素坐标相同的Sobol&rsquo;变换结果执行逆变换即可得到样本序号, 这可以通过矩阵的逆变换实现, pbrt实现在<code>SobolIntervalToIndex</code>中(这里没有解释代码的原理, 没太看懂).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>uint64_t</span> <span class=nf>SobolIntervalToIndex</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>m</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>frame</span><span class=p>,</span> <span class=n>Point2i</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>m</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>frame</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>m2</span> <span class=o>=</span> <span class=n>m</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>index</span> <span class=o>=</span> <span class=kt>uint64_t</span><span class=p>(</span><span class=n>frame</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>m2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>delta</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>frame</span><span class=p>;</span> <span class=n>frame</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>,</span> <span class=o>++</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>frame</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1>// Add flipped column m + c + 1.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>delta</span> <span class=o>^=</span> <span class=n>VdCSobolMatrices</span><span class=p>[</span><span class=n>m</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// flipped b
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>b</span> <span class=o>=</span> <span class=p>(((</span><span class=kt>uint64_t</span><span class=p>)((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>m</span><span class=p>)</span> <span class=o>|</span> <span class=p>((</span><span class=kt>uint32_t</span><span class=p>)</span><span class=n>p</span><span class=p>.</span><span class=n>y</span><span class=p>))</span> <span class=o>^</span> <span class=n>delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>b</span><span class=p>;</span> <span class=n>b</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>,</span> <span class=o>++</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1>// Add column 2 * m - c.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>index</span> <span class=o>^=</span> <span class=n>VdCSobolMatricesInv</span><span class=p>[</span><span class=n>m</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">填充Sobol&rsquo;采样器<div id=%E5%A1%AB%E5%85%85sobol%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%A1%AB%E5%85%85sobol%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h3><p><code>SobolSampler</code>生成的多维样本在二维上的投影可能不具有良好的分布, <code>PaddedSobolSampler</code>通过混排Sobol&rsquo;序列实现, 不会进行缩放等操作.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>Get1D</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get permuted index for current pixel sample
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>hash</span> <span class=o>=</span> <span class=n>Hash</span><span class=p>(</span><span class=n>pixel</span><span class=p>,</span> <span class=n>dimension</span><span class=p>,</span> <span class=n>seed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>PermutationElement</span><span class=p>(</span><span class=n>sampleIndex</span><span class=p>,</span> <span class=n>samplesPerPixel</span><span class=p>,</span> <span class=n>hash</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>dim</span> <span class=o>=</span> <span class=n>dimension</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Return randomized 1D van der Corput sample for dimension _dim_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>SampleDimension</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=n>hash</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">蓝噪声Sobol&rsquo;采样器<div id=%E8%93%9D%E5%99%AA%E5%A3%B0sobol%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E8%93%9D%E5%99%AA%E5%A3%B0sobol%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h3><p><code>ZSobolSampler</code>是pbrt的默认采样器, 它会在<code>PaddedSobolSampler</code>的混排过程中遵循蓝噪声分布, 使得更多的误差分布在高频中. 这不会改变MSE, 但是对于人类视觉可以取得更优的效果.</p><p>相邻的二次幂个Sobol采样点具有良好的分层, 如果通过当前像素的Morton码决定使用的采样点序号, 那么在相邻像素上可以取得较优的分布. 直接采用Morton码会导致渲染误差呈现结构化特征, 可以通过对每4个相邻的Morton码进行混排来实现扰动. 对于像素内部的采样点, pbrt会左移像素对应的Morton码, 然后将低位设置为像素内部采样点的序号, 这使得内部序号也参与随机扰动的过程.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>StartPixelSample</span><span class=p>(</span><span class=n>Point2i</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>index</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dim</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dimension</span> <span class=o>=</span> <span class=n>dim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mortonIndex</span> <span class=o>=</span> <span class=p>(</span><span class=n>EncodeMorton2</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>log2SamplesPerPixel</span><span class=p>)</span> <span class=o>|</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>pbrt对样本序号的扰动是每4个为一组的, 类似于Owen扰动这里会将已经生成的高位扰动结果添加到扰动过程中. 对于像素内部样本数量为2的幂而非4的幂的情况, 最后一位会单组作为一组来执行扰动, 此时只需要执行异或.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>GetSampleIndex</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Define the full set of 4-way permutations in _permutations_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=k>const</span> <span class=kt>uint8_t</span> <span class=n>permutations</span><span class=p>[</span><span class=mi>24</span><span class=p>][</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Define remaining 20 4-way permutations
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>sampleIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Apply random permutations to full base-4 digits
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>pow2Samples</span> <span class=o>=</span> <span class=n>log2SamplesPerPixel</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>lastDigit</span> <span class=o>=</span> <span class=n>pow2Samples</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>nBase4Digits</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>lastDigit</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Randomly permute $i$th base-4 digit in _mortonIndex_
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>digitShift</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>-</span> <span class=p>(</span><span class=n>pow2Samples</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>digit</span> <span class=o>=</span> <span class=p>(</span><span class=n>mortonIndex</span> <span class=o>&gt;&gt;</span> <span class=n>digitShift</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Choose permutation _p_ to use for _digit_
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint64_t</span> <span class=n>higherDigits</span> <span class=o>=</span> <span class=n>mortonIndex</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>digitShift</span> <span class=o>+</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=n>MixBits</span><span class=p>(</span><span class=n>higherDigits</span> <span class=o>^</span> <span class=p>(</span><span class=mh>0x55555555u</span> <span class=o>*</span> <span class=n>dimension</span><span class=p>))</span> <span class=o>&gt;&gt;</span> <span class=mi>24</span><span class=p>)</span> <span class=o>%</span> <span class=mi>24</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>digit</span> <span class=o>=</span> <span class=n>permutations</span><span class=p>[</span><span class=n>p</span><span class=p>][</span><span class=n>digit</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>sampleIndex</span> <span class=o>|=</span> <span class=kt>uint64_t</span><span class=p>(</span><span class=n>digit</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>digitShift</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle power-of-2 (but not 4) sample count
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>pow2Samples</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>digit</span> <span class=o>=</span> <span class=n>mortonIndex</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sampleIndex</span> <span class=o>|=</span>
</span></span><span class=line><span class=cl>            <span class=n>digit</span> <span class=o>^</span> <span class=p>(</span><span class=n>MixBits</span><span class=p>((</span><span class=n>mortonIndex</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>^</span> <span class=p>(</span><span class=mh>0x55555555u</span> <span class=o>*</span> <span class=n>dimension</span><span class=p>))</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sampleIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">效果求解<div id=%E6%95%88%E6%9E%9C%E6%B1%82%E8%A7%A3-1 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%95%88%E6%9E%9C%E6%B1%82%E8%A7%A3-1 aria-label=锚点>#</a></span></h3><p>Owen采样后的Sobol&rsquo;采样器可以取得较好的PSD, 同时适合计算机执行的二进制操作也大大提高了采样效率.</p><h2 class="relative group">图像重建<div id=%E5%9B%BE%E5%83%8F%E9%87%8D%E5%BB%BA class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%9B%BE%E5%83%8F%E9%87%8D%E5%BB%BA aria-label=锚点>#</a></span></h2><p>理想采样在实践中几乎是不可能的, 而在渲染任务中理想的\(\text{sinc}\)滤波器也会导致滤波结果的震荡, pbrt所实现的滤波器都致力于尽量减小误差.</p><h3 class="relative group">滤波器接口<div id=%E6%BB%A4%E6%B3%A2%E5%99%A8%E6%8E%A5%E5%8F%A3 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%BB%A4%E6%B3%A2%E5%99%A8%E6%8E%A5%E5%8F%A3 aria-label=锚点>#</a></span></h3><p>滤波器需要实现<code>Filter</code>接口. <code>Radius</code>返回滤波器的半径, 超过半径时权重为0, 滤波器在\(x\), \(y\)轴上的半径可能是不同的, 但都是关于原点对称的. <code>Evaluate</code>返回坐标点对应的权重. <code>Integral</code>返回当前半径下的积分值, 由于渲染具有归一化的过程, 这里不保证积分值为1. <code>Sample</code>用于实现重要性抽样, 返回均匀分布值对应的坐标以及权重与pdf的比值, 由于部分滤波器是可以作为概率分布直接采样的, 此时返回的比值为1.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Filter</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TaggedPointer</span><span class=o>&lt;</span><span class=n>BoxFilter</span><span class=p>,</span> <span class=n>GaussianFilter</span><span class=p>,</span> <span class=n>MitchellFilter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                    <span class=n>LanczosSincFilter</span><span class=p>,</span> <span class=n>TriangleFilter</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Filter Interface
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>TaggedPointer</span><span class=o>::</span><span class=n>TaggedPointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Filter</span> <span class=nf>Create</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=n>ParameterDictionary</span> <span class=o>&amp;</span><span class=n>parameters</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=k>const</span> <span class=n>FileLoc</span> <span class=o>*</span><span class=n>loc</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Vector2f</span> <span class=nf>Radius</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Float</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>p</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Float</span> <span class=nf>Integral</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>FilterSample</span> <span class=nf>Sample</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>u</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">滤波器采样器<div id=%E6%BB%A4%E6%B3%A2%E5%99%A8%E9%87%87%E6%A0%B7%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%BB%A4%E6%B3%A2%E5%99%A8%E9%87%87%E6%A0%B7%E5%99%A8 aria-label=锚点>#</a></span></h3><p><code>FilterSampler</code>主要负责重要性抽样的细节, 不具有解析形式逆变换的滤波器会通过分段函数查表的形式采样, pbrt使用的采样率为每单位长度32个样本. 由于对称的特性, 只需要对第一象限进行采样即可.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>FilterSampler</span><span class=o>::</span><span class=n>FilterSampler</span><span class=p>(</span><span class=n>Filter</span> <span class=n>filter</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>domain</span><span class=p>(</span><span class=n>Point2f</span><span class=p>(</span><span class=o>-</span><span class=n>filter</span><span class=p>.</span><span class=n>Radius</span><span class=p>()),</span> <span class=n>Point2f</span><span class=p>(</span><span class=n>filter</span><span class=p>.</span><span class=n>Radius</span><span class=p>())),</span>
</span></span><span class=line><span class=cl>      <span class=n>f</span><span class=p>(</span><span class=kt>int</span><span class=p>(</span><span class=mi>32</span> <span class=o>*</span> <span class=n>filter</span><span class=p>.</span><span class=n>Radius</span><span class=p>().</span><span class=n>x</span><span class=p>),</span> <span class=kt>int</span><span class=p>(</span><span class=mi>32</span> <span class=o>*</span> <span class=n>filter</span><span class=p>.</span><span class=n>Radius</span><span class=p>().</span><span class=n>y</span><span class=p>),</span> <span class=n>alloc</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=n>distrib</span><span class=p>(</span><span class=n>alloc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Tabularize unnormalized filter function in _f_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=n>f</span><span class=p>.</span><span class=n>YSize</span><span class=p>();</span> <span class=o>++</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>f</span><span class=p>.</span><span class=n>XSize</span><span class=p>();</span> <span class=o>++</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Point2f</span> <span class=n>p</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=n>domain</span><span class=p>.</span><span class=n>Lerp</span><span class=p>(</span><span class=n>Point2f</span><span class=p>((</span><span class=n>x</span> <span class=o>+</span> <span class=mf>0.5f</span><span class=p>)</span> <span class=o>/</span> <span class=n>f</span><span class=p>.</span><span class=n>XSize</span><span class=p>(),</span> <span class=p>(</span><span class=n>y</span> <span class=o>+</span> <span class=mf>0.5f</span><span class=p>)</span> <span class=o>/</span> <span class=n>f</span><span class=p>.</span><span class=n>YSize</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=o>=</span> <span class=n>filter</span><span class=p>.</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute sampling distribution for filter
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>distrib</span> <span class=o>=</span> <span class=n>PiecewiseConstant2D</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>domain</span><span class=p>,</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为了避免权重产生过大的方差, <code>FilterSampler</code>返回的权重是分段函数而非滤波函数本身的值与pdf的比值, 这使得比值为常数.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>FilterSample</span> <span class=nf>Sample</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>u</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>pdf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2i</span> <span class=n>pi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2f</span> <span class=n>p</span> <span class=o>=</span> <span class=n>distrib</span><span class=p>.</span><span class=n>Sample</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pdf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>FilterSample</span><span class=p>{</span><span class=n>p</span><span class=p>,</span> <span class=n>f</span><span class=p>[</span><span class=n>pi</span><span class=p>]</span> <span class=o>/</span> <span class=n>pdf</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 class="relative group">一维分段函数<div id=%E4%B8%80%E7%BB%B4%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%B8%80%E7%BB%B4%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0 aria-label=锚点>#</a></span></h4><p>pbrt支持在\((0-1)\)上均匀划分区间的分段函数重要性抽样, 可以通过自定义参数缩放采样结果, 其归一化因子, PDF以及CDF如下, PDF需要保证为正, 因此使用绝对值. 对于重要性抽样, 只需要找到\(P(x_i) \le U \le P(x_{i+1})\)并线性插值即可.</p><p>$$
\begin{equation}
\begin{aligned}
c&=\sum_{i=0}^{n-1}\frac{|v_i|}{n}\\
p(x_i)&=\frac{|v_i|}{c}\\
P(x_i)&=
\begin{cases}
0 & i=0\\
P(x_{i-1})+\frac{|v_i|}{nc} & \text{otherwise}
\end{cases}
\end{aligned}
\end{equation}
$$</p><p><code>PiecewiseConstant1D</code>的构造函数如下. 对于积分和为\(0\)的情况, pbrt将其转为均匀分布, 在二维采样中这种情况很常见, 由于最终获取的权重为\(0\)转为均匀分布在统计上正确.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PiecewiseConstant1D</span><span class=p>(</span><span class=n>pstd</span><span class=o>::</span><span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Float</span><span class=o>&gt;</span> <span class=n>f</span><span class=p>,</span> <span class=n>Float</span> <span class=n>min</span><span class=p>,</span> <span class=n>Float</span> <span class=n>max</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>Allocator</span> <span class=n>alloc</span> <span class=o>=</span> <span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>func</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>f</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>alloc</span><span class=p>),</span> <span class=n>cdf</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>alloc</span><span class=p>),</span> <span class=n>min</span><span class=p>(</span><span class=n>min</span><span class=p>),</span> <span class=n>max</span><span class=p>(</span><span class=n>max</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CHECK_GT</span><span class=p>(</span><span class=n>max</span><span class=p>,</span> <span class=n>min</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Take absolute value of _func_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>Float</span> <span class=o>&amp;</span><span class=nl>f</span> <span class=p>:</span> <span class=n>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>abs</span><span class=p>(</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute integral of step function at $x_i$
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cdf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=n>f</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>CHECK_GE</span><span class=p>(</span><span class=n>func</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cdf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>cdf</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>func</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>max</span> <span class=o>-</span> <span class=n>min</span><span class=p>)</span> <span class=o>/</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Transform step function integral into CDF
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>funcInt</span> <span class=o>=</span> <span class=n>cdf</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>funcInt</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cdf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Float</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=n>Float</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cdf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>/=</span> <span class=n>funcInt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>PiecewiseConstant1D</code>的采样实现如下, <code>FindInterval</code>实现二分搜索, <code>min</code>和<code>max</code>是用户设置的缩放系数.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>Sample</span><span class=p>(</span><span class=n>Float</span> <span class=n>u</span><span class=p>,</span> <span class=n>Float</span> <span class=o>*</span><span class=n>pdf</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>offset</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Find surrounding CDF segments and _offset_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>o</span> <span class=o>=</span> <span class=n>FindInterval</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span><span class=n>cdf</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>cdf</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>u</span><span class=p>;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>offset</span> <span class=o>=</span> <span class=n>o</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute offset along CDF segment
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>du</span> <span class=o>=</span> <span class=n>u</span> <span class=o>-</span> <span class=n>cdf</span><span class=p>[</span><span class=n>o</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cdf</span><span class=p>[</span><span class=n>o</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>cdf</span><span class=p>[</span><span class=n>o</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>du</span> <span class=o>/=</span> <span class=n>cdf</span><span class=p>[</span><span class=n>o</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>cdf</span><span class=p>[</span><span class=n>o</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>DCHECK</span><span class=p>(</span><span class=o>!</span><span class=n>IsNaN</span><span class=p>(</span><span class=n>du</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute PDF for sampled offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>pdf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pdf</span> <span class=o>=</span> <span class=p>(</span><span class=n>funcInt</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>func</span><span class=p>[</span><span class=n>o</span><span class=p>]</span> <span class=o>/</span> <span class=nl>funcInt</span> <span class=p>:</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Return $x$ corresponding to sample
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>Lerp</span><span class=p>((</span><span class=n>o</span> <span class=o>+</span> <span class=n>du</span><span class=p>)</span> <span class=o>/</span> <span class=n>size</span><span class=p>(),</span> <span class=n>min</span><span class=p>,</span> <span class=n>max</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 class="relative group">二维分段函数<div id=%E4%BA%8C%E7%BB%B4%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%BA%8C%E7%BB%B4%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0 aria-label=锚点>#</a></span></h4><p>基于一维分段函数, pbrt支持\(n_u \times n_v\)上的二维分段函数重要性抽样.</p><p><code>PiecewiseConstant2D</code>的构造函数如下, 计算并存储每行的积分和.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PiecewiseConstant2D</span><span class=p>(</span><span class=n>pstd</span><span class=o>::</span><span class=n>span</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Float</span><span class=o>&gt;</span> <span class=n>func</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nu</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nv</span><span class=p>,</span> <span class=n>Bounds2f</span> <span class=n>domain</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>Allocator</span> <span class=n>alloc</span> <span class=o>=</span> <span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>domain</span><span class=p>(</span><span class=n>domain</span><span class=p>),</span> <span class=n>pConditionalV</span><span class=p>(</span><span class=n>alloc</span><span class=p>),</span> <span class=n>pMarginal</span><span class=p>(</span><span class=n>alloc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CHECK_EQ</span><span class=p>(</span><span class=n>func</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span><span class=n>nu</span> <span class=o>*</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span><span class=n>nv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pConditionalV</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>nv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>nv</span><span class=p>;</span> <span class=o>++</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Compute conditional sampling distribution for $\tilde{v}$
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pConditionalV</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>func</span><span class=p>.</span><span class=n>subspan</span><span class=p>(</span><span class=n>v</span> <span class=o>*</span> <span class=n>nu</span><span class=p>,</span> <span class=n>nu</span><span class=p>),</span> <span class=n>domain</span><span class=p>.</span><span class=n>pMin</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                                    <span class=n>domain</span><span class=p>.</span><span class=n>pMax</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute marginal sampling distribution $p[\tilde{v}]$
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pstd</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Float</span><span class=o>&gt;</span> <span class=n>marginalFunc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>marginalFunc</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>nv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>nv</span><span class=p>;</span> <span class=o>++</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>marginalFunc</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>pConditionalV</span><span class=p>[</span><span class=n>v</span><span class=p>].</span><span class=n>Integral</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>pMarginal</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>PiecewiseConstant1D</span><span class=p>(</span><span class=n>marginalFunc</span><span class=p>,</span> <span class=n>domain</span><span class=p>.</span><span class=n>pMin</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>domain</span><span class=p>.</span><span class=n>pMax</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>PiecewiseConstant2D</code>的采样函数如下, 现在列上做一维重要性抽样, 然后再采样对应行.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Point2f</span> <span class=nf>Sample</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>u</span><span class=p>,</span> <span class=n>Float</span> <span class=o>*</span><span class=n>pdf</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=n>Point2i</span> <span class=o>*</span><span class=n>offset</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>pdfs</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2i</span> <span class=n>uv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>d1</span> <span class=o>=</span> <span class=n>pMarginal</span><span class=p>.</span><span class=n>Sample</span><span class=p>(</span><span class=n>u</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>pdfs</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>uv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>d0</span> <span class=o>=</span> <span class=n>pConditionalV</span><span class=p>[</span><span class=n>uv</span><span class=p>[</span><span class=mi>1</span><span class=p>]].</span><span class=n>Sample</span><span class=p>(</span><span class=n>u</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>pdfs</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>uv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pdf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pdf</span> <span class=o>=</span> <span class=n>pdfs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>pdfs</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>offset</span> <span class=o>=</span> <span class=n>uv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Point2f</span><span class=p>(</span><span class=n>d0</span><span class=p>,</span> <span class=n>d1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 class="relative group">窗口二维分段函数<div id=%E7%AA%97%E5%8F%A3%E4%BA%8C%E7%BB%B4%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%AA%97%E5%8F%A3%E4%BA%8C%E7%BB%B4%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0 aria-label=锚点>#</a></span></h4><p><code>WindowedPiecewiseConstant2D</code>支持采样二维函数的部分矩形区域, 主要用于实现门户光源. pbrt实现了<code>SummedAreaTable</code>来存储二维分段函数某个位置到左下角的积分和, 这加速来计算任意矩形区域的积分和.</p><p>对于浮点数的<code>SummedAreaTable</code>, pbrt通过对相邻整数对应的积分和做双线性插值实现.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>Lookup</span><span class=p>(</span><span class=n>Float</span> <span class=n>x</span><span class=p>,</span> <span class=n>Float</span> <span class=n>y</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Rescale $(x,y)$ to table resolution and compute integer coordinates
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span> <span class=o>*=</span> <span class=n>sum</span><span class=p>.</span><span class=n>XSize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>*=</span> <span class=n>sum</span><span class=p>.</span><span class=n>YSize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x0</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>x</span><span class=p>,</span> <span class=n>y0</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Bilinearly interpolate between surrounding table values
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>v00</span> <span class=o>=</span> <span class=n>LookupInt</span><span class=p>(</span><span class=n>x0</span><span class=p>,</span> <span class=n>y0</span><span class=p>),</span> <span class=n>v10</span> <span class=o>=</span> <span class=n>LookupInt</span><span class=p>(</span><span class=n>x0</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>y0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>v01</span> <span class=o>=</span> <span class=n>LookupInt</span><span class=p>(</span><span class=n>x0</span><span class=p>,</span> <span class=n>y0</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>v11</span> <span class=o>=</span> <span class=n>LookupInt</span><span class=p>(</span><span class=n>x0</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>y0</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>dx</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-</span> <span class=kt>int</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>dy</span> <span class=o>=</span> <span class=n>y</span> <span class=o>-</span> <span class=kt>int</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>dx</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>dy</span><span class=p>)</span> <span class=o>*</span> <span class=n>v00</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>dx</span><span class=p>)</span> <span class=o>*</span> <span class=n>dy</span> <span class=o>*</span> <span class=n>v01</span> <span class=o>+</span> <span class=n>dx</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>dy</span><span class=p>)</span> <span class=o>*</span> <span class=n>v10</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>            <span class=n>dx</span> <span class=o>*</span> <span class=n>dy</span> <span class=o>*</span> <span class=n>v11</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>WindowedPiecewiseConstant2D</code>的采样函数如下, <code>Px</code>用于返回窗口区域归一化后到某行的CDF. <code>SampleBisection</code>实现二分查找, 最后一个参数为底层<code>PiecewiseConstant2D</code>的行数量, 当搜索区间小于一行时进行插值并返回结果. 由于矩形长或宽为\(0\)时无法采样, pbrt将窗口宽度缩小到当前行, 在列上再次二分查找, 实际上缩小后的行可能略微超出原本的矩形区域了.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>pstd</span><span class=o>::</span><span class=n>optional</span><span class=o>&lt;</span><span class=n>Point2f</span><span class=o>&gt;</span> <span class=n>Sample</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>u</span><span class=p>,</span> <span class=n>Bounds2f</span> <span class=n>b</span><span class=p>,</span> <span class=n>Float</span> <span class=o>*</span><span class=n>pdf</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle zero-valued function for windowed sampling
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sat</span><span class=p>.</span><span class=n>Integral</span><span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Define lambda function _Px_ for marginal cumulative distribution
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>bInt</span> <span class=o>=</span> <span class=n>sat</span><span class=p>.</span><span class=n>Integral</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>Px</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>this</span><span class=p>](</span><span class=n>Float</span> <span class=n>x</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Float</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Bounds2f</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>bx</span><span class=p>.</span><span class=n>pMax</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>sat</span><span class=p>.</span><span class=n>Integral</span><span class=p>(</span><span class=n>bx</span><span class=p>)</span> <span class=o>/</span> <span class=n>bInt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Sample marginal windowed function in $x$
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Point2f</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>SampleBisection</span><span class=p>(</span><span class=n>Px</span><span class=p>,</span> <span class=n>u</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>b</span><span class=p>.</span><span class=n>pMin</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>pMax</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>func</span><span class=p>.</span><span class=n>XSize</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Sample conditional windowed function in $y$
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Compute 2D bounds _bCond_ for conditional sampling
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>nx</span> <span class=o>=</span> <span class=n>func</span><span class=p>.</span><span class=n>XSize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Bounds2f</span> <span class=nf>bCond</span><span class=p>(</span><span class=n>Point2f</span><span class=p>(</span><span class=n>pstd</span><span class=o>::</span><span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>nx</span><span class=p>)</span> <span class=o>/</span> <span class=n>nx</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>pMin</span><span class=p>.</span><span class=n>y</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                    <span class=n>Point2f</span><span class=p>(</span><span class=n>pstd</span><span class=o>::</span><span class=n>ceil</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>nx</span><span class=p>)</span> <span class=o>/</span> <span class=n>nx</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>pMax</span><span class=p>.</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bCond</span><span class=p>.</span><span class=n>pMin</span><span class=p>.</span><span class=n>x</span> <span class=o>==</span> <span class=n>bCond</span><span class=p>.</span><span class=n>pMax</span><span class=p>.</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>bCond</span><span class=p>.</span><span class=n>pMax</span><span class=p>.</span><span class=n>x</span> <span class=o>+=</span> <span class=mf>1.f</span> <span class=o>/</span> <span class=n>nx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sat</span><span class=p>.</span><span class=n>Integral</span><span class=p>(</span><span class=n>bCond</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Define lambda function for conditional distribution and sample $y$
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>condIntegral</span> <span class=o>=</span> <span class=n>sat</span><span class=p>.</span><span class=n>Integral</span><span class=p>(</span><span class=n>bCond</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>Py</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>this</span><span class=p>](</span><span class=n>Float</span> <span class=n>y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Float</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Bounds2f</span> <span class=n>by</span> <span class=o>=</span> <span class=n>bCond</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>by</span><span class=p>.</span><span class=n>pMax</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>sat</span><span class=p>.</span><span class=n>Integral</span><span class=p>(</span><span class=n>by</span><span class=p>)</span> <span class=o>/</span> <span class=n>condIntegral</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>SampleBisection</span><span class=p>(</span><span class=n>Py</span><span class=p>,</span> <span class=n>u</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>b</span><span class=p>.</span><span class=n>pMin</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>pMax</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>func</span><span class=p>.</span><span class=n>YSize</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute PDF and return point sampled from windowed function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>pdf</span> <span class=o>=</span> <span class=n>Eval</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>/</span> <span class=n>bInt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">盒形滤波器<div id=%E7%9B%92%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%9B%92%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8 aria-label=锚点>#</a></span></h3><p>盒形滤波器对半径内的采样点都具有相同的权重, 在频域下会导致高频信息泄漏至低频, 导致走样. 盒形滤波器本身就是均匀分布, 因此<code>Sample</code>方法只需要对传入的均匀分布样本进行缩放.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>FilterSample</span> <span class=nf>Sample</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>u</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2f</span> <span class=n>p</span><span class=p>(</span><span class=n>Lerp</span><span class=p>(</span><span class=n>u</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>-</span><span class=n>radius</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>radius</span><span class=p>.</span><span class=n>x</span><span class=p>),</span> <span class=n>Lerp</span><span class=p>(</span><span class=n>u</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>-</span><span class=n>radius</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>radius</span><span class=p>.</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=n>p</span><span class=p>,</span> <span class=n>Float</span><span class=p>(</span><span class=mi>1</span><span class=p>)};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">三角形滤波器<div id=%E4%B8%89%E8%A7%92%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8 aria-label=锚点>#</a></span></h3><p>三角形滤波器的权重在坐标轴上是线性减小的, pbrt中将滤波器的斜率设置为1, 半径为r时归一化形式如下.</p><p>$$
\begin{equation}
\begin{aligned}
f(x) &= \max(0, \frac{1}{r} - \frac{|x|}{r^2})
\end{aligned}
\end{equation}
$$</p><p>二维上三角形滤波器是可分离的, 投影到\(x=c\)或\(y=c\)后仍为三角形.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=o>&lt;</span><span class=n>Float</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>radius</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=n>std</span><span class=o>::</span><span class=n>abs</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=p>))</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>           <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=o>&lt;</span><span class=n>Float</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>radius</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>std</span><span class=o>::</span><span class=n>abs</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>三角形函数在正负两侧分别为线性函数, 且已知采样到两侧概率相同, 因此分别执行之前章节介绍的线性函数重要性抽样即可. 由于三角形滤波器本身即为三角形分布, 返回权重为1.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>Float</span> <span class=nf>SampleTent</span><span class=p>(</span><span class=n>Float</span> <span class=n>u</span><span class=p>,</span> <span class=n>Float</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>SampleDiscrete</span><span class=p>({</span><span class=mf>0.5f</span><span class=p>,</span> <span class=mf>0.5f</span><span class=p>},</span> <span class=n>u</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>u</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>r</span> <span class=o>+</span> <span class=n>r</span> <span class=o>*</span> <span class=n>SampleLinear</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>r</span> <span class=o>*</span> <span class=n>SampleLinear</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于可分离的特性在重要性抽样时可以在不同的轴上分别采样.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>FilterSample</span> <span class=nf>Sample</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>u</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=n>Point2f</span><span class=p>(</span><span class=n>SampleTent</span><span class=p>(</span><span class=n>u</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>radius</span><span class=p>.</span><span class=n>x</span><span class=p>),</span> <span class=n>SampleTent</span><span class=p>(</span><span class=n>u</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>radius</span><span class=p>.</span><span class=n>y</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>            <span class=n>Float</span><span class=p>(</span><span class=mi>1</span><span class=p>)};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">Gaussian滤波器<div id=gaussian%E6%BB%A4%E6%B3%A2%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#gaussian%E6%BB%A4%E6%B3%A2%E5%99%A8 aria-label=锚点>#</a></span></h3><p>由于滤波器只在半径内不为0, pbrt会减去半径处对应的Gaussian函数的值, 这也使得一般的Gaussian分布重要性抽样无法被采样, 需要使用<code>FilterSampler</code>. Gaussian滤波器通常会导致边缘的模糊.</p><p>$$
\begin{equation}
\begin{aligned}
g(x,\mu,\sigma) &= \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\\
f(x) &=
\begin{cases}
g(x,0,\sigma)-g(r,0,\sigma) &|x|&lt;r\\
0 &\text{otherwise}
\end{cases}
\end{aligned}
\end{equation}
$$</p><p>Gaussian函数的CDF如下, 可以看出它不是可逆的.</p><p>$$
\begin{equation}
\begin{aligned}
P(x,\mu,\sigma)
&=\int_{-\infty}^x \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}} dx\\
&=\int_{-\infty}^z \frac{1}{\sqrt{2\pi}}e^{-\frac{z^2}{2}} dz\\
&=\int_{-\infty}^0 \frac{1}{\sqrt{2\pi}}e^{-\frac{z^2}{2}} dz + \int_0^z \frac{1}{\sqrt{2\pi}}e^{-\frac{z^2}{2}} dz\\
&=\frac{1}{2} + \int_0^z \frac{1}{\sqrt{\pi}}e^{-\frac{z^2}{2}} d\frac{z}{\sqrt{2}}\\
&=\frac{1}{2}(1+\text{erf}(\frac{z}{\sqrt{2}}))
\end{aligned}
\end{equation}
$$</p><p>pbrt通过某种多项式来你和误差函数的逆函数, 以实现重要性抽样.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>SampleNormal</span><span class=p>(</span><span class=n>Float</span> <span class=n>u</span><span class=p>,</span> <span class=n>Float</span> <span class=n>mu</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>Float</span> <span class=n>sigma</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mu</span> <span class=o>+</span> <span class=n>Sqrt2</span> <span class=o>*</span> <span class=n>sigma</span> <span class=o>*</span> <span class=n>ErfInv</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>u</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">Mitchell滤波器<div id=mitchell%E6%BB%A4%E6%B3%A2%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#mitchell%E6%BB%A4%E6%B3%A2%E5%99%A8 aria-label=锚点>#</a></span></h3><p>Mitchell滤波器致力于在振荡与模糊之间达成平衡, 这通过在滤波器中引入负值来实现, 负值部分较少会偏向模糊, 反之偏向振荡以及不合法的图像值. Mitchell滤波器的定义如下, 其中的参数\(b\)和\(c\)在原文中推荐保持\(b+2c=1\)的关系.</p><p>$$
\begin{equation}
\begin{aligned}
f(x) = \frac{1}{6}
\begin{cases}
(12-9b-6c)|x|^3\\
+(-18+12b+6c)|x|^2+(6-2b) &|x|&lt;1\\
(-b-6c)|x|^3+(6b+30c)|x|^2\\
+(-12b-48c)|x|+(8b+24c) &amp;1\le|x|&lt;2\\
0 &\text{otherwise}
\end{cases}
\end{aligned}
\end{equation}
$$</p><p>pbrt中会依据设定的半径来缩放坐标值, 通过半径缩放后的Mitchell滤波器的积分具有良好的解析形式.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>Point2f</span> <span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Mitchell1D</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=n>radius</span><span class=p>.</span><span class=n>x</span><span class=p>)</span> <span class=o>*</span> <span class=n>Mitchell1D</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>/</span> <span class=n>radius</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>Float</span> <span class=nf>Integral</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>radius</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>radius</span><span class=p>.</span><span class=n>y</span> <span class=o>/</span> <span class=mi>4</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">Lanczos滤波器<div id=lanczos%E6%BB%A4%E6%B3%A2%E5%99%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#lanczos%E6%BB%A4%E6%B3%A2%E5%99%A8 aria-label=锚点>#</a></span></h3><p>Lanczos滤波器基于\(\text{sinc}\)函数, 通过将\(\text{sinc}\)函数与一个周期缩放后的\(\text{sinc}\)函数相乘并截断实现. 缩放后的\(\text{sinc}\)函数被称为窗口函数, 因此该滤波也叫窗口化\(\text{sinc}\)滤波器. 与直接使用\(\text{sinc}\)相比Lanczos滤波器具有更少的振荡. Lanczos滤波器的积分较难求解, pbrt通过Riemann和来估计.</p><p>$$
\begin{equation}
\begin{aligned}
\text{sinc}(x) &= \frac{\sin(\pi x)}{\pi x}\\
w(x) &= \text{sinc}(\frac{x}{\tau})\\
f(x) &=
\begin{cases}
\text{sinc}(x)w(x) &|x|\le \tau\\
0 &\text{otherwise}
\end{cases}
\end{aligned}
\end{equation}
$$</p></div></div><script>var oid="views_render/1732940841429-pbrt-v4-episode-8/index.md",oid_likes="likes_render/1732940841429-pbrt-v4-episode-8/index.md"</script><script type=text/javascript src=/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q+oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/render/1731999189039-pbrt-v4-episode-7/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">pbrt-v4 Ep. VII: 图元与加速结构</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2024-11-19T00:00:00+00:00>2024 November 19</time>
</span></span></a></span><span><a class="flex text-right group ml-3" href=/render/1733816209202-pbrt-v4-episode-9/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">pbrt-v4 Ep. IX: 反射模型</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2024-12-10T00:00:00+00:00>2024 December 10</time>
</span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div><div class=pt-3><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class=pt-3><script src=https://giscus.app/client.js data-repo=tsssni/tsssni.github.io data-repo-id=R_kgDOMEzJ_g data-category=Announcements data-category-id=DIC_kwDOMEzJ_s4CgBEJ data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=返回顶部 title=返回顶部>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href title></a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2025</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://tsssni.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>