<!doctype html><html lang=zh-cn dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><title>pbrt-v4 Ep. X: 材质纹理 &#183; tsssni's blowfish blog</title>
<meta name=title content="pbrt-v4 Ep. X: 材质纹理 &#183; tsssni's blowfish blog"><meta name=description content="pbrt-v4 episode 10"><meta name=keywords content="graphics,rendering,pbrt,"><link rel=canonical href=https://tsssni.github.io/render/pbrt-v4-episode-10/><link type=text/css rel=stylesheet href=/css/main.bundle.min.3c451cff13adc9f03ed84ad472bed71f3ce32af0a5a02c86a92488a46f39d2132c8b77415cba5d090209aa152c39f494955da5508be718dd24dee647d4a5eb5f.css integrity="sha512-PEUc/xOtyfA+2ErUcr7XHzzjKvCloCyGqSSIpG850hMsi3dBXLpdCQIJqhUsOfSUlV2lUIvnGN0k3uZH1KXrXw=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.b6411b5d4cd56c0068d34c4acbce043846adad56b824e3d486a06d3459aed2eb7f7413874b7871cc2c822c8c8834cbed944022918bcc8cca710a962167c36d32.js integrity="sha512-tkEbXUzVbABo00xKy84EOEatrVa4JOPUhqBtNFmu0ut/dBOHS3hxzCyCLIyINMvtlEAikYvMjMpxCpYhZ8NtMg==" data-copy data-copied></script><script src=/lib/zoom/zoom.min.f592a181a15d2a5b042daa7f746c3721acf9063f8b6acd175d989129865a37d400ae0e85b640f9ad42cd98d1f8ad30931718cf8811abdcc5fcb264400d1a2b0c.js integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj+Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://tsssni.github.io/render/pbrt-v4-episode-10/"><meta property="og:site_name" content="tsssni's blowfish blog"><meta property="og:title" content="pbrt-v4 Ep. X: 材质纹理"><meta property="og:description" content="pbrt-v4 episode 10"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="render"><meta property="article:published_time" content="2024-12-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-24T00:00:00+00:00"><meta property="article:tag" content="Graphics"><meta property="article:tag" content="Rendering"><meta property="article:tag" content="Pbrt"><meta property="og:image" content="https://tsssni.github.io/render/pbrt-v4-episode-10/featured.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tsssni.github.io/render/pbrt-v4-episode-10/featured.jpg"><meta name=twitter:title content="pbrt-v4 Ep. X: 材质纹理"><meta name=twitter:description content="pbrt-v4 episode 10"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Rendering","name":"pbrt-v4 Ep. X: 材质纹理","headline":"pbrt-v4 Ep. X: 材质纹理","description":"pbrt-v4 episode 10","inLanguage":"zh-cn","url":"https:\/\/tsssni.github.io\/render\/pbrt-v4-episode-10\/","author":{"@type":"Person","name":""},"copyrightYear":"2024","dateCreated":"2024-12-24T00:00:00\u002b00:00","datePublished":"2024-12-24T00:00:00\u002b00:00","dateModified":"2024-12-24T00:00:00\u002b00:00","keywords":["graphics","rendering","pbrt"],"mainEntityOfPage":"true","wordCount":"5906"}]</script><script src=/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj+KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script><link type=text/css rel=stylesheet href=/lib/katex/katex.min.8fee1bb91734542a6701c61b7be516ff2eb2df248bf4e4591aacc8f4e9df40c7ca9e9c0b3f657b166f5f13e69a8fb50a139b3babcef20aeeea18f0fbcd4169fb.css integrity="sha512-j+4buRc0VCpnAcYbe+UW/y6y3ySL9ORZGqzI9OnfQMfKnpwLP2V7Fm9fE+aaj7UKE5s7q87yCu7qGPD7zUFp+w=="><script defer src=/lib/katex/katex.min.8c68eaeb75cfdcfac071717a969e1b9d9230ad52c6a2ac21ff846eaf6a258364cbb79e5e3552e32c280faeb4f4eda4d7c5bd1492e30a961c737e1e5305300281.js integrity="sha512-jGjq63XP3PrAcXF6lp4bnZIwrVLGoqwh/4Rur2olg2TLt55eNVLjLCgPrrT07aTXxb0UkuMKlhxzfh5TBTACgQ=="></script><script defer src=/lib/katex/auto-render.min.e9b2833d28623d18c071d78ef13e9c79d695122d296af3dbcee7bf1bf6518b0565bab59939267fbc8f5faf696193c20f5caef3e7501969cfb306f6738032730d.js integrity="sha512-6bKDPShiPRjAcdeO8T6cedaVEi0pavPbzue/G/ZRiwVlurWZOSZ/vI9fr2lhk8IPXK7z51AZac+zBvZzgDJzDQ==" onload=renderMathInElement(document.body)></script><script data-id=umami-script async src=https://analytics.umami.is/script.js data-website-id=e54a34b7-b153-41c0-a794-bb050c0c1abc></script><script type=text/javascript>document.querySelector('script[data-id="umami-script"]').addEventListener("load",function(){const e=document.head.querySelector('meta[property = "og:type"]').getAttribute("content");let t=document.head.querySelector('meta[property = "og:title"]').getAttribute("content"),n=document.head.querySelector('meta[property = "og:url"]').getAttribute("content");umami.track(e+":"+t,{url:n})})</script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start gap-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">tsssni&rsquo;s blowfish blog</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/render/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=Rendering>渲染</p></a><a href=/unix/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=Unix>Unix</p></a><a href=/acgn/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title=ACGN>ACGN</p></a><a href class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>关于</p></a><a href class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title></p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-1 rtl:ml-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><label id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/render/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=Rendering>渲染</p></a></li><li class=mt-1><a href=/unix/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=Unix>Unix</p></a></li><li class=mt-1><a href=/acgn/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title=ACGN>ACGN</p></a></li><li class=mt-1><a href class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>关于</p></a></li><li class=mt-1><a href class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title></p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div class="w-full rounded-md h-36 md:h-56 lg:h-72 single_hero_basic nozoom" style=background-image:url(/render/pbrt-v4-episode-10/featured_hu_ccff0193129c329b.jpg)></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/plana-hero_hu_c87777a65a22491f.png)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-30 dark:opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">pbrt-v4 Ep. X: 材质纹理</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2024-12-24T00:00:00+00:00>2024 December 24</time><span class="px-2 text-primary-500">&#183;</span><span>5906 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>12 分钟</span></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='return window.open("/tags/graphics/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Graphics
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='return window.open("/tags/rendering/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Rendering
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='return window.open("/tags/pbrt/","_self"),!1'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Pbrt</span></span></span></div></div><div class="flex author"><div class=place-self-center><div class="text-2xl sm:text-lg"></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open id=TOCView class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#纹理采样与反走样>纹理采样与反走样</a><ul><li><a href=#介质过渡处的光线微分>介质过渡处的光线微分</a></li><li><a href=#镜面反射与透射的光线微分>镜面反射与透射的光线微分</a></li><li><a href=#纹理方程滤波>纹理方程滤波</a></li></ul></li><li><a href=#纹理坐标生成>纹理坐标生成</a><ul><li><a href=#uv映射>\((u,v)\)映射</a></li><li><a href=#球形映射>球形映射</a></li><li><a href=#圆柱映射>圆柱映射</a></li><li><a href=#平面映射>平面映射</a></li><li><a href=#三维映射>三维映射</a></li></ul></li><li><a href=#纹理接口与基础纹理>纹理接口与基础纹理</a><ul><li><a href=#常量纹理>常量纹理</a></li><li><a href=#缩放纹理>缩放纹理</a></li><li><a href=#混合纹理>混合纹理</a></li></ul></li><li><a href=#图像纹理>图像纹理</a><ul><li><a href=#纹理内存管理>纹理内存管理</a></li><li><a href=#图像纹理求解>图像纹理求解</a></li><li><a href=#mipmap>mipmap</a></li><li><a href=#图像滤波>图像滤波</a></li></ul></li><li><a href=#材质接口与实现>材质接口与实现</a><ul><li><a href=#材质实现>材质实现</a><ul><li><a href=#漫反射材质>漫反射材质</a></li><li><a href=#绝缘体材质>绝缘体材质</a></li><li><a href=#混合材质>混合材质</a></li></ul></li><li><a href=#获取表面bsdf>获取表面BSDF</a></li><li><a href=#法线映射>法线映射</a></li><li><a href=#视差映射>视差映射</a></li></ul></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#纹理采样与反走样>纹理采样与反走样</a><ul><li><a href=#介质过渡处的光线微分>介质过渡处的光线微分</a></li><li><a href=#镜面反射与透射的光线微分>镜面反射与透射的光线微分</a></li><li><a href=#纹理方程滤波>纹理方程滤波</a></li></ul></li><li><a href=#纹理坐标生成>纹理坐标生成</a><ul><li><a href=#uv映射>\((u,v)\)映射</a></li><li><a href=#球形映射>球形映射</a></li><li><a href=#圆柱映射>圆柱映射</a></li><li><a href=#平面映射>平面映射</a></li><li><a href=#三维映射>三维映射</a></li></ul></li><li><a href=#纹理接口与基础纹理>纹理接口与基础纹理</a><ul><li><a href=#常量纹理>常量纹理</a></li><li><a href=#缩放纹理>缩放纹理</a></li><li><a href=#混合纹理>混合纹理</a></li></ul></li><li><a href=#图像纹理>图像纹理</a><ul><li><a href=#纹理内存管理>纹理内存管理</a></li><li><a href=#图像纹理求解>图像纹理求解</a></li><li><a href=#mipmap>mipmap</a></li><li><a href=#图像滤波>图像滤波</a></li></ul></li><li><a href=#材质接口与实现>材质接口与实现</a><ul><li><a href=#材质实现>材质实现</a><ul><li><a href=#漫反射材质>漫反射材质</a></li><li><a href=#绝缘体材质>绝缘体材质</a></li><li><a href=#混合材质>混合材质</a></li></ul></li><li><a href=#获取表面bsdf>获取表面BSDF</a></li><li><a href=#法线映射>法线映射</a></li><li><a href=#视差映射>视差映射</a></li></ul></li></ul></nav></div></details><script>var margin=200,marginError=50;(function(){var t=$(window),e=$("#TOCView"),s=e.height();function n(){var n=t.height()-margin;s>=n?(e.css("overflow-y","scroll"),e.css("max-height",n+marginError+"px")):(e.css("overflow-y","hidden"),e.css("max-height","9999999px"))}t.on("resize",n),$(document).ready(n)})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><p>纹理描述表面上标量或光谱量在空间上的变化, 材质通过求解表面上某个点的纹理来决定其BSDF参数.</p><h2 class="relative group">纹理采样与反走样<div id=%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E4%B8%8E%E5%8F%8D%E8%B5%B0%E6%A0%B7 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E4%B8%8E%E5%8F%8D%E8%B5%B0%E6%A0%B7 aria-label=锚点>#</a></span></h2><p>纹理反走样比光线渲染结果反走样要容易, 某些纹理具有解析形式, 同时也可以做预滤波, 通常来说每个像素不会需要多于一个的纹理样本.</p><p><code>GenerateRayDifferential</code>获取相邻像素发出的光线的相交结果, 此时可以计算当前像素的\(\frac{\partial p}{\partial u}\)和\(\frac{\partial p}{\partial v}\), pbrt会根据交点的位置与法线构建切平面, 让相交光线与切平面相交来获取微分估计值.</p><p>对于例如漫反射的难以计算微分的情况以及不支持<code>GenerateRayDifferential</code>的相机, pbrt会将相机变换到朝向交点的方向, 根据相机提供的最小光线位置与方向的微分来生成微分光线, 再变换回渲染空间.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Approximate_dp_dxy</span><span class=p>(</span><span class=n>Point3f</span> <span class=n>p</span><span class=p>,</span> <span class=n>Normal3f</span> <span class=n>n</span><span class=p>,</span> <span class=n>Float</span> <span class=n>time</span><span class=p>,</span> <span class=kt>int</span> <span class=n>samplesPerPixel</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>Vector3f</span> <span class=o>*</span><span class=n>dpdx</span><span class=p>,</span> <span class=n>Vector3f</span> <span class=o>*</span><span class=n>dpdy</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute tangent plane equation for ray differential intersections
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Point3f</span> <span class=n>pCamera</span> <span class=o>=</span> <span class=n>CameraFromRender</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Transform</span> <span class=n>DownZFromCamera</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>RotateFromTo</span><span class=p>(</span><span class=n>Normalize</span><span class=p>(</span><span class=n>Vector3f</span><span class=p>(</span><span class=n>pCamera</span><span class=p>)),</span> <span class=n>Vector3f</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>Point3f</span> <span class=n>pDownZ</span> <span class=o>=</span> <span class=n>DownZFromCamera</span><span class=p>(</span><span class=n>pCamera</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Normal3f</span> <span class=n>nDownZ</span> <span class=o>=</span> <span class=n>DownZFromCamera</span><span class=p>(</span><span class=n>CameraFromRender</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>time</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>d</span> <span class=o>=</span> <span class=n>nDownZ</span><span class=p>.</span><span class=n>z</span> <span class=o>*</span> <span class=n>pDownZ</span><span class=p>.</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Find intersection points for approximated camera differential rays
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Ray</span> <span class=n>xRay</span><span class=p>(</span><span class=n>Point3f</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>minPosDifferentialX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>Vector3f</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>minDirDifferentialX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>tx</span> <span class=o>=</span> <span class=o>-</span><span class=p>(</span><span class=n>Dot</span><span class=p>(</span><span class=n>nDownZ</span><span class=p>,</span> <span class=n>Vector3f</span><span class=p>(</span><span class=n>xRay</span><span class=p>.</span><span class=n>o</span><span class=p>))</span> <span class=o>-</span> <span class=n>d</span><span class=p>)</span> <span class=o>/</span> <span class=n>Dot</span><span class=p>(</span><span class=n>nDownZ</span><span class=p>,</span> <span class=n>xRay</span><span class=p>.</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Ray</span> <span class=n>yRay</span><span class=p>(</span><span class=n>Point3f</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=n>minPosDifferentialY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>Vector3f</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>minDirDifferentialY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>ty</span> <span class=o>=</span> <span class=o>-</span><span class=p>(</span><span class=n>Dot</span><span class=p>(</span><span class=n>nDownZ</span><span class=p>,</span> <span class=n>Vector3f</span><span class=p>(</span><span class=n>yRay</span><span class=p>.</span><span class=n>o</span><span class=p>))</span> <span class=o>-</span> <span class=n>d</span><span class=p>)</span> <span class=o>/</span> <span class=n>Dot</span><span class=p>(</span><span class=n>nDownZ</span><span class=p>,</span> <span class=n>yRay</span><span class=p>.</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Point3f</span> <span class=n>px</span> <span class=o>=</span> <span class=n>xRay</span><span class=p>(</span><span class=n>tx</span><span class=p>),</span> <span class=n>py</span> <span class=o>=</span> <span class=n>yRay</span><span class=p>(</span><span class=n>ty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Estimate $\dpdx$ and $\dpdy$ in tangent plane at intersection point
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>sppScale</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>GetOptions</span><span class=p>().</span><span class=n>disablePixelJitter</span>
</span></span><span class=line><span class=cl>            <span class=o>?</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=o>&lt;</span><span class=n>Float</span><span class=o>&gt;</span><span class=p>(</span><span class=mf>.125</span><span class=p>,</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>std</span><span class=o>::</span><span class=n>sqrt</span><span class=p>((</span><span class=n>Float</span><span class=p>)</span><span class=n>samplesPerPixel</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dpdx</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>sppScale</span> <span class=o>*</span> <span class=n>RenderFromCamera</span><span class=p>(</span><span class=n>DownZFromCamera</span><span class=p>.</span><span class=n>ApplyInverse</span><span class=p>(</span><span class=n>px</span> <span class=o>-</span> <span class=n>pDownZ</span><span class=p>),</span> <span class=n>time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dpdy</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>sppScale</span> <span class=o>*</span> <span class=n>RenderFromCamera</span><span class=p>(</span><span class=n>DownZFromCamera</span><span class=p>.</span><span class=n>ApplyInverse</span><span class=p>(</span><span class=n>py</span> <span class=o>-</span> <span class=n>pDownZ</span><span class=p>),</span> <span class=n>time</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>正交投影各个像素上的光线位置变化与渲染空间一致, 光线方向不变, 因此可以直接获取微分. 其它相机会遍历屏幕对角线上的像素, 计算各个像素发射的光线, 比较这些光线以获取光线位置与方向的最小变化值作为微分.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>CameraBase</span><span class=o>::</span><span class=n>FindMinimumDifferentials</span><span class=p>(</span><span class=n>Camera</span> <span class=n>camera</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>minPosDifferentialX</span> <span class=o>=</span> <span class=n>minPosDifferentialY</span> <span class=o>=</span> <span class=n>minDirDifferentialX</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>minDirDifferentialY</span> <span class=o>=</span> <span class=n>Vector3f</span><span class=p>(</span><span class=n>Infinity</span><span class=p>,</span> <span class=n>Infinity</span><span class=p>,</span> <span class=n>Infinity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CameraSample</span> <span class=n>sample</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>sample</span><span class=p>.</span><span class=n>pLens</span> <span class=o>=</span> <span class=n>Point2f</span><span class=p>(</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sample</span><span class=p>.</span><span class=n>time</span> <span class=o>=</span> <span class=mf>0.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SampledWavelengths</span> <span class=n>lambda</span> <span class=o>=</span> <span class=n>SampledWavelengths</span><span class=o>::</span><span class=n>SampleVisible</span><span class=p>(</span><span class=mf>0.5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>512</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sample</span><span class=p>.</span><span class=n>pFilm</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>Float</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>film</span><span class=p>.</span><span class=n>FullResolution</span><span class=p>().</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sample</span><span class=p>.</span><span class=n>pFilm</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>Float</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>film</span><span class=p>.</span><span class=n>FullResolution</span><span class=p>().</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>pstd</span><span class=o>::</span><span class=n>optional</span><span class=o>&lt;</span><span class=n>CameraRayDifferential</span><span class=o>&gt;</span> <span class=n>crd</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>camera</span><span class=p>.</span><span class=n>GenerateRayDifferential</span><span class=p>(</span><span class=n>sample</span><span class=p>,</span> <span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>crd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>RayDifferential</span> <span class=o>&amp;</span><span class=n>ray</span> <span class=o>=</span> <span class=n>crd</span><span class=o>-&gt;</span><span class=n>ray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3f</span> <span class=n>dox</span> <span class=o>=</span> <span class=n>CameraFromRender</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>rxOrigin</span> <span class=o>-</span> <span class=n>ray</span><span class=p>.</span><span class=n>o</span><span class=p>,</span> <span class=n>ray</span><span class=p>.</span><span class=n>time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>Length</span><span class=p>(</span><span class=n>dox</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>Length</span><span class=p>(</span><span class=n>minPosDifferentialX</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>minPosDifferentialX</span> <span class=o>=</span> <span class=n>dox</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3f</span> <span class=n>doy</span> <span class=o>=</span> <span class=n>CameraFromRender</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>ryOrigin</span> <span class=o>-</span> <span class=n>ray</span><span class=p>.</span><span class=n>o</span><span class=p>,</span> <span class=n>ray</span><span class=p>.</span><span class=n>time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>Length</span><span class=p>(</span><span class=n>doy</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>Length</span><span class=p>(</span><span class=n>minPosDifferentialY</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>minPosDifferentialY</span> <span class=o>=</span> <span class=n>doy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>ray</span><span class=p>.</span><span class=n>d</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ray</span><span class=p>.</span><span class=n>rxDirection</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>rxDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ray</span><span class=p>.</span><span class=n>ryDirection</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>ryDirection</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Frame</span> <span class=n>f</span> <span class=o>=</span> <span class=n>Frame</span><span class=o>::</span><span class=n>FromZ</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3f</span> <span class=n>df</span> <span class=o>=</span> <span class=n>f</span><span class=p>.</span><span class=n>ToLocal</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>d</span><span class=p>);</span>  <span class=c1>// should be (0, 0, 1);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Vector3f</span> <span class=n>dxf</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>ToLocal</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>rxDirection</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3f</span> <span class=n>dyf</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>ToLocal</span><span class=p>(</span><span class=n>ray</span><span class=p>.</span><span class=n>ryDirection</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>Length</span><span class=p>(</span><span class=n>dxf</span> <span class=o>-</span> <span class=n>df</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>Length</span><span class=p>(</span><span class=n>minDirDifferentialX</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>minDirDifferentialX</span> <span class=o>=</span> <span class=n>dxf</span> <span class=o>-</span> <span class=n>df</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>Length</span><span class=p>(</span><span class=n>dyf</span> <span class=o>-</span> <span class=n>df</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>Length</span><span class=p>(</span><span class=n>minDirDifferentialY</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>minDirDifferentialY</span> <span class=o>=</span> <span class=n>dyf</span> <span class=o>-</span> <span class=n>df</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>LOG_VERBOSE</span><span class=p>(</span><span class=s>&#34;Camera min pos differentials: %s, %s&#34;</span><span class=p>,</span> <span class=n>minPosDifferentialX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>minPosDifferentialY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>LOG_VERBOSE</span><span class=p>(</span><span class=s>&#34;Camera min dir differentials: %s, %s&#34;</span><span class=p>,</span> <span class=n>minDirDifferentialX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>minDirDifferentialY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>令\((u, v)\)为纹理坐标, \((x,y)\)为像素坐标, 根据与形状的相交结果可以获取\(\frac{\partial p}{\partial u}\)和\(\frac{\partial p}{\partial v}\), 根据光线微分可以获取\(\frac{\partial p}{\partial x}\)和\(\frac{\partial p}{\partial y}\), 通过链式法则可以获取\(\frac{\partial u}{\partial x}\), \(\frac{\partial u}{\partial y}\), \(\frac{\partial v}{\partial x}\)和\(\frac{\partial v}{\partial y}\). 这可以通过最小二乘法求解, 其计算过程如下, 此时\(\bold{A}=\begin{bmatrix}\frac{\partial p}{\partial u}\ \frac{\partial p}{\partial v}\end{bmatrix}\),\(\bold{b}=\begin{bmatrix}\frac{\partial p}{\partial x}\end{bmatrix}\),\(\bold{x}=\begin{bmatrix}\frac{\partial u}{\partial x}\\\frac{\partial v}{\partial x}\end{bmatrix}\).</p><p>$$
\begin{equation}
\begin{aligned}
\bold{A}\bold{x}&=\bold{b}\\
\bold{x}&=(\bold{A}^T \bold{A})^{-1}\bold{A}^T \bold{b}
\end{aligned}
\end{equation}
$$</p><h3 class="relative group">介质过渡处的光线微分<div id=%E4%BB%8B%E8%B4%A8%E8%BF%87%E6%B8%A1%E5%A4%84%E7%9A%84%E5%85%89%E7%BA%BF%E5%BE%AE%E5%88%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%BB%8B%E8%B4%A8%E8%BF%87%E6%B8%A1%E5%A4%84%E7%9A%84%E5%85%89%E7%BA%BF%E5%BE%AE%E5%88%86 aria-label=锚点>#</a></span></h3><p>当光线与表示介质过渡但不散射光线的表面相交是, pbrt会返回未设置的<code>BSDF</code>, 光线会将原点设置为交点后继续执行路径追踪, 光线微分也具有同样的行为.</p><h3 class="relative group">镜面反射与透射的光线微分<div id=%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E4%B8%8E%E9%80%8F%E5%B0%84%E7%9A%84%E5%85%89%E7%BA%BF%E5%BE%AE%E5%88%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E4%B8%8E%E9%80%8F%E5%B0%84%E7%9A%84%E5%85%89%E7%BA%BF%E5%BE%AE%E5%88%86 aria-label=锚点>#</a></span></h3><p>通过反射或折射可见的物体同样需要反走样, 例如镜子中的物体.</p><p>反射方向的偏导数如下, 式中的偏导数都是可以计算出来的.</p><p>$$
\begin{equation}
\begin{aligned}
\frac{\partial \omega_i}{\partial x}
&=\frac{\partial}{\partial x}(-\omega_o+2(\omega_o\cdot\bold{n})\bold{n})\\
&=-\frac{\partial\omega_o}{\partial x}+2((\omega_o\cdot\bold{n})\frac{\partial\bold{n}}{\partial x}+\bold{n}\frac{\partial(\omega_o\cdot\bold{n})}{\partial x})\\
&=-\frac{\partial\omega_o}{\partial x}+2((\omega_o\cdot\bold{n})\frac{\partial\bold{n}}{\partial x}+\bold{n}(\bold{n}\frac{\partial\omega_o}{\partial x}+\omega_o\frac{\partial\bold{n}}{\partial x}))
\end{aligned}
\end{equation}
$$</p><p>根据折射光线方向的定义可以得到其微分, 其中\(\mu=\frac{1}{\eta}(\omega_o\cdot\bold{n})-\cos\theta_i\). \(\frac{\partial\mu}{\partial x}\)中包含\(\frac{\partial\cos\theta_i}{\partial x}\), 这可以通过Snell定律得到.</p><p>$$
\begin{equation}
\frac{\partial\omega_i}{\partial x}=-\frac{1}{\eta}\frac{\partial\omega_o}{\partial x}+\mu\frac{\partial\bold{n}}{\partial x}+\frac{\partial\mu}{\partial x}\bold{n}
\end{equation}
$$</p><h3 class="relative group">纹理方程滤波<div id=%E7%BA%B9%E7%90%86%E6%96%B9%E7%A8%8B%E6%BB%A4%E6%B3%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BA%B9%E7%90%86%E6%96%B9%E7%A8%8B%E6%BB%A4%E6%B3%A2 aria-label=锚点>#</a></span></h3><p>反走样需要限制信号带宽, 去除纹理中频率高于Nyquist频率的部分, 对应的卷积如下, \(f\)为将像素坐标映射到纹理坐标的函数. 根据之前章节的内容, 我们可以知道其Fourier变换相当于与盒形方程相乘, 这可以直接去除高频部分.</p><p>$$
\begin{equation}
T_b(x,y)=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\text{sinc}(x&rsquo;)\text{sinc}(y&rsquo;)T&rsquo;(f(x-x&rsquo;,y-y&rsquo;))dx&rsquo;dy'
\end{equation}
$$</p><p>限制带宽后还需要还需要执行采样, \(g\)为采样所用的滤波器.</p><p>$$
\begin{equation}
T_{\text{ideal}}(x,y)=\int_{-\frac{w_x}{2}}^{\frac{w_x}{2}}\int_{-\frac{w_x}{2}}^{\frac{w_x}{2}}g(x&rsquo;,y&rsquo;)T_b(x-x&rsquo;,y-y&rsquo;)dx&rsquo;dy'
\end{equation}
$$</p><p>这类理想采样实际上只对线性变化的量有效, 例如albedo对光照的贡献的变化, 而像roughness对BSDF的贡献就是非线性的, pbrt不考虑这点.</p><p>在纹理滤波这一任务上, 盒形滤波也可以取得较好的效果, 且计算过程简单, 其定义如下, 其中\(u_0=u-\frac{1}{2}\max(\frac{du}{dx},\frac{dv}{dx})\), \(u_1=u+\frac{1}{2}\max(\frac{du}{dx},\frac{dv}{dx})\), \(v_0\), \(v_1\)同理.</p><p>$$
\begin{equation}
T_{\text{box}}(x,y)=\frac{1}{(u_1-u_0)(v_1-v_0)}\int_{v_0}^{v_1}\int_{u_0}^{u_1}T(u&rsquo;,v&rsquo;)du&rsquo;dv'
\end{equation}
$$</p><h2 class="relative group">纹理坐标生成<div id=%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87%E7%94%9F%E6%88%90 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87%E7%94%9F%E6%88%90 aria-label=锚点>#</a></span></h2><p>对于参数化几何形状, 纹理坐标是与生俱来的属性. 对于三维纹理, 几何位置就是最佳纹理坐标. 对于其它情况, 纹理坐标需要手动生成, 或者像球的极点一样, 虽然有纹理坐标但是扭曲较为严重, 需要重新生成. pbrt使用\((u,v)\)表示参数化表面本来的纹理坐标, \((s,t)\)表示生成的纹理坐标.</p><p><code>TextureMapping2D</code>接口负责二维纹理坐标的生成.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>TextureMapping2D</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TaggedPointer</span><span class=o>&lt;</span><span class=n>UVMapping</span><span class=p>,</span> <span class=n>SphericalMapping</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                              <span class=n>CylindricalMapping</span><span class=p>,</span> <span class=n>PlanarMapping</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TextureMapping2D Interface
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>TaggedPointer</span><span class=o>::</span><span class=n>TaggedPointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>TextureMapping2D</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>TaggedPointer</span><span class=o>&lt;</span><span class=n>UVMapping</span><span class=p>,</span> <span class=n>SphericalMapping</span><span class=p>,</span> <span class=n>CylindricalMapping</span><span class=p>,</span> <span class=n>PlanarMapping</span><span class=o>&gt;</span> <span class=n>tp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>TaggedPointer</span><span class=p>(</span><span class=n>tp</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>TextureMapping2D</span> <span class=nf>Create</span><span class=p>(</span><span class=k>const</span> <span class=n>ParameterDictionary</span> <span class=o>&amp;</span><span class=n>parameters</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=k>const</span> <span class=n>Transform</span> <span class=o>&amp;</span><span class=n>renderFromTexture</span><span class=p>,</span> <span class=k>const</span> <span class=n>FileLoc</span> <span class=o>*</span><span class=n>loc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>TexCoord2D</span> <span class=nf>Map</span><span class=p>(</span><span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>Map</code>负责执行映射, 返回的<code>TexCoord2D</code>的定义如下, 其中包含\((s,t)\)坐标及其导数.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TexCoord2D</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2f</span> <span class=n>st</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>dsdx</span><span class=p>,</span> <span class=n>dsdy</span><span class=p>,</span> <span class=n>dtdx</span><span class=p>,</span> <span class=n>dtdy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>Map</code>参数为<code>TextureEvalContext</code>而非<code>SurfaceInteraction</code>是因为考虑到了GPU的缓存结构, 其定义如下.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TextureEvalContext</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TextureEvalContext Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>TextureEvalContext</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>TextureEvalContext</span><span class=p>(</span><span class=k>const</span> <span class=n>Interaction</span> <span class=o>&amp;</span><span class=n>intr</span><span class=p>)</span> <span class=o>:</span> <span class=n>p</span><span class=p>(</span><span class=n>intr</span><span class=p>.</span><span class=n>p</span><span class=p>()),</span> <span class=n>uv</span><span class=p>(</span><span class=n>intr</span><span class=p>.</span><span class=n>uv</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>TextureEvalContext</span><span class=p>(</span><span class=k>const</span> <span class=n>SurfaceInteraction</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>p</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>p</span><span class=p>()),</span>
</span></span><span class=line><span class=cl>          <span class=n>dpdx</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dpdx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dpdy</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dpdy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>n</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>n</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>uv</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>uv</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dudx</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dudx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dudy</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dudy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dvdx</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dvdx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dvdy</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dvdy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>faceIndex</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>faceIndex</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>TextureEvalContext</span><span class=p>(</span><span class=n>Point3f</span> <span class=n>p</span><span class=p>,</span> <span class=n>Vector3f</span> <span class=n>dpdx</span><span class=p>,</span> <span class=n>Vector3f</span> <span class=n>dpdy</span><span class=p>,</span> <span class=n>Normal3f</span> <span class=n>n</span><span class=p>,</span> <span class=n>Point2f</span> <span class=n>uv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>Float</span> <span class=n>dudx</span><span class=p>,</span> <span class=n>Float</span> <span class=n>dudy</span><span class=p>,</span> <span class=n>Float</span> <span class=n>dvdx</span><span class=p>,</span> <span class=n>Float</span> <span class=n>dvdy</span><span class=p>,</span> <span class=kt>int</span> <span class=n>faceIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>p</span><span class=p>(</span><span class=n>p</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dpdx</span><span class=p>(</span><span class=n>dpdx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dpdy</span><span class=p>(</span><span class=n>dpdy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>n</span><span class=p>(</span><span class=n>n</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>uv</span><span class=p>(</span><span class=n>uv</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dudx</span><span class=p>(</span><span class=n>dudx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dudy</span><span class=p>(</span><span class=n>dudy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dvdx</span><span class=p>(</span><span class=n>dvdx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dvdy</span><span class=p>(</span><span class=n>dvdy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>faceIndex</span><span class=p>(</span><span class=n>faceIndex</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Point3f</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3f</span> <span class=n>dpdx</span><span class=p>,</span> <span class=n>dpdy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Normal3f</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2f</span> <span class=n>uv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>dudx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dudy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dvdx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dvdy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>faceIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">\((u,v)\)映射<div id=uv%E6%98%A0%E5%B0%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#uv%E6%98%A0%E5%B0%84 aria-label=锚点>#</a></span></h3><p>\((u,v)\)映射通过对\((u,v)\)坐标的缩放与偏移实现, 定义如下, \(\frac{ds}{dx}\)通过链式法则得到.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>UVMapping</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// UVMapping Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UVMapping</span><span class=p>(</span><span class=n>Float</span> <span class=n>su</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>Float</span> <span class=n>sv</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>Float</span> <span class=n>du</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>Float</span> <span class=n>dv</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>su</span><span class=p>(</span><span class=n>su</span><span class=p>),</span> <span class=n>sv</span><span class=p>(</span><span class=n>sv</span><span class=p>),</span> <span class=n>du</span><span class=p>(</span><span class=n>du</span><span class=p>),</span> <span class=n>dv</span><span class=p>(</span><span class=n>dv</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=n>TexCoord2D</span> <span class=nf>Map</span><span class=p>(</span><span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Compute texture differentials for 2D $(u,v)$ mapping
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Float</span> <span class=n>dsdx</span> <span class=o>=</span> <span class=n>su</span> <span class=o>*</span> <span class=n>ctx</span><span class=p>.</span><span class=n>dudx</span><span class=p>,</span> <span class=n>dsdy</span> <span class=o>=</span> <span class=n>su</span> <span class=o>*</span> <span class=n>ctx</span><span class=p>.</span><span class=n>dudy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Float</span> <span class=n>dtdx</span> <span class=o>=</span> <span class=n>sv</span> <span class=o>*</span> <span class=n>ctx</span><span class=p>.</span><span class=n>dvdx</span><span class=p>,</span> <span class=n>dtdy</span> <span class=o>=</span> <span class=n>sv</span> <span class=o>*</span> <span class=n>ctx</span><span class=p>.</span><span class=n>dvdy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Point2f</span> <span class=n>st</span><span class=p>(</span><span class=n>su</span> <span class=o>*</span> <span class=n>ctx</span><span class=p>.</span><span class=n>uv</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>du</span><span class=p>,</span> <span class=n>sv</span> <span class=o>*</span> <span class=n>ctx</span><span class=p>.</span><span class=n>uv</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>TexCoord2D</span><span class=p>{</span><span class=n>st</span><span class=p>,</span> <span class=n>dsdx</span><span class=p>,</span> <span class=n>dsdy</span><span class=p>,</span> <span class=n>dtdx</span><span class=p>,</span> <span class=n>dtdy</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>su</span><span class=p>,</span> <span class=n>sv</span><span class=p>,</span> <span class=n>du</span><span class=p>,</span> <span class=n>dv</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">球形映射<div id=%E7%90%83%E5%BD%A2%E6%98%A0%E5%B0%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%90%83%E5%BD%A2%E6%98%A0%E5%B0%84 aria-label=锚点>#</a></span></h3><p>球形映射定义如下, \(\text{atan2}\)代表\(p_x,p_y\)所形成的角度, 通过<code>std::atan2</code>获取, 可以正确的处理符号与象限. 这里认为得到的角度范围在\([0,2\pi]\),而非实际返回的\([-\pi,\pi]\).</p><p>$$
\begin{equation}
f(p)=(\frac{1}{\pi}\text{arccos}\frac{p_x}{\Vert p_x^2+p_y^2+p_z^2 \Vert}, \frac{1}{2\pi}\text{atan2}(p_y,p_x))
\end{equation}
$$</p><h3 class="relative group">圆柱映射<div id=%E5%9C%86%E6%9F%B1%E6%98%A0%E5%B0%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%9C%86%E6%9F%B1%E6%98%A0%E5%B0%84 aria-label=锚点>#</a></span></h3><p>圆柱映射定义如下, 注意到\(t\)坐标需要被缩放, 或者通过某种手段采样超出范围的纹理.</p><p>$$
\begin{equation}
f(p)=(\frac{1}{2\pi}\text{atan2}(p_y,p_x),p_z)
\end{equation}
$$</p><h3 class="relative group">平面映射<div id=%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84 aria-label=锚点>#</a></span></h3><p>平面映射通过两个不平行的向量和偏移定义.</p><p>$$
\begin{equation}
f(p)=((p-(0,0,0)\cdot\bold{v}_s)+d_s,(p-(0,0,0)\cdot\bold{v}_t)+d_t)
\end{equation}
$$</p><h3 class="relative group">三维映射<div id=%E4%B8%89%E7%BB%B4%E6%98%A0%E5%B0%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E4%B8%89%E7%BB%B4%E6%98%A0%E5%B0%84 aria-label=锚点>#</a></span></h3><p>通过几何坐标采样纹理即可.</p><h2 class="relative group">纹理接口与基础纹理<div id=%E7%BA%B9%E7%90%86%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BA%B9%E7%90%86%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86 aria-label=锚点>#</a></span></h2><p>pbrt支持浮点类型的标量纹理与光谱量纹理, 本文只记录光谱量纹理的定义, 其定义如下. <code>SpectrumTexture</code>的<code>Evaluate</code>需要考虑波长.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpectrumTexture</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=k>public</span> <span class=n>TaggedPointer</span><span class=o>&lt;</span>  <span class=c1>// SpectrumTextures
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>SpectrumImageTexture</span><span class=p>,</span> <span class=n>GPUSpectrumImageTexture</span><span class=p>,</span> <span class=n>SpectrumMixTexture</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>SpectrumDirectionMixTexture</span><span class=p>,</span> <span class=n>SpectrumScaledTexture</span><span class=p>,</span> <span class=n>SpectrumConstantTexture</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>SpectrumBilerpTexture</span><span class=p>,</span> <span class=n>SpectrumCheckerboardTexture</span><span class=p>,</span> <span class=n>MarbleTexture</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>SpectrumDotsTexture</span><span class=p>,</span> <span class=n>SpectrumPtexTexture</span><span class=p>,</span> <span class=n>GPUSpectrumPtexTexture</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SpectrumTexture Interface
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>TaggedPointer</span><span class=o>::</span><span class=n>TaggedPointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>SpectrumTexture</span> <span class=nf>Create</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=k>const</span> <span class=n>Transform</span> <span class=o>&amp;</span><span class=n>renderFromTexture</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=k>const</span> <span class=n>TextureParameterDictionary</span> <span class=o>&amp;</span><span class=n>parameters</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>SpectrumType</span> <span class=n>spectrumType</span><span class=p>,</span> <span class=k>const</span> <span class=n>FileLoc</span> <span class=o>*</span><span class=n>loc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>gpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>SampledSpectrum</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                 <span class=n>SampledWavelengths</span> <span class=n>lambda</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">常量纹理<div id=%E5%B8%B8%E9%87%8F%E7%BA%B9%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%B8%B8%E9%87%8F%E7%BA%B9%E7%90%86 aria-label=锚点>#</a></span></h3><p>常量纹理主要用于表示材质的某些参数, 使得材质只需要考虑纹理接口.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>SampledSpectrum</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>SampledWavelengths</span> <span class=n>lambda</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>value</span><span class=p>.</span><span class=n>Sample</span><span class=p>(</span><span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">缩放纹理<div id=%E7%BC%A9%E6%94%BE%E7%BA%B9%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BC%A9%E6%94%BE%E7%BA%B9%E7%90%86 aria-label=锚点>#</a></span></h3><p>缩放纹理通过将两张纹理相乘获取新的纹理.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>SampledSpectrum</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>SampledWavelengths</span> <span class=n>lambda</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>sc</span> <span class=o>=</span> <span class=n>scale</span><span class=p>.</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SampledSpectrum</span><span class=p>(</span><span class=mf>0.f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tex</span><span class=p>.</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>lambda</span><span class=p>)</span> <span class=o>*</span> <span class=n>sc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">混合纹理<div id=%E6%B7%B7%E5%90%88%E7%BA%B9%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%B7%B7%E5%90%88%E7%BA%B9%E7%90%86 aria-label=锚点>#</a></span></h3><p>混合纹理通过混合系数来混合两张纹理.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl><span class=n>SampledSpectrum</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>SampledWavelengths</span> <span class=n>lambda</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>amt</span> <span class=o>=</span> <span class=n>amount</span><span class=p>.</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SampledSpectrum</span> <span class=n>t1</span><span class=p>,</span> <span class=n>t2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>amt</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span> <span class=o>=</span> <span class=n>tex1</span><span class=p>.</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>amt</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span> <span class=o>=</span> <span class=n>tex2</span><span class=p>.</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>amt</span><span class=p>)</span> <span class=o>*</span> <span class=n>t1</span> <span class=o>+</span> <span class=n>amt</span> <span class=o>*</span> <span class=n>t2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 class="relative group">图像纹理<div id=%E5%9B%BE%E5%83%8F%E7%BA%B9%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%9B%BE%E5%83%8F%E7%BA%B9%E7%90%86 aria-label=锚点>#</a></span></h2><p>图像纹理可以在任意位置被采样, 采样值被称为纹素(texel), 它是图形学中被使用最多的纹理类型. 图像纹理继承<code>ImageTextureBase</code>, 同样可以返回标量或光谱量.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>ImageTextureBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ImageTextureBase Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ImageTextureBase</span><span class=p>(</span><span class=n>TextureMapping2D</span> <span class=n>mapping</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>MIPMapFilterOptions</span> <span class=n>filterOptions</span><span class=p>,</span> <span class=n>WrapMode</span> <span class=n>wrapMode</span><span class=p>,</span> <span class=n>Float</span> <span class=n>scale</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=kt>bool</span> <span class=n>invert</span><span class=p>,</span> <span class=n>ColorEncoding</span> <span class=n>encoding</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>mapping</span><span class=p>(</span><span class=n>mapping</span><span class=p>),</span> <span class=n>filename</span><span class=p>(</span><span class=n>filename</span><span class=p>),</span> <span class=n>scale</span><span class=p>(</span><span class=n>scale</span><span class=p>),</span> <span class=n>invert</span><span class=p>(</span><span class=n>invert</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Get _MIPMap_ from texture cache if present
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>TexInfo</span> <span class=nf>texInfo</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>filterOptions</span><span class=p>,</span> <span class=n>wrapMode</span><span class=p>,</span> <span class=n>encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>textureCacheMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>textureCache</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>texInfo</span><span class=p>);</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>textureCache</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mipmap</span> <span class=o>=</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Create _MIPMap_ for _filename_ and add to texture cache
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mipmap</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=n>MIPMap</span><span class=o>::</span><span class=n>CreateFromFile</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>filterOptions</span><span class=p>,</span> <span class=n>wrapMode</span><span class=p>,</span> <span class=n>encoding</span><span class=p>,</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// This is actually ok, but if it hits, it means we&#39;ve wastefully
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// loaded this texture. (Note that in that case, should just return
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// the one that&#39;s already in there and not replace it.)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CHECK</span><span class=p>(</span><span class=n>textureCache</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>texInfo</span><span class=p>)</span> <span class=o>==</span> <span class=n>textureCache</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>textureCache</span><span class=p>[</span><span class=n>texInfo</span><span class=p>]</span> <span class=o>=</span> <span class=n>mipmap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>void</span> <span class=nf>ClearCache</span><span class=p>()</span> <span class=p>{</span> <span class=n>textureCache</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>MultiplyScale</span><span class=p>(</span><span class=n>Float</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span> <span class=n>scale</span> <span class=o>*=</span> <span class=n>s</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ImageTextureBase Protected Members
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>TextureMapping2D</span> <span class=n>mapping</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>filename</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>invert</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MIPMap</span> <span class=o>*</span><span class=n>mipmap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ImageTextureBase Private Members
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>textureCacheMutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>TexInfo</span><span class=p>,</span> <span class=n>MIPMap</span> <span class=o>*&gt;</span> <span class=n>textureCache</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpectrumImageTexture</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ImageTextureBase</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SpectrumImageTexture Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SpectrumImageTexture</span><span class=p>(</span><span class=n>TextureMapping2D</span> <span class=n>mapping</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>filename</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>MIPMapFilterOptions</span> <span class=n>filterOptions</span><span class=p>,</span> <span class=n>WrapMode</span> <span class=n>wrapMode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>Float</span> <span class=n>scale</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>invert</span><span class=p>,</span> <span class=n>ColorEncoding</span> <span class=n>encoding</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>SpectrumType</span> <span class=n>spectrumType</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>ImageTextureBase</span><span class=p>(</span><span class=n>mapping</span><span class=p>,</span> <span class=n>filename</span><span class=p>,</span> <span class=n>filterOptions</span><span class=p>,</span> <span class=n>wrapMode</span><span class=p>,</span> <span class=n>scale</span><span class=p>,</span> <span class=n>invert</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>encoding</span><span class=p>,</span> <span class=n>alloc</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>spectrumType</span><span class=p>(</span><span class=n>spectrumType</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=n>SampledSpectrum</span> <span class=nf>Evaluate</span><span class=p>(</span><span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>SampledWavelengths</span> <span class=n>lambda</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>SpectrumImageTexture</span> <span class=o>*</span><span class=nf>Create</span><span class=p>(</span><span class=k>const</span> <span class=n>Transform</span> <span class=o>&amp;</span><span class=n>renderFromTexture</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=k>const</span> <span class=n>TextureParameterDictionary</span> <span class=o>&amp;</span><span class=n>parameters</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>SpectrumType</span> <span class=n>spectrumType</span><span class=p>,</span> <span class=k>const</span> <span class=n>FileLoc</span> <span class=o>*</span><span class=n>loc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SpectrumImageTexture Private Members
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SpectrumType</span> <span class=n>spectrumType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">纹理内存管理<div id=%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BA%B9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86 aria-label=锚点>#</a></span></h3><p>pbrt会生成mipmap来处理图像滤波, mipmap只生成一次, 之后通过<code>textureCache</code>读取.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>TexInfo</span> <span class=nf>texInfo</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>filterOptions</span><span class=p>,</span> <span class=n>wrapMode</span><span class=p>,</span> <span class=n>encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>textureCacheMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>textureCache</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>texInfo</span><span class=p>);</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>textureCache</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mipmap</span> <span class=o>=</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
</span></span></code></pre></div><h3 class="relative group">图像纹理求解<div id=%E5%9B%BE%E5%83%8F%E7%BA%B9%E7%90%86%E6%B1%82%E8%A7%A3 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%9B%BE%E5%83%8F%E7%BA%B9%E7%90%86%E6%B1%82%E8%A7%A3 aria-label=锚点>#</a></span></h3><p>pbrt中图像以左下角为原点, 而纹理坐标位于左上角, 这需要手动处理.</p><p>通过图像中的<code>RGBColorSpace</code>与<code>SpectrumType</code>可以从RGB中还原光谱, 对于没有色彩空间信息的图像, pbrt认为是灰度图.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=k>const</span> <span class=n>RGBColorSpace</span> <span class=o>*</span><span class=n>cs</span> <span class=o>=</span> <span class=n>mipmap</span><span class=o>-&gt;</span><span class=n>GetRGBColorSpace</span><span class=p>();</span> <span class=n>cs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>spectrumType</span> <span class=o>==</span> <span class=n>SpectrumType</span><span class=o>::</span><span class=n>Unbounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>RGBUnboundedSpectrum</span><span class=p>(</span><span class=o>*</span><span class=n>cs</span><span class=p>,</span> <span class=n>rgb</span><span class=p>).</span><span class=n>Sample</span><span class=p>(</span><span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>spectrumType</span> <span class=o>==</span> <span class=n>SpectrumType</span><span class=o>::</span><span class=n>Albedo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>RGBAlbedoSpectrum</span><span class=p>(</span><span class=o>*</span><span class=n>cs</span><span class=p>,</span> <span class=n>Clamp</span><span class=p>(</span><span class=n>rgb</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)).</span><span class=n>Sample</span><span class=p>(</span><span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>RGBIlluminantSpectrum</span><span class=p>(</span><span class=o>*</span><span class=n>cs</span><span class=p>,</span> <span class=n>rgb</span><span class=p>).</span><span class=n>Sample</span><span class=p>(</span><span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>DCHECK</span><span class=p>(</span><span class=n>rgb</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>rgb</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>rgb</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>rgb</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nf>SampledSpectrum</span><span class=p>(</span><span class=n>rgb</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span></code></pre></div><h3 class="relative group">mipmap<div id=mipmap class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#mipmap aria-label=锚点>#</a></span></h3><p>mipmap通过将图像预处理为图像金字塔来减小滤波开销, 即每一层为上一层分辨率的一半, mipmap所需的内存只比原图多\(\frac{1}{3}\).</p><h3 class="relative group">图像滤波<div id=%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2 aria-label=锚点>#</a></span></h3><p>pbrt支持以下四种滤波, 除EWA外都具有GPU硬件支持, 根据最大梯度执行各向同性滤波, pbrt会选择使得滤波窗口覆盖四个像素的mip层级. 点滤波只需要选取四个像素中最近的采样点, 双线性插值为三角形滤波, 三线形插值则根据计算出的非整数层级来混合相邻两个层级的双线性滤波结果.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>FilterFunction</span> <span class=p>{</span> <span class=n>Point</span><span class=p>,</span> <span class=n>Bilinear</span><span class=p>,</span> <span class=n>Trilinear</span><span class=p>,</span> <span class=n>EWA</span> <span class=p>};</span>
</span></span></code></pre></div><p>EWA为椭圆加权平均(elliptically weighted average), 它会在不同方向使用不同的梯度, 即各向异性滤波, 且不要求方向与\(x\)轴或\(y\)轴平行. EWA的带限和滤波过程都采用Gaussian滤波器, 而非上述方法所用的盒滤波器带限. pbrt使用短轴长度选择mip层级, 若长短轴比率过大会导致过多的采样点, pbrt会适当增长短轴以使用更高的mip层级, 虽然会有模糊但并不明显</p><p>EWA根据梯度计算得到椭圆, 其形式如下, 然后根据椭圆的梯度得到包围盒, 此时可以选取包围盒内位于椭圆内部的点执行滤波.</p><p>$$
\begin{equation}
\begin{aligned}
e(s,t)&=\frac{A}{F}s^2+\frac{B}{F}st+\frac{C}{F}t^2&lt;1\\
A&=(\frac{\partial s}{\partial y})^2+(\frac{\partial t}{\partial y})^2+1\\
B&=-2(\frac{\partial s}{\partial x}\frac{\partial s}{\partial y}+\frac{\partial t}{\partial x}\frac{\partial t}{\partial y})\\
C&=(\frac{\partial s}{\partial x})^2+(\frac{\partial t}{\partial x})^2+1\\
F&=AC-\frac{B^2}{4}
\end{aligned}
\end{equation}
$$</p><p>已知\(e(s,t)\)为某个点到椭圆中心的距离与对应直线上的椭圆边界到中心的距离的比值的平方, 这与Gaussian滤波器的定义相符, 因此可以通过该值来查表获取滤波权重.</p><h2 class="relative group">材质接口与实现<div id=%E6%9D%90%E8%B4%A8%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%9D%90%E8%B4%A8%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0 aria-label=锚点>#</a></span></h2><p>材质用于求解纹理获取参数后初始化BSDF, 其定义如下.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Material</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=k>public</span> <span class=n>TaggedPointer</span><span class=o>&lt;</span>  <span class=c1>// Material Types
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=n>CoatedDiffuseMaterial</span><span class=p>,</span> <span class=n>CoatedConductorMaterial</span><span class=p>,</span> <span class=n>ConductorMaterial</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>DielectricMaterial</span><span class=p>,</span> <span class=n>DiffuseMaterial</span><span class=p>,</span> <span class=n>DiffuseTransmissionMaterial</span><span class=p>,</span> <span class=n>HairMaterial</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>MeasuredMaterial</span><span class=p>,</span> <span class=n>SubsurfaceMaterial</span><span class=p>,</span> <span class=n>ThinDielectricMaterial</span><span class=p>,</span> <span class=n>MixMaterial</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Material Interface
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>using</span> <span class=n>TaggedPointer</span><span class=o>::</span><span class=n>TaggedPointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Material</span> <span class=nf>Create</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=k>const</span> <span class=n>TextureParameterDictionary</span> <span class=o>&amp;</span><span class=n>parameters</span><span class=p>,</span> <span class=n>Image</span> <span class=o>*</span><span class=n>normalMap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=cm>/*const */</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>Material</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>namedMaterials</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=k>const</span> <span class=n>FileLoc</span> <span class=o>*</span><span class=n>loc</span><span class=p>,</span> <span class=n>Allocator</span> <span class=n>alloc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kr>inline</span> <span class=n>BSDF</span> <span class=n>GetBSDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span> <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>,</span> <span class=n>ScratchBuffer</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kr>inline</span> <span class=n>BSSRDF</span> <span class=n>GetBSSRDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span> <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>,</span> <span class=n>ScratchBuffer</span> <span class=o>&amp;</span><span class=n>buf</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=kt>bool</span> <span class=n>CanEvaluateTextures</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=k>const</span> <span class=n>Image</span> <span class=o>*</span><span class=nf>GetNormalMap</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=n>FloatTexture</span> <span class=nf>GetDisplacement</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span> <span class=kr>inline</span> <span class=kt>bool</span> <span class=nf>HasSubsurfaceScattering</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>Material</code>最核心的方法为<code>GetBxDF</code>, 这里的返回值<code>ConcreteBxDF</code>对于每个派生类都是不同的. pbrt在这里不要求函数签名相同, 这使得<code>BxDF</code>被分配在栈上而非堆上, 有利于GPU渲染.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=n>ConcreteBxDF</span> <span class=n>GetBxDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span> <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span></code></pre></div><p><code>GetBSDF</code>会调用<code>GetBxDF</code>, 这里通过模板获取实际的返回类型.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>BSDF</span> <span class=n>Material</span><span class=o>::</span><span class=n>GetBSDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span> <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=n>ScratchBuffer</span> <span class=o>&amp;</span><span class=n>scratchBuffer</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Define _getBSDF_ lambda function for _Material::GetBSDF()_
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>getBSDF</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=k>auto</span> <span class=n>mtl</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>BSDF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>ConcreteMtl</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>remove_reference_t</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=o>*</span><span class=n>mtl</span><span class=p>)</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>ConcreteBxDF</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>ConcreteMtl</span><span class=o>::</span><span class=n>BxDF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nf>constexpr</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>ConcreteBxDF</span><span class=p>,</span> <span class=kt>void</span><span class=o>&gt;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>BSDF</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Allocate memory for _ConcreteBxDF_ and return _BSDF_ for material
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>ConcreteBxDF</span> <span class=o>*</span><span class=n>bxdf</span> <span class=o>=</span> <span class=n>scratchBuffer</span><span class=p>.</span><span class=n>Alloc</span><span class=o>&lt;</span><span class=n>ConcreteBxDF</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=o>*</span><span class=n>bxdf</span> <span class=o>=</span> <span class=n>mtl</span><span class=o>-&gt;</span><span class=n>GetBxDF</span><span class=p>(</span><span class=n>texEval</span><span class=p>,</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nf>BSDF</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>ns</span><span class=p>,</span> <span class=n>ctx</span><span class=p>.</span><span class=n>dpdus</span><span class=p>,</span> <span class=n>bxdf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>DispatchCPU</span><span class=p>(</span><span class=n>getBSDF</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>包含了次表面散射的材质需要实现<code>GetBSSRDF</code>, 实现上与<code>GetBSDF</code>类似.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=n>ConcreteBSSRDF</span> <span class=n>GetBSSRDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=k>const</span> <span class=n>MaterialEvalContext</span> <span class=o>&amp;</span><span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>BSSRDF</span> <span class=n>Material</span><span class=o>::</span><span class=n>GetBSSRDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span> <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>ScratchBuffer</span> <span class=o>&amp;</span><span class=n>scratchBuffer</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>get</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>](</span><span class=k>auto</span> <span class=n>mtl</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>BSSRDF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>Material</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>remove_reference_t</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=o>*</span><span class=n>mtl</span><span class=p>)</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>MaterialBSSRDF</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Material</span><span class=o>::</span><span class=n>BSSRDF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nf>constexpr</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>MaterialBSSRDF</span><span class=p>,</span> <span class=kt>void</span><span class=o>&gt;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>MaterialBSSRDF</span> <span class=o>*</span><span class=n>bssrdf</span> <span class=o>=</span> <span class=n>scratchBuffer</span><span class=p>.</span><span class=n>Alloc</span><span class=o>&lt;</span><span class=n>MaterialBSSRDF</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=o>*</span><span class=n>bssrdf</span> <span class=o>=</span> <span class=n>mtl</span><span class=o>-&gt;</span><span class=n>GetBSSRDF</span><span class=p>(</span><span class=n>texEval</span><span class=p>,</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nf>BSSRDF</span><span class=p>(</span><span class=n>bssrdf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>DispatchCPU</span><span class=p>(</span><span class=n>get</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>MaterialEvalContext</code>与<code>TextureEvalContext</code>类似, 包含了求解材质的必要信息, 这些信息包含在<code>TextureEvalContext</code>中, 因此pbrt采用了继承.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MaterialEvalContext</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TextureEvalContext</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// MaterialEvalContext Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MaterialEvalContext</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>MaterialEvalContext</span><span class=p>(</span><span class=k>const</span> <span class=n>SurfaceInteraction</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>TextureEvalContext</span><span class=p>(</span><span class=n>si</span><span class=p>),</span> <span class=n>wo</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>wo</span><span class=p>),</span> <span class=n>ns</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>n</span><span class=p>),</span> <span class=n>dpdus</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Vector3f</span> <span class=n>wo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Normal3f</span> <span class=n>ns</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3f</span> <span class=n>dpdus</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>pbrt通过<code>TextureEvaluator</code>求解纹理, 而非直接调用<code>Texture::Evaluate</code>, 这使得pbrt可以在GPU上根据<code>TextureEvaluator::CanEvaluate</code>返回的信息预先判断材质是否具有重量级的纹理, 并将这两种纹理分离. 在CPU上pbrt只使用<code>UniversalTextureEvaluator</code>, 它内部直接调用<code>Evaluate</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SampledSpectrum</span> <span class=n>UniversalTextureEvaluator</span><span class=o>::</span><span class=k>operator</span><span class=p>()(</span><span class=n>SpectrumTexture</span> <span class=n>tex</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=n>TextureEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                      <span class=n>SampledWavelengths</span> <span class=n>lambda</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tex</span><span class=p>.</span><span class=n>Evaluate</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=n>lambda</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">材质实现<div id=%E6%9D%90%E8%B4%A8%E5%AE%9E%E7%8E%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%9D%90%E8%B4%A8%E5%AE%9E%E7%8E%B0 aria-label=锚点>#</a></span></h3><h4 class="relative group">漫反射材质<div id=%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8 aria-label=锚点>#</a></span></h4><p>漫反射的<code>GetBxDF</code>会将反射值限制在\([0,1]\).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>DiffuseBxDF</span> <span class=n>GetBxDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span> <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SampledSpectrum</span> <span class=n>r</span> <span class=o>=</span> <span class=n>Clamp</span><span class=p>(</span><span class=n>texEval</span><span class=p>(</span><span class=n>reflectance</span><span class=p>,</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>lambda</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>DiffuseBxDF</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 class="relative group">绝缘体材质<div id=%E7%BB%9D%E7%BC%98%E4%BD%93%E6%9D%90%E8%B4%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E7%BB%9D%E7%BC%98%E4%BD%93%E6%9D%90%E8%B4%A8 aria-label=锚点>#</a></span></h4><p><code>DielectricMaterial</code>的IOR通过光谱分布存储, 光谱渲染时会导致散射, pbrt在折射时通过<code>TerminateSecondary</code>来只保留一条光线, 除非IOR是常量.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>PBRT_CPU_GPU</span> <span class=n>DielectricBxDF</span> <span class=n>GetBxDF</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span> <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                    <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Compute index of refraction for dielectric material
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>sampledEta</span> <span class=o>=</span> <span class=n>eta</span><span class=p>(</span><span class=n>lambda</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>eta</span><span class=p>.</span><span class=k>template</span> <span class=n>Is</span><span class=o>&lt;</span><span class=n>ConstantSpectrum</span><span class=o>&gt;</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>lambda</span><span class=p>.</span><span class=n>TerminateSecondary</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle edge case in case lambda[0] is beyond the wavelengths stored by the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Spectrum.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>sampledEta</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>sampledEta</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create microfacet distribution for dielectric material
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>urough</span> <span class=o>=</span> <span class=n>texEval</span><span class=p>(</span><span class=n>uRoughness</span><span class=p>,</span> <span class=n>ctx</span><span class=p>),</span> <span class=n>vrough</span> <span class=o>=</span> <span class=n>texEval</span><span class=p>(</span><span class=n>vRoughness</span><span class=p>,</span> <span class=n>ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>remapRoughness</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>urough</span> <span class=o>=</span> <span class=n>TrowbridgeReitzDistribution</span><span class=o>::</span><span class=n>RoughnessToAlpha</span><span class=p>(</span><span class=n>urough</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>vrough</span> <span class=o>=</span> <span class=n>TrowbridgeReitzDistribution</span><span class=o>::</span><span class=n>RoughnessToAlpha</span><span class=p>(</span><span class=n>vrough</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>TrowbridgeReitzDistribution</span> <span class=nf>distrib</span><span class=p>(</span><span class=n>urough</span><span class=p>,</span> <span class=n>vrough</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Return BSDF for dielectric material
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>DielectricBxDF</span><span class=p>(</span><span class=n>sampledEta</span><span class=p>,</span> <span class=n>distrib</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 class="relative group">混合材质<div id=%E6%B7%B7%E5%90%88%E6%9D%90%E8%B4%A8 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%B7%B7%E5%90%88%E6%9D%90%E8%B4%A8 aria-label=锚点>#</a></span></h4><p>混合材质无法返回BSDF, 因此这里的混合是概率上的混合, 每次随机选取一个材质来执行材质求解.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TextureEvaluator</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Material</span> <span class=n>ChooseMaterial</span><span class=p>(</span><span class=n>TextureEvaluator</span> <span class=n>texEval</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>MaterialEvalContext</span> <span class=n>ctx</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>amt</span> <span class=o>=</span> <span class=n>texEval</span><span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=n>ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>amt</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>materials</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>amt</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=n>materials</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>u</span> <span class=o>=</span> <span class=n>HashFloat</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>p</span><span class=p>,</span> <span class=n>ctx</span><span class=p>.</span><span class=n>wo</span><span class=p>,</span> <span class=n>materials</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>materials</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>amt</span> <span class=o>&lt;</span> <span class=n>u</span><span class=p>)</span> <span class=o>?</span> <span class=n>materials</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>:</span> <span class=n>materials</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">获取表面BSDF<div id=%E8%8E%B7%E5%8F%96%E8%A1%A8%E9%9D%A2bsdf class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E8%8E%B7%E5%8F%96%E8%A1%A8%E9%9D%A2bsdf aria-label=锚点>#</a></span></h3><p>pbrt的<code>Integrator</code>通过<code>SurfaceInteraction</code>获取表面信息, 因此需要<code>SurfaceInteraction</code>返回BSDF.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>BSDF</span> <span class=n>SurfaceInteraction</span><span class=o>::</span><span class=n>GetBSDF</span><span class=p>(</span><span class=k>const</span> <span class=n>RayDifferential</span> <span class=o>&amp;</span><span class=n>ray</span><span class=p>,</span> <span class=n>SampledWavelengths</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>Camera</span> <span class=n>camera</span><span class=p>,</span> <span class=n>ScratchBuffer</span> <span class=o>&amp;</span><span class=n>scratchBuffer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>Sampler</span> <span class=n>sampler</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Estimate $(u,v)$ and position differentials at intersection point
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ComputeDifferentials</span><span class=p>(</span><span class=n>ray</span><span class=p>,</span> <span class=n>camera</span><span class=p>,</span> <span class=n>sampler</span><span class=p>.</span><span class=n>SamplesPerPixel</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Resolve _MixMaterial_ if necessary
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>material</span><span class=p>.</span><span class=n>Is</span><span class=o>&lt;</span><span class=n>MixMaterial</span><span class=o>&gt;</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>MixMaterial</span> <span class=o>*</span><span class=n>mix</span> <span class=o>=</span> <span class=n>material</span><span class=p>.</span><span class=n>Cast</span><span class=o>&lt;</span><span class=n>MixMaterial</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>material</span> <span class=o>=</span> <span class=n>mix</span><span class=o>-&gt;</span><span class=n>ChooseMaterial</span><span class=p>(</span><span class=n>UniversalTextureEvaluator</span><span class=p>(),</span> <span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Return unset _BSDF_ if surface has a null material
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>material</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Evaluate normal or bump map, if present
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FloatTexture</span> <span class=n>displacement</span> <span class=o>=</span> <span class=n>material</span><span class=p>.</span><span class=n>GetDisplacement</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Image</span> <span class=o>*</span><span class=n>normalMap</span> <span class=o>=</span> <span class=n>material</span><span class=p>.</span><span class=n>GetNormalMap</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>displacement</span> <span class=o>||</span> <span class=n>normalMap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Get shading $\dpdu$ and $\dpdv$ using normal or bump map
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Vector3f</span> <span class=n>dpdu</span><span class=p>,</span> <span class=n>dpdv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>normalMap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>NormalMap</span><span class=p>(</span><span class=o>*</span><span class=n>normalMap</span><span class=p>,</span> <span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dpdu</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dpdv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=nf>BumpMap</span><span class=p>(</span><span class=n>UniversalTextureEvaluator</span><span class=p>(),</span> <span class=n>displacement</span><span class=p>,</span> <span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dpdu</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dpdv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Normal3f</span> <span class=nf>ns</span><span class=p>(</span><span class=n>Normalize</span><span class=p>(</span><span class=n>Cross</span><span class=p>(</span><span class=n>dpdu</span><span class=p>,</span> <span class=n>dpdv</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>        <span class=n>SetShadingGeometry</span><span class=p>(</span><span class=n>ns</span><span class=p>,</span> <span class=n>dpdu</span><span class=p>,</span> <span class=n>dpdv</span><span class=p>,</span> <span class=n>shading</span><span class=p>.</span><span class=n>dndu</span><span class=p>,</span> <span class=n>shading</span><span class=p>.</span><span class=n>dndv</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Return BSDF for surface interaction
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BSDF</span> <span class=n>bsdf</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>material</span><span class=p>.</span><span class=n>GetBSDF</span><span class=p>(</span><span class=n>UniversalTextureEvaluator</span><span class=p>(),</span> <span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=n>lambda</span><span class=p>,</span> <span class=n>scratchBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bsdf</span> <span class=o>&amp;&amp;</span> <span class=n>GetOptions</span><span class=p>().</span><span class=n>forceDiffuse</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Override _bsdf_ with diffuse equivalent
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>SampledSpectrum</span> <span class=n>r</span> <span class=o>=</span> <span class=n>bsdf</span><span class=p>.</span><span class=n>rho</span><span class=p>(</span><span class=n>wo</span><span class=p>,</span> <span class=p>{</span><span class=n>sampler</span><span class=p>.</span><span class=n>Get1D</span><span class=p>()},</span> <span class=p>{</span><span class=n>sampler</span><span class=p>.</span><span class=n>Get2D</span><span class=p>()});</span>
</span></span><span class=line><span class=cl>        <span class=n>bsdf</span> <span class=o>=</span> <span class=n>BSDF</span><span class=p>(</span><span class=n>shading</span><span class=p>.</span><span class=n>n</span><span class=p>,</span> <span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span><span class=p>,</span> <span class=n>scratchBuffer</span><span class=p>.</span><span class=n>Alloc</span><span class=o>&lt;</span><span class=n>DiffuseBxDF</span><span class=o>&gt;</span><span class=p>(</span><span class=n>r</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>bsdf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 class="relative group">法线映射<div id=%E6%B3%95%E7%BA%BF%E6%98%A0%E5%B0%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E6%B3%95%E7%BA%BF%E6%98%A0%E5%B0%84 aria-label=锚点>#</a></span></h3><p>法线映射通过法线纹理实现, 纹理中存储的是切线空间下的法线, 在pbrt中即以法线为\(z\)轴, 切线为\(x\)轴. 在pbrt-v4中只有法线纹理是明确要用RGB存储的, 因此只存储在图片中, 通过<code>NormalMap</code>函数返回.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kr>inline</span> <span class=n>PBRT_CPU_GPU</span> <span class=kt>void</span> <span class=nf>NormalMap</span><span class=p>(</span><span class=k>const</span> <span class=n>Image</span> <span class=o>&amp;</span><span class=n>normalMap</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=k>const</span> <span class=n>NormalBumpEvalContext</span> <span class=o>&amp;</span><span class=n>ctx</span><span class=p>,</span> <span class=n>Vector3f</span> <span class=o>*</span><span class=n>dpdu</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=n>Vector3f</span> <span class=o>*</span><span class=n>dpdv</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get normalized normal vector from normal map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WrapMode2D</span> <span class=n>wrap</span><span class=p>(</span><span class=n>WrapMode</span><span class=o>::</span><span class=n>Repeat</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2f</span> <span class=n>uv</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>uv</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>ctx</span><span class=p>.</span><span class=n>uv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3f</span> <span class=n>ns</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>normalMap</span><span class=p>.</span><span class=n>BilerpChannel</span><span class=p>(</span><span class=n>uv</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>wrap</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=mi>2</span> <span class=o>*</span> <span class=n>normalMap</span><span class=p>.</span><span class=n>BilerpChannel</span><span class=p>(</span><span class=n>uv</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>wrap</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=mi>2</span> <span class=o>*</span> <span class=n>normalMap</span><span class=p>.</span><span class=n>BilerpChannel</span><span class=p>(</span><span class=n>uv</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>wrap</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ns</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>ns</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Transform tangent-space normal to rendering space
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Frame</span> <span class=n>frame</span> <span class=o>=</span> <span class=n>Frame</span><span class=o>::</span><span class=n>FromXZ</span><span class=p>(</span><span class=n>Normalize</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span><span class=p>),</span> <span class=n>Vector3f</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>n</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>ns</span> <span class=o>=</span> <span class=n>frame</span><span class=p>.</span><span class=n>FromLocal</span><span class=p>(</span><span class=n>ns</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Find $\dpdu$ and $\dpdv$ that give shading normal
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Float</span> <span class=n>ulen</span> <span class=o>=</span> <span class=n>Length</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span><span class=p>),</span> <span class=n>vlen</span> <span class=o>=</span> <span class=n>Length</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdv</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dpdu</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>GramSchmidt</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span><span class=p>,</span> <span class=n>ns</span><span class=p>))</span> <span class=o>*</span> <span class=n>ulen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>dpdv</span> <span class=o>=</span> <span class=n>Normalize</span><span class=p>(</span><span class=n>Cross</span><span class=p>(</span><span class=n>ns</span><span class=p>,</span> <span class=o>*</span><span class=n>dpdu</span><span class=p>))</span> <span class=o>*</span> <span class=n>vlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>NormalBumpEvalContext</code>定义如下.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>NormalBumpEvalContext</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// NormalBumpEvalContext Public Methods
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NormalBumpEvalContext</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=nf>NormalBumpEvalContext</span><span class=p>(</span><span class=k>const</span> <span class=n>SurfaceInteraction</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>p</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>p</span><span class=p>()),</span>
</span></span><span class=line><span class=cl>          <span class=n>uv</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>uv</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>n</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>n</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dudx</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dudx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dudy</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dudy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dvdx</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dvdx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dvdy</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dvdy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dpdx</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dpdx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>dpdy</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>dpdy</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=n>faceIndex</span><span class=p>(</span><span class=n>si</span><span class=p>.</span><span class=n>faceIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>shading</span><span class=p>.</span><span class=n>n</span> <span class=o>=</span> <span class=n>si</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span> <span class=o>=</span> <span class=n>si</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>shading</span><span class=p>.</span><span class=n>dpdv</span> <span class=o>=</span> <span class=n>si</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>shading</span><span class=p>.</span><span class=n>dndu</span> <span class=o>=</span> <span class=n>si</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dndu</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>shading</span><span class=p>.</span><span class=n>dndv</span> <span class=o>=</span> <span class=n>si</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dndv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ToString</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PBRT_CPU_GPU</span>
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=nf>TextureEvalContext</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>TextureEvalContext</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>dpdx</span><span class=p>,</span> <span class=n>dpdy</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>uv</span><span class=p>,</span> <span class=n>dudx</span><span class=p>,</span> <span class=n>dudy</span><span class=p>,</span> <span class=n>dvdx</span><span class=p>,</span> <span class=n>dvdy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>faceIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// NormalBumpEvalContext Public Members
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Point3f</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Point2f</span> <span class=n>uv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Normal3f</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Normal3f</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3f</span> <span class=n>dpdu</span><span class=p>,</span> <span class=n>dpdv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Normal3f</span> <span class=n>dndu</span><span class=p>,</span> <span class=n>dndv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>shading</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Float</span> <span class=n>dudx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dudy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dvdx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dvdy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3f</span> <span class=n>dpdx</span><span class=p>,</span> <span class=n>dpdy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>faceIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">视差映射<div id=%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84 aria-label=锚点>#</a></span></h3><p>视差纹理记录表面高度, 以此生成新的几何位置和法线.</p><p>$$
\begin{equation}
p&rsquo;(u,v)=p(u,v)+d(u,v)\bold{n}(u,v)
\end{equation}
$$</p><p>此时可以得到新的导数, 由于\(d(u,v)\)通常很小, 有些渲染器会省略最后一项.</p><p>$$
\begin{equation}
\frac{\partial p&rsquo;}{\partial u}=\frac{\partial p(u,v)}{\partial u}+\bold{n}(u,v)\frac{\partial d(u,v)}{\partial u}+d(u,v)\frac{\partial\bold{n}(u,v)}{\partial u}
\end{equation}
$$</p><p>\(d(u,v)\)的导数可以通过导数的定义来计算.</p><p>$$
\begin{equation}
\frac{\partial d(u,v)}{\partial u}=\lim_{\Delta_u \to 0}\frac{d(u+\Delta_u,v)-d(u,v)}{\Delta_u}
\end{equation}
$$</p><p>\(\Delta_u\)的计算方式如下, 这里考虑到了浮点精度.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Float</span> <span class=n>du</span> <span class=o>=</span> <span class=mf>.5f</span> <span class=o>*</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>abs</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>dudx</span><span class=p>)</span> <span class=o>+</span> <span class=n>std</span><span class=o>::</span><span class=n>abs</span><span class=p>(</span><span class=n>ctx</span><span class=p>.</span><span class=n>dudy</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>du</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=n>du</span> <span class=o>=</span> <span class=mf>.0005f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>shiftedCtx</span><span class=p>.</span><span class=n>p</span> <span class=o>=</span> <span class=n>ctx</span><span class=p>.</span><span class=n>p</span> <span class=o>+</span> <span class=n>du</span> <span class=o>*</span> <span class=n>ctx</span><span class=p>.</span><span class=n>shading</span><span class=p>.</span><span class=n>dpdu</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>shiftedCtx</span><span class=p>.</span><span class=n>uv</span> <span class=o>=</span> <span class=n>ctx</span><span class=p>.</span><span class=n>uv</span> <span class=o>+</span> <span class=n>Vector2f</span><span class=p>(</span><span class=n>du</span><span class=p>,</span> <span class=mf>0.f</span><span class=p>);</span>
</span></span></code></pre></div></div></div><script>var oid="views_render/pbrt-v4-episode-10/index.md",oid_likes="likes_render/pbrt-v4-episode-10/index.md"</script><script type=text/javascript src=/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q+oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/render/pbrt-v4-episode-9/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">pbrt-v4 Ep. IX: 反射模型</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2024-12-10T00:00:00+00:00>2024 December 10</time>
</span></span></a></span><span><a class="flex text-right group ml-3" href=/render/pbrt-v4-episode-11/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">pbrt-v4 Ep. XI: 体散射</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2024-12-27T00:00:00+00:00>2024 December 27</time>
</span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div><div class=pt-3><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class=pt-3><script src=https://giscus.app/client.js data-repo=tsssni/tsssni.github.io data-repo-id=R_kgDOMEzJ_g data-category=Announcements data-category-id=DIC_kwDOMEzJ_s4CgBEJ data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=返回顶部 title=返回顶部>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href title></a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2026</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://tsssni.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>