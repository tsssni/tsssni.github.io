[{"content":"","date":"2025 August 6","externalUrl":null,"permalink":"/tags/graphics/","section":"Tags","summary":"","title":"Graphics","type":"tags"},{"content":"","date":"2025 August 6","externalUrl":null,"permalink":"/tags/metatron/","section":"Tags","summary":"","title":"Metatron","type":"tags"},{"content":"利用EnTT和Glaze构建了一套场景管理系统.\nECS # metatron的ecs系统中, entity/component由entt管理, system则需要实现ecs::Daemon接口.\necs::Hierarchy用于维护世界树, 树节点采用Unix路径命名并分配对应的ecs::Entity. hierarchy会包含多个ecs::Stage, stage中则包含多个ecs::Daemon, stage会按序更新, 但内部的daemon可能会由于多线程不能保证有序, 若需有序需位于不同的stage.\n// ... resource_stage-\u0026gt;daemons = { \u0026amp;transform_daemon, \u0026amp;shape_daemon, \u0026amp;medium_daemon, \u0026amp;texture_daemon, }; // ... hierarchy.stages = { spectrum_stage.get(), resource_stage.get(), material_stage.get(), camera_stage.get(), render_stage.get(), }; 各个daemon会有init与update接口, init用于提前挂载预定义的components(例如金属的IOR光谱)以及注册serde, update则执行前述的更新操作, 负载重的任务可通过stl::scheduler实现多线程.\nstruct Daemon final: pro::facade_builder ::add_convention\u0026lt;daemon_init, auto () noexcept -\u0026gt; void\u0026gt; ::add_convention\u0026lt;daemon_update, auto () noexcept -\u0026gt; void\u0026gt; ::add_skill\u0026lt;pro::skills::as_view\u0026gt; ::build {}; entt不会记录component是否被修改, metatron通过在世界树节点上挂载额外的ecs::Dirty_Mark\u0026lt;T\u0026gt;实现, 各个daemon更新完毕后需要清除.\ntemplate\u0026lt;typename T\u0026gt; auto attach(Entity entity, T\u0026amp;\u0026amp; component = {}) noexcept -\u0026gt; void { registry.emplace\u0026lt;Dirty_Mark\u0026lt;T\u0026gt;\u0026gt;(entity); registry.emplace\u0026lt;T\u0026gt;(entity, std::forward\u0026lt;T\u0026gt;(component)); } 当前活跃的hierarchy可以通过global static ecs::Hierarchy::instance访问, 执行activate()来修改instance. 这主要用于方便entity与路径的转换, 例如可以通过字面量_et执行转换.\nnamespace mtt::ecs { auto to_path(Entity entity) -\u0026gt; std::string { return Hierarchy::instance-\u0026gt;path(entity); } auto to_entity(std::string const\u0026amp; path) -\u0026gt; Entity { return Hierarchy::instance-\u0026gt;create(path); } } namespace mtt { auto operator\u0026#34;\u0026#34; _et(view\u0026lt;char\u0026gt; path, usize size) -\u0026gt; ecs::Entity { return ecs::to_entity(path); } } SERDE # Glaze库通过调用编译器的internal函数实现反射功能, 对于aggregate的反射无需手动注册, 对部分容器也有支持, 在c++26的静态反射实装前是很好用的替代品.\n对于ecs::Entity, 我们通过全局的ecs::Hierarchy::instance调用ecs::to_path与ecs::to_entity即可. 对于metatron中最基础的math::Matrix类型, 注册为反射内部实际存储数据的std::array\u0026lt;Element, first_dim\u0026gt;, Glaze会处理Element的递归. math::Quaternion的反射同理. 除这三个类型外别的都可以交给Glaze处理.\ntemplate\u0026lt;typename T, mtt::usize first_dim, mtt::usize... rest_dims\u0026gt; struct from\u0026lt;JSON, mtt::math::Matrix\u0026lt;T, first_dim, rest_dims...\u0026gt;\u0026gt; { template\u0026lt;auto Opts\u0026gt; auto static op(mtt::math::Matrix\u0026lt;T, first_dim, rest_dims...\u0026gt;\u0026amp; v, auto\u0026amp;\u0026amp;... args) noexcept -\u0026gt; void { using M = mtt::math::Matrix\u0026lt;T, first_dim, rest_dims...\u0026gt;; using E = M::Element; auto data = std::array\u0026lt;E, first_dim\u0026gt;{}; parse\u0026lt;JSON\u0026gt;::op\u0026lt;Opts\u0026gt;(data, args...); v = M{std::span\u0026lt;E const\u0026gt;{data}}; } }; template\u0026lt;typename T, mtt::usize first_dim, mtt::usize... rest_dims\u0026gt; struct to\u0026lt;JSON, mtt::math::Matrix\u0026lt;T, first_dim, rest_dims...\u0026gt;\u0026gt; { template\u0026lt;auto Opts\u0026gt; auto static op(mtt::math::Matrix\u0026lt;T, first_dim, rest_dims...\u0026gt; const\u0026amp; v, auto\u0026amp;\u0026amp;... args) noexcept -\u0026gt; void { using E = mtt::math::Matrix\u0026lt;T, first_dim, rest_dims...\u0026gt;::Element; auto const\u0026amp; data = std::array\u0026lt;E, first_dim\u0026gt;(v); serialize\u0026lt;JSON\u0026gt;::op\u0026lt;Opts\u0026gt;(data, args...); } }; 对于enum, Glaze需要手动注册才能反射出各项名称, 如果后续添加c++26支持的话理论上是不需要的, 或者说实现类似magic_enum的功能, 两种方法都会方便很多.\ntemplate\u0026lt;\u0026gt; struct glz::meta\u0026lt;mtt::color::Color_Space::Spectrum_Type\u0026gt; { using enum mtt::color::Color_Space::Spectrum_Type; auto constexpr static value = glz::enumerate( albedo, unbounded, illuminant ); }; 对于需要多态的components, 例如不同的光源, metatron通过std::variant实现, 避免同时存储各个子component的数据. 每个子component最后的i32用于Glaze序列化时标记, 否则需要为所有类型手动注册glz::meta::value, 并为std::variant\u0026lt;Ts...\u0026gt;注册glz::meta::tag与glz::meta::ids.\nstruct Parallel_Light final { ecs::Entity spectrum; i32 parallel{0}; }; struct Point_Light final { ecs::Entity spectrum; i32 point{0}; }; struct Spot_Light final { ecs::Entity spectrum; f32 falloff_start_theta; f32 falloff_end_theta; i32 spot{0}; }; struct Environment_Light final { ecs::Entity env_map; i32 environment{0}; }; using Light = std::variant\u0026lt; Parallel_Light, Point_Light, Spot_Light, Environment_Light \u0026gt;; 需要注意的是对于多重std::variant(std::variant\u0026lt;std::variant\u0026lt;Ts...\u0026gt;, std::varaint\u0026lt;Us...\u0026gt;\u0026gt;)Glaze是无法正确反序列化的, 原本metatron中有这种写法, 因为texture需要分为spectrum_texture与vector_texture, 后面还是展开到单个std::variant中, 通过实现stl::is_variant_alternative判断是否位于原本的内部std::variant中, 不再走std::visit来判断.\ntemplate\u0026lt;typename T, typename Variant\u0026gt; struct is_variant_alternative : std::false_type {}; template\u0026lt;typename T, typename... Types\u0026gt; struct is_variant_alternative\u0026lt;T, std::variant\u0026lt;Types...\u0026gt;\u0026gt; : std::disjunction\u0026lt;std::is_same\u0026lt;T, Types\u0026gt;...\u0026gt; {}; template\u0026lt;typename T, typename Variant\u0026gt; auto constexpr is_variant_alternative_v = is_variant_alternative\u0026lt;T, Variant\u0026gt;::value; json序列化结构如下, 每个daemon会注册处理序列化与反序列化的函数, 通过type索引到对应的std::function.\n{ \u0026#34;entity\u0026#34;: \u0026#34;/divider/cloud\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;divider\u0026#34;, \u0026#34;serialized\u0026#34;: { \u0026#34;shape\u0026#34;: \u0026#34;/hierarchy/shape/bound\u0026#34;, \u0026#34;medium\u0026#34;: \u0026#34;/hierarchy/medium/cloud\u0026#34;, \u0026#34;material\u0026#34;: \u0026#34;/material/cloud\u0026#34; } } 注册的函数在ecs::Hierarchy中通过模板实现, 各个daemon提供类型即可, 类型名会通过宏MTT_SERDE(T)获取.\ntemplate\u0026lt;typename T\u0026gt; auto static serde(std::string const\u0026amp; type) noexcept -\u0026gt; void { auto sanitized_type = type; std::ranges::transform( sanitized_type, sanitized_type.begin(), ::tolower ); auto fr = [](ecs::Entity e, glz::raw_json const\u0026amp; s) -\u0026gt; void { auto d = T{}; if (auto er = glz::read_json\u0026lt;T\u0026gt;(d, s.str); er) { std::println(\u0026#34;desrialize {} with glaze error: {}\u0026#34;, s.str, glz::format_error(er)); std::abort(); } else { ecs::Hierarchy::instance-\u0026gt;attach(e, std::move(d)); } }; auto fw = [sanitized_type]() -\u0026gt; std::vector\u0026lt;serde::json\u0026gt; { auto v = std::vector\u0026lt;serde::json\u0026gt;{}; auto\u0026amp; r = ecs::Hierarchy::instance-\u0026gt;registry; for (auto e: r.view\u0026lt;T\u0026gt;()) { auto s = glz::write_json(r.get\u0026lt;T\u0026gt;(e)); if (!s) { std::println( \u0026#34;failed to serialize component {} on {}\u0026#34;, sanitized_type, ecs::Hierarchy::instance-\u0026gt;path(e) ); std::abort(); } v.emplace_back(e, sanitized_type, s.value()); } return v; }; ecs::Hierarchy::instance-\u0026gt;enable(sanitized_type, fr, fw); } ","date":"2025 August 6","externalUrl":null,"permalink":"/render/1754466886159-metatron-dev-6/","section":"Rendering","summary":"","title":"Metatron Dev. VI: ecs \u0026 serde","type":"render"},{"content":"","date":"2025 August 6","externalUrl":null,"permalink":"/render/","section":"Rendering","summary":"","title":"Rendering","type":"render"},{"content":"","date":"2025 August 6","externalUrl":null,"permalink":"/tags/rendering/","section":"Tags","summary":"","title":"Rendering","type":"tags"},{"content":"","date":"2025 August 6","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025 August 6","externalUrl":null,"permalink":"/","section":"tsssni's blowfish blog","summary":"","title":"tsssni's blowfish blog","type":"page"},{"content":"尝试在项目里用上proxy的多态, 目前版本为master上未发布的4.0.0, 用官方的example研究一下源码与compiler explorer里的预处理展开结果, 内容会参考C++ proxy库的多态是怎么实现的.\n#include \u0026#34;proxy.h\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; PRO_DEF_MEM_DISPATCH(MemDraw, Draw); PRO_DEF_MEM_DISPATCH(MemArea, Area); struct Drawable : pro::facade_builder ::add_convention\u0026lt;MemDraw, void(std::ostream\u0026amp; output)\u0026gt; ::add_convention\u0026lt;MemArea, double() noexcept\u0026gt; ::support_copy\u0026lt;pro::constraint_level::nontrivial\u0026gt; ::build {}; class Rectangle { public: Rectangle(double width, double height) : width_(width), height_(height) {} Rectangle(const Rectangle\u0026amp;) = default; void Draw(std::ostream\u0026amp; out) const { out \u0026lt;\u0026lt; \u0026#34;{Rectangle: width = \u0026#34; \u0026lt;\u0026lt; width_ \u0026lt;\u0026lt; \u0026#34;, height = \u0026#34; \u0026lt;\u0026lt; height_ \u0026lt;\u0026lt; \u0026#34;}\u0026#34;; } double Area() const noexcept { return width_ * height_; } private: double width_; double height_; }; std::string PrintDrawableToString(pro::proxy\u0026lt;Drawable\u0026gt; p) { std::stringstream result; result \u0026lt;\u0026lt; \u0026#34;entity = \u0026#34;; p-\u0026gt;Draw(result); result \u0026lt;\u0026lt; \u0026#34;, area = \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;Area(); return std::move(result).str(); } int main() { pro::proxy\u0026lt;Drawable\u0026gt; p = pro::make_proxy\u0026lt;Drawable, Rectangle\u0026gt;(3, 5); std::string str = PrintDrawableToString(p); std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints \u0026#34;entity = {Rectangle: width = 3, height = 5}, area = 15\u0026#34; } abbr. # F：facade （鸭子类型约束） D：dispatch （成员函数调用器） Os： overloads （各类重载的函数签名） C/Cs： convention （成员函数meta) R/Rs： return/reflection A/As：accessor Q： qualifier （enum标记） NE：noexcept (bool标记) P: proxied (proxy接管的对象) macro # 展开PRO_DEF_MEM_DISPATCH(MemDraw, Draw)的结果如下.\nstruct MemDraw { template \u0026lt;class __T, class... __Args\u0026gt; decltype(auto) operator()(__T \u0026amp;\u0026amp;__self, __Args \u0026amp;\u0026amp;...__args) const noexcept(noexcept(::std::forward\u0026lt;__T\u0026gt;(__self).Draw( ::std::forward\u0026lt;__Args\u0026gt;(__args)...))) requires(requires { ::std::forward\u0026lt;__T\u0026gt;(__self).Draw(::std::forward\u0026lt;__Args\u0026gt;(__args)...); }) { return ::std::forward\u0026lt;__T\u0026gt;(__self).Draw( ::std::forward\u0026lt;__Args\u0026gt;(__args)...); } template \u0026lt;class __F, bool __IsDirect, class __D, class... __Os\u0026gt; struct accessor { accessor() = delete; }; template \u0026lt;class __F, bool __IsDirect, class __D, class... __Os\u0026gt; requires( sizeof...(__Os) \u0026gt; 1u \u0026amp;\u0026amp; (::std::is_constructible_v\u0026lt;accessor\u0026lt;__F, __IsDirect, __D, __Os\u0026gt;\u0026gt; \u0026amp;\u0026amp; ...)) struct accessor\u0026lt;__F, __IsDirect, __D, __Os...\u0026gt; : accessor\u0026lt;__F, __IsDirect, __D, __Os\u0026gt;... { using accessor\u0026lt;__F, __IsDirect, __D, __Os\u0026gt;::Draw...; }; template \u0026lt;class __F, bool __IsDirect, class __D, class __R, class... __Args\u0026gt; struct accessor\u0026lt;__F, __IsDirect, __D, __R(__Args...)\u0026gt; { accessor() noexcept { ::std::ignore = \u0026amp;accessor::Draw; } __R Draw(__Args... __args) { return ::pro::proxy_invoke\u0026lt;__IsDirect, __D, __R(__Args...)\u0026gt;( ::pro::access_proxy\u0026lt;__F\u0026gt;(*this), ::std::forward\u0026lt;__Args\u0026gt;(__args)...); } }; template \u0026lt;class __F, bool __IsDirect, class __D, class __R, class... __Args\u0026gt; struct accessor\u0026lt;__F, __IsDirect, __D, __R(__Args...) noexcept\u0026gt; { accessor() noexcept { ::std::ignore = \u0026amp;accessor::Draw; } __R Draw(__Args... __args) noexcept { return ::pro::proxy_invoke\u0026lt;__IsDirect, __D, __R(__Args...) noexcept\u0026gt;( ::pro::access_proxy\u0026lt;__F\u0026gt;(*this), ::std::forward\u0026lt;__Args\u0026gt;(__args)...); } }; // ... }; 先解读一下这里的部分c++语法.\ndecltype(auto): 用于保留返回值的ref type与cv qualifier. noexcept(noexcept(\u0026hellip;)): 内部为noexcept operator, 用于判断表达式是否为noexcept的 外部为noexcept specifier, 用于判断括号内是否为true requires(requires(\u0026hellip;)): 内部为requires expression, 检查表达式是否有效, 可以通过requires(args...){}传入参数后再执行判断 外部为requires clauses, 用于限制模板参数, 判断括号内是否为true. 此时operator()的限制条件就很清晰了: 只在调用的函数为noexcept时开启noexcept, 限制__T必须含有Draw(__args...)函数.\nproxy为ref, const与noexcept的每种组合情况生成一种accessor, 用于调用实际对象的Draw.\nfacade # facade意为虚伪的表面, 在proxy里用于声明鸭子类型, 通过facade_builder实现.\ntemplate \u0026lt;class Cs, class Rs, proxiable_ptr_constraints C\u0026gt; struct basic_facade_builder { template \u0026lt;class D, details::extended_overload... Os\u0026gt; requires(sizeof...(Os) \u0026gt; 0u) using add_indirect_convention = basic_facade_builder\u0026lt; details::add_conv_t\u0026lt;Cs, details::conv_impl\u0026lt;false, D, Os...\u0026gt;\u0026gt;, Rs, C\u0026gt;; template \u0026lt;class D, details::extended_overload... Os\u0026gt; requires(sizeof...(Os) \u0026gt; 0u) using add_direct_convention = basic_facade_builder\u0026lt; details::add_conv_t\u0026lt;Cs, details::conv_impl\u0026lt;true, D, Os...\u0026gt;\u0026gt;, Rs, C\u0026gt;; template \u0026lt;class D, details::extended_overload... Os\u0026gt; requires(sizeof...(Os) \u0026gt; 0u) using add_convention = add_indirect_convention\u0026lt;D, Os...\u0026gt;; // ... using build = details::facade_impl\u0026lt;Cs, Rs, details::normalize(C)\u0026gt;; basic_facade_builder() = delete; }; facade_builder会不断递归调用自己来收集函数签名, 最终调用build结束收集, 存储convention与reflection.\ntemplate \u0026lt;class Cs, class Rs, proxiable_ptr_constraints C\u0026gt; struct facade_impl { using convention_types = Cs; using reflection_types = Rs; static constexpr proxiable_ptr_constraints constraints = C; }; convention # conv_impl负责构建convention, D为macro生成的dispatcher, Os为该函数各类重载的函数签名.\ntemplate \u0026lt;bool IsDirect, class D, class... Os\u0026gt; struct conv_impl { static constexpr bool is_direct = IsDirect; using dispatch_type = D; using overload_types = std::tuple\u0026lt;Os...\u0026gt;; template \u0026lt;class F\u0026gt; using accessor = instantiated_accessor_t\u0026lt;D, F, IsDirect, substituted_overload_t\u0026lt;Os, F\u0026gt;...\u0026gt;; }; accessor为从macro生成的dispatcher中根据限定符获取的accessor, instantiated_accessor_t会调用macro生成的dispatcher中的第二个accessor类, 它会继承所有重载. 注意到上文的dispatcher中using了多个同名方法, 在c++中引入不同重载到命名空间中是合法的, 不会造成歧义.\ntemplate \u0026lt;class SFINAE, class T, class F, bool IsDirect, class... Args\u0026gt; struct accessor_instantiation_traits : std::type_identity\u0026lt;void\u0026gt; {}; template \u0026lt;class T, class F, bool IsDirect, class... Args\u0026gt; struct accessor_instantiation_traits\u0026lt; std::void_t\u0026lt;typename T::template accessor\u0026lt;F, IsDirect, T, Args...\u0026gt;\u0026gt;, T, F, IsDirect, Args...\u0026gt; : std::type_identity\u0026lt; typename T::template accessor\u0026lt;F, IsDirect, T, Args...\u0026gt;\u0026gt; {}; template \u0026lt;class T, class F, bool IsDirect, class... Args\u0026gt; using instantiated_accessor_t = typename accessor_instantiation_traits\u0026lt;void, T, F, IsDirect, Args...\u0026gt;::type; proxy # proxy负责根据facade构建派生类.\ntemplate \u0026lt;facade F\u0026gt; class proxy : public details::facade_traits\u0026lt;F\u0026gt;::direct_accessor, public details::inplace_ptr\u0026lt;proxy_indirect_accessor\u0026lt;F\u0026gt;\u0026gt; { // ... } proxy中的ptr_为一个分配了足够空间的数组, 构造proxy时会在数组上构造实际对象, 例如pro::make_proxy\u0026lt;Drawable, Rectangle\u0026gt;(3, 5)初始化过程如下, 使用std::construct_at构造.\ntemplate \u0026lt;class P, class... Args\u0026gt; constexpr P\u0026amp; initialize(Args\u0026amp;\u0026amp;... args) { PRO4D_DEBUG(std::ignore = \u0026amp;_symbol_guard;) P\u0026amp; result = *std::construct_at(reinterpret_cast\u0026lt;P*\u0026gt;(ptr_), std::forward\u0026lt;Args\u0026gt;(args)...); if constexpr (proxiable\u0026lt;P, F\u0026gt;) { meta_ = details::meta_ptr\u0026lt;typename _Traits::meta\u0026gt;{std::in_place_type\u0026lt;P\u0026gt;}; } else { _Traits::template diagnose_proxiable\u0026lt;P\u0026gt;(); } return result; } facade_traits展开所有convention与reflection, facade_conv_traits_impl收集所有conv_impl中的accessor.\nstruct facade_traits\u0026lt;F\u0026gt; : instantiated_t\u0026lt;facade_conv_traits_impl, typename F::convention_types, F\u0026gt;, instantiated_t\u0026lt;facade_refl_traits_impl, typename F::reflection_types, F\u0026gt; { // ... using indirect_accessor = merged_composite_accessor\u0026lt;typename facade_traits::conv_indirect_accessor, typename facade_traits::refl_indirect_accessor\u0026gt;; // ... } facade_conv_traits_impl最终会生成composite_accessor_impl, 它通过继承合并所有convention中的accessor, 且这些accessor都已传入conv_impl中accessor的F参数, 即当前facade.\ntemplate \u0026lt;class... As\u0026gt; class PRO4D_ENFORCE_EBO composite_accessor_impl : public As... { template \u0026lt;facade\u0026gt; friend class pro::v4::proxy; template \u0026lt;facade\u0026gt; friend struct pro::v4::proxy_indirect_accessor; composite_accessor_impl() noexcept = default; composite_accessor_impl(const composite_accessor_impl\u0026amp;) noexcept = default; composite_accessor_impl\u0026amp; operator=(const composite_accessor_impl\u0026amp;) noexcept = default; }; inplace_ptr传入合并后的accessor类型后, 即可通过指针或引用调用T中所有using的函数.\ntemplate \u0026lt;class T\u0026gt; class inplace_ptr { public: template \u0026lt;class... Args\u0026gt; explicit inplace_ptr(std::in_place_t, Args\u0026amp;\u0026amp;... args) : value_(std::forward\u0026lt;Args\u0026gt;(args)...) {} inplace_ptr() = default; inplace_ptr(const inplace_ptr\u0026amp;) = default; inplace_ptr(inplace_ptr\u0026amp;\u0026amp;) = default; inplace_ptr\u0026amp; operator=(const inplace_ptr\u0026amp;) = default; inplace_ptr\u0026amp; operator=(inplace_ptr\u0026amp;\u0026amp;) = default; T* operator-\u0026gt;() noexcept { return std::addressof(value_); } const T* operator-\u0026gt;() const noexcept { return std::addressof(value_); } T\u0026amp; operator*() \u0026amp; noexcept { return value_; } const T\u0026amp; operator*() const\u0026amp; noexcept { return value_; } T\u0026amp;\u0026amp; operator*() \u0026amp;\u0026amp; noexcept { return std::move(value_); } const T\u0026amp;\u0026amp; operator*() const\u0026amp;\u0026amp; noexcept { return std::move(value_); } private: [[PROD_NO_UNIQUE_ADDRESS_ATTRIBUTE]] T value_; }; 此时已经可以调用底层对象的函数, 例如Draw, 通过上文可以看出proxy_invoke会执行调用过程, 它最终展开到invoke_impl中调用meta存储的dispatcher.\ntemplate \u0026lt;class F, bool IsDirect, class D, class O, class P, class... Args\u0026gt; decltype(auto) invoke_impl(P\u0026amp;\u0026amp; p, Args\u0026amp;\u0026amp;... args) { auto dispatcher = proxy_helper\u0026lt;F\u0026gt;::get_meta(p) .template invocation_meta\u0026lt;F, IsDirect, D, O\u0026gt;::dispatcher; return dispatcher(std::forward\u0026lt;P\u0026gt;(p), std::forward\u0026lt;Args\u0026gt;(args)...); } 对于convention, meta存储的dispatcher展开后为conv_dispatcher, 它将self内部的指针转为P类型, 在invoke_dispatch中调用macro生成的accessor. conv_dispatch会以函数指针的形式存储在meta中, 实现运行时多态.\ntemplate \u0026lt;class D, class R, class... Args\u0026gt; R invoke_dispatch(Args\u0026amp;\u0026amp;... args) { if constexpr (std::is_void_v\u0026lt;R\u0026gt;) { D{}(std::forward\u0026lt;Args\u0026gt;(args)...); } else { return D{}(std::forward\u0026lt;Args\u0026gt;(args)...); } } template \u0026lt;bool IsDirect, class P\u0026gt; decltype(auto) get_operand(P\u0026amp;\u0026amp; ptr) { if constexpr (IsDirect) { return std::forward\u0026lt;P\u0026gt;(ptr); } else { if constexpr (std::is_constructible_v\u0026lt;bool, P\u0026amp;\u0026gt;) { assert(ptr); } return *std::forward\u0026lt;P\u0026gt;(ptr); } } template \u0026lt;class F, bool IsDirect, class D, class P, qualifier_type Q, class R, class... Args\u0026gt; R conv_dispatcher(add_qualifier_t\u0026lt;proxy\u0026lt;F\u0026gt;, Q\u0026gt; self, Args... args) noexcept( invocable_dispatch_ptr\u0026lt;IsDirect, D, P, Q, true, R, Args...\u0026gt;) { if constexpr (Q == qualifier_type::rv) { proxy_resetting_guard\u0026lt;F, P\u0026gt; guard{self}; return invoke_dispatch\u0026lt;D, R\u0026gt;( get_operand\u0026lt;IsDirect\u0026gt;( proxy_helper\u0026lt;F\u0026gt;::template get_ptr\u0026lt;P, Q\u0026gt;(std::move(self))), std::forward\u0026lt;Args\u0026gt;(args)...); } else { return invoke_dispatch\u0026lt;D, R\u0026gt;( get_operand\u0026lt;IsDirect\u0026gt;(proxy_helper\u0026lt;F\u0026gt;::template get_ptr\u0026lt;P, Q\u0026gt;( std::forward\u0026lt;add_qualifier_t\u0026lt;proxy\u0026lt;F\u0026gt;, Q\u0026gt;\u0026gt;(self))), std::forward\u0026lt;Args\u0026gt;(args)...); } } direct # add_direct_convention定义接口类型中该类型本身的函数, 可以直接调用, 而非间接调用底层实际对象的函数.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;proxy/proxy.h\u0026gt; PRO_DEF_FREE_DISPATCH(FreeToString, std::to_string, ToString); struct BasicStringable : pro::facade_builder // ::add_convention\u0026lt;FreeToString, std::string() const\u0026gt; // ::build {}; struct Stringable : pro::facade_builder // ::add_facade\u0026lt;BasicStringable\u0026gt; // ::support_copy\u0026lt;pro::constraint_level::nontrivial\u0026gt; // ::add_direct_convention\u0026lt;pro::conversion_dispatch, pro::proxy\u0026lt;BasicStringable\u0026gt;() \u0026amp;\u0026amp;\u0026gt; // ::build {}; int main() { pro::proxy\u0026lt;Stringable\u0026gt; p1 = std::make_shared\u0026lt;int\u0026gt;(123); pro::proxy\u0026lt;Stringable\u0026gt; p2 = p1; pro::proxy\u0026lt;BasicStringable\u0026gt; p3 = static_cast\u0026lt;pro::proxy\u0026lt;BasicStringable\u0026gt;\u0026gt;(std::move(p2)); pro::proxy\u0026lt;BasicStringable\u0026gt; p4 = std::move(p3); // pro::proxy\u0026lt;BasicStringable\u0026gt; p5 = p4; // Won\u0026#39;t compile std::cout \u0026lt;\u0026lt; ToString(*p4) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints \u0026#34;123\u0026#34; std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; p3.has_value() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints \u0026#34;false\u0026#34; } reflection # 将类型传入用户自定义的reflector收集类型信息并支持运行时获取, 并非相对复杂的反射实现.\n#include \u0026lt;array\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;proxy/proxy.h\u0026gt; struct LayoutReflector { public: template \u0026lt;class T\u0026gt; constexpr explicit LayoutReflector(std::in_place_type_t\u0026lt;T\u0026gt;) : Size(sizeof(T)), Align(alignof(T)) {} template \u0026lt;class F, bool IsDirect, class R\u0026gt; struct accessor { friend std::size_t SizeOf(const std::conditional_t\u0026lt;IsDirect, pro::proxy\u0026lt;F\u0026gt;, pro::proxy_indirect_accessor\u0026lt;F\u0026gt;\u0026gt;\u0026amp; self) noexcept { const LayoutReflector\u0026amp; refl = pro::proxy_reflect\u0026lt;IsDirect, R\u0026gt;(pro::access_proxy\u0026lt;F\u0026gt;(self)); return refl.Size; } friend std::size_t AlignOf(const std::conditional_t\u0026lt;IsDirect, pro::proxy\u0026lt;F\u0026gt;, pro::proxy_indirect_accessor\u0026lt;F\u0026gt;\u0026gt;\u0026amp; self) noexcept { const LayoutReflector\u0026amp; refl = pro::proxy_reflect\u0026lt;IsDirect, R\u0026gt;(pro::access_proxy\u0026lt;F\u0026gt;(self)); return refl.Align; } }; std::size_t Size, Align; }; struct LayoutAware : pro::facade_builder // ::add_direct_reflection\u0026lt;LayoutReflector\u0026gt; // ::add_indirect_reflection\u0026lt;LayoutReflector\u0026gt; // ::build {}; int main() { int a = 123; pro::proxy\u0026lt;LayoutAware\u0026gt; p = \u0026amp;a; std::cout \u0026lt;\u0026lt; SizeOf(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints sizeof(raw pointer) std::cout \u0026lt;\u0026lt; AlignOf(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints alignof(raw pointer) std::cout \u0026lt;\u0026lt; SizeOf(*p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints sizeof(int) std::cout \u0026lt;\u0026lt; AlignOf(*p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints alignof(int) p = pro::make_proxy\u0026lt;LayoutAware\u0026gt;(123); // SBO enabled std::cout \u0026lt;\u0026lt; SizeOf(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints sizeof(int) std::cout \u0026lt;\u0026lt; AlignOf(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints alignof(int) std::cout \u0026lt;\u0026lt; SizeOf(*p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints sizeof(int) std::cout \u0026lt;\u0026lt; AlignOf(*p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints alignof(int) p = pro::make_proxy\u0026lt;LayoutAware, std::array\u0026lt;char, 100\u0026gt;\u0026gt;(); // SBO disabled std::cout \u0026lt;\u0026lt; SizeOf(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints sizeof(raw pointer) std::cout \u0026lt;\u0026lt; AlignOf(p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints alignof(raw pointer) std::cout \u0026lt;\u0026lt; SizeOf(*p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints \u0026#34;100\u0026#34; std::cout \u0026lt;\u0026lt; AlignOf(*p) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // Prints \u0026#34;1\u0026#34; } conclusion # 与c++虚函数相比proxy可总结出以下优势.\n鸭子类型, 无需继承或宏 虚表位于多态对象, 保持内存布局 抽象类可调用自由函数重载 支持传值, 有小对象优化 可约束构造函数, 析构函数 设计理念上proxy和rust等现代语言一样, 抛弃了java那套oo, 性能提升大概也来自于此.\n","date":"2025 July 6","externalUrl":null,"permalink":"/render/1751771879759-metatron-dev-5/","section":"Rendering","summary":"","title":"Metatron Dev. V: proxy","type":"render"},{"content":" 图片与部分证明来自Understanding The Math Behind ReSTIR DI\n重采样重要性抽样 # 令\\(x\\)的目标概率分布为\\(\\hat{p}(x)\\), 它可能难以被重要性抽样. 我们为每个样本选择一个容易抽样的提议分布\\(p_i(X)\\), 选出\\(M\\)个样本组成序列\\(\\bold{x}\\), 然后将每个样本的权重设置为\\(w_i(x_i)=\\frac{\\hat{p}(x_i)}{p_i(x_i)}\\), 随机选择其中一个样本\\(x_z\\), 此时概率如下.\n$$ \\begin{equation} \\begin{aligned} p(z|\\bold{x}) \u0026amp;=\\frac{w_z(x_z)}{\\sum_{i=1}^M w_i(x_i)} \\end{aligned} \\end{equation} $$\n证明采用RIS进行Monte Carlo最终可以收敛的过程如下, 其中\\(y\\)为每次RIS所选择到的样本, \\(p\u0026rsquo;\\)为RIS后被选中的概率. 可以看出\\(\\sum_{k=1,p_k(x) \\neq 0}^Mm(x)=1\\)即可无偏. 由于目标概率分布被抵消, 不要求为积分为\\(1\\), 渲染任务可选择Kajiya积分项为\\(\\hat{p}(x)\\).\n$$ \\begin{equation} \\begin{aligned} E(\\frac{1}{N}\\sum_{i=1}^N\\frac{f(y_i)}{\\hat{p}(y_i)}m(y_i)\\sum_{j=1}^Mw_j(x_{ij})) \u0026amp;=\\frac{1}{N}\\sum_{i=1}^NE(\\frac{f(y)}{\\hat{p}(y)}m(y)\\sum_{j=1}^Mw_j(x_j))\\\\ \u0026amp;=E(\\frac{f(y)}{\\hat{p}(y)}m(y)w_{\\text{sum}})\\\\ \u0026amp;=\\sum_{k=1,p_k(x_k) \\neq 0}^M\\int\\cdots\\int\\frac{f(x_k)}{\\hat{p}(x_k)}m(x_k)w_{\\text{sum}}p\u0026rsquo;(x_k)dx_1 \\cdots dx_M\\\\ \u0026amp;=\\sum_{k=1,p_k(x_k) \\neq 0}^M\\int\\cdots\\int\\frac{f(x_k)}{\\hat{p}(x_k)}m(x_k)w_{\\text{sum}}\\frac{w_k(x_k)}{w_{\\text{sum}}}\\prod_{i=1}^Mp_i(x_i)dx_1 \\cdots dx_M\\\\ \u0026amp;=\\sum_{k=1,p_k(x_k) \\neq 0}^M\\int\\cdots\\int f(x_k)m(x_k)\\prod_{i=1,i \\neq k}^Mp_i(x_i)dx_1 \\cdots dx_M\\\\ \u0026amp;=\\sum_{k=1,p_k(x_k) \\neq 0}^M\\int f(x_k)m(x_k)dx_k\\int\\cdots\\int\\underbrace{\\prod_{i=1,i \\neq k}^Mp_i(x_i)\\underbrace{dx_1 \\cdots dx_M}_{\\text{M - 1, except k}}}_{1}\\\\ \u0026amp;=\\int \\sum_{k=1,p_k(x) \\neq 0}^Mm(x)f(x)dx\\\\ \\end{aligned} \\end{equation} $$\n蓄水池抽样 # 蓄水池抽样只保留一个样本, 样本保留的概率是当前样本的权重与所有已知样本权重和的比值. 蓄水池抽样更新过程如下. 保留新样本, 概率值为\\(\\frac{w_i}{W}\\); 保留旧样本, 概率值为\\(\\frac{w_j}{W\u0026rsquo;}\\frac{W - w_i}{W}=\\frac{w_j}{W\u0026rsquo;}\\frac{W\u0026rsquo;}{W}=\\frac{w_j}{W}\\). 可见概率值一定会更新为权重与已知权重和的比值.\nReservoir s, Sample sp, Weight w s.W += w; if u \u0026lt; w / s.W then s.y = sp; 若要合并多个蓄水池, 将每个蓄水池的权重和作为合并权重, 将蓄水池本身作为样本, 对多个蓄水池执行蓄水池抽样过程即可, 此时被选中的蓄水池中的样本的概率更新为\\(\\frac{w_i}{W_j}\\frac{W_j}{\\sum_{k=1}^n W_k}=\\frac{w_i}{\\sum_{k=1}^n W_k}\\), 仍然满足要求.\n时空复用 # 假设所有样本提议分布相同, 则\\(m(y)=\\frac{1}{M}\\), 使得\\(w_{\\text{sum}}=\\hat{p}(y)WM\\), 得到有偏结果.\nReservoir s for r in {r1, ..., rk} do s.update(r.y, p_hat(r.y) * r.W * r.M) s.M = s1.M + s2.M + ... + sk.M 为实现无偏需保证\\(p_k(y) \u0026gt; 0\\), 由于相邻像素来自于重采样, \\(p_k(y)\\)是未知的, 但由重采样过程可知, \\(\\hat{p}(y)=0\\)时样本选中概率为0, 可用相邻像素的目标分布来测试\\(p_k(y) \u0026gt; 0\\), 即执行阴影测试.\nfor qi in {q1, ..., qk} do if p_hat_qi(s.y) \u0026gt; 0 then Z += ri.M m = 1 / Z ","date":"2025 May 17","externalUrl":null,"permalink":"/render/1747455314882-metatron-dev-4/","section":"Rendering","summary":"","title":"Metatron Dev. IV: ReSTIR","type":"render"},{"content":"","date":"2025 May 17","externalUrl":null,"permalink":"/tags/restir/","section":"Tags","summary":"","title":"Restir","type":"tags"},{"content":"pbrt通过RayMajorantIterator遍历体数据, 独立于体数据之外, 将体数据采样方式暴露给积分器. metatron开发时决定将采样细节封装在介质类中, 实现了math::Grid以及media::Grid_Medium以划分体素和访问体数据, 效果如下.\n体素网格 # Grid将空间在各个维度上均匀划分, 底层采用Matrix存储, 网格大小在编译期确定. operator()采用局部坐标访问网格获取实际数据, operator[]采用序号访问网格获取某种在当前体素中一致的数据, 为支持负数网格序号, 参数使用i32. bounding_box无论哪种输入, 返回的都是当前体素的包围盒, 若在包围盒外部则返回整体的包围盒.\ntemplate\u0026lt;typename T, usize x, usize y, usize z\u0026gt; struct Grid { auto static constexpr dimensions = std::array\u0026lt;usize, 3\u0026gt;{x, y, z}; virtual ~Grid() = default; auto virtual to_local(math::Vector\u0026lt;i32, 3\u0026gt; const\u0026amp; ijk) const -\u0026gt; math::Vector\u0026lt;f32, 3\u0026gt; = 0; auto virtual to_index(math::Vector\u0026lt;f32, 3\u0026gt; const\u0026amp; pos) const -\u0026gt; math::Vector\u0026lt;i32, 3\u0026gt; = 0; auto virtual bounding_box() const -\u0026gt; math::Bounding_Box = 0; auto virtual bounding_box(math::Vector\u0026lt;f32, 3\u0026gt; const\u0026amp; pos) const -\u0026gt; math::Bounding_Box = 0; auto virtual bounding_box(math::Vector\u0026lt;i32, 3\u0026gt; const\u0026amp; ijk) const -\u0026gt; math::Bounding_Box = 0; auto virtual operator()(math::Vector\u0026lt;f32, 3\u0026gt; const\u0026amp; pos) const -\u0026gt; T = 0; auto virtual operator[](math::Vector\u0026lt;i32, 3\u0026gt; const\u0026amp; ijk) -\u0026gt; T\u0026amp; = 0; auto virtual operator[](math::Vector\u0026lt;i32, 3\u0026gt; const\u0026amp; ijk) const -\u0026gt; T const\u0026amp; = 0; }; Nanovdb_Grid读取nanovdb格式的体数据, 并使用Uniform_Grid建立主值网格, 将nanovdb的包围盒均匀划分, 读取内部所有体素取最大值. Uniform_Grid是Grid最基础的实现, 采用局部坐标或序号访问的结果是相同的, 而Nanovdb_Grid采用局部坐标获取实际数据, 序号获取主值. pbrt构造主值网格时会将体素包围盒向外扩展一个单位, 构建更loose的网格, 这里暂时不太清楚原因, 因此未采用.\nNanovdb_Grid(std::string_view path): /* ... */ { // ... for (auto i = pmin[0]; i \u0026lt;= pmax[0]; i++) { for (auto j = pmin[1]; j \u0026lt;= pmax[1]; j++) { for (auto k = pmin[2]; k \u0026lt;= pmax[2]; k++) { majorant_grid[ijk] = std::max(majorant_grid[ijk], accessor.getValue({i, j, k})); } } } } 由于需要主值, 在构造函数中就已经通过让sampler访问包围盒之外以获取背景值了, 通过序号访问时判断是否位于包围盒内部即可.\nauto virtual operator()(math::Vector\u0026lt;f32, 3\u0026gt; const\u0026amp; pos) const -\u0026gt; T { return sampler(nanovdb_grid-\u0026gt;worldToIndex(to_nanovdb(pos))); } auto virtual operator[](math::Vector\u0026lt;i32, 3\u0026gt; const\u0026amp; ijk) -\u0026gt; T\u0026amp; { if (ijk == clamp(ijk, math::Vector\u0026lt;i32, 3\u0026gt;{0}, math::Vector\u0026lt;i32, 3\u0026gt;{x - 1, y - 1, z - 1})) { return majorant_grid[ijk]; } else { return background; } } 网格介质 # 采样过程在Grid_Medium::sample中实现, 由于delta tracking的特性, 采样时没有超过体素边界才会返回, 否则光线继续追踪.\nGrid_Medium内部会保存一份cache, 如果积分器采样到空散射事件, 由于光线按原路径传播, 直接读取缓存继续采样过程. 缓存是thread_local的, 否则不同像素并发发射的光线对缓存的读取会冲突.\nstruct Cache final { math::Ray r{ {math::maxv\u0026lt;f32\u0026gt;}, {0.f} }; math::Bounding_Box bbox{}; f32 t_max{-1.f}; f32 density_maj{0.f}; spectra::Stochastic_Spectrum sigma_maj{}; math::Exponential_Distribution distr{0.f}; }; std::unordered_map\u0026lt;Grid_Medium const*, Grid_Medium::Cache\u0026gt; thread_local Grid_Medium::thread_caches; 透射率按如下方式更新, t_transmitted用于返回实际追踪距离, t_boundary用于记录与几何交点的距离.\nauto update_transmittance = [\u0026amp;](f32 t) -\u0026gt; void { t_transmitted += t; t_boundary -= t; cache.t_max -= t; cache.r.o += t * cache.r.d; for (auto i = 0uz; i \u0026lt; transmittance.lambda.size(); i++) { transmittance.value[i] *= std::exp(-cache.sigma_maj.value[i] * t); } }; 穿过体素后主值更新方式如下, 如果不与包围盒相交代表位于整个网格外部, 此时t_max设置为与几何物体的相交点. 由于需要主值这里使用operator[]访问网格.\nauto update_majorant = [\u0026amp;](f32 t_max) -\u0026gt; void { cache.bbox = grid-\u0026gt;bounding_box(cache.r.o); cache.t_max = math::hit(cache.r, cache.bbox).value_or(t_max); cache.density_maj = (*grid)[grid-\u0026gt;to_index(cache.r.o)] * density_scale; cache.sigma_maj = cache.density_maj * sigma_t; cache.distr = math::Exponential_Distribution(cache.sigma_maj.value.front()); }; 对于当前与包围盒交点超过到下一个几何物体的交点的情况, 若主值为0或采样点超过几何物体边界, 更新透射率后返回. 这代表光线追踪过程中没有发生任何事件, 直接传播到下一个交点.\nif (t_boundary \u0026lt;= cache.t_max \u0026amp;\u0026amp; (cache.density_maj == 0.f || t_u \u0026gt;= t_boundary)) { update_transmittance(t_boundary + t_offset); return Interaction{ cache.r.o, phase.get(), t_max, transmittance.value.front(), transmittance, transmittance, {}, {}, {}, {}, {} }; } 如果到达包围盒交点或者当前体素主值为0, 直接穿过包围盒, 更新主值与透射率后继续追踪.\nelse if (t_boundary \u0026gt; cache.t_max \u0026amp;\u0026amp; (cache.density_maj == 0.f || t_u \u0026gt;= cache.t_max)) { update_transmittance(cache.t_max + t_offset); update_majorant(t_boundary); } 其余情况代表成功采样, 返回并交给积分器做决定.\nelse { update_transmittance(t_u); auto spectra_pdf = cache.sigma_maj * transmittance; auto density = (*grid)(cache.r.o); return Interaction{ cache.r.o, phase.get(), t_transmitted, spectra_pdf.value.front(), spectra_pdf, transmittance, density * sigma_a, density * sigma_s, cache.sigma_maj - density * sigma_t, cache.sigma_maj, density * (ctx.L \u0026amp; *Le), }; } ","date":"2025 May 5","externalUrl":null,"permalink":"/render/1746458808033-metatron-dev-3/","section":"Rendering","summary":"","title":"Metatron Dev. III: 体数据","type":"render"},{"content":"","date":"2025 April 13","externalUrl":null,"permalink":"/acgn/","section":"ACGN","summary":"","title":"ACGN","type":"acgn"},{"content":"","date":"2025 April 13","externalUrl":null,"permalink":"/tags/jrpg/","section":"Tags","summary":"","title":"Jrpg","type":"tags"},{"content":"","date":"2025 April 13","externalUrl":null,"permalink":"/tags/kiseki/","section":"Tags","summary":"","title":"Kiseki","type":"tags"},{"content":"4部打完看完大团圆, 被注水流程弄的急躁的心情终于是释怀了.\n战斗 # 结晶回路系统是对的, 想要的技能和buff即插即用, 模块化这一块.\nCP系统是好的, 没有前摇比法术爽很多, 带上几个回CP食品美美当上永动机.\n3/4的勇气指令很好用, 给的buff很牛批, 也是变相鼓励用普攻/战技而不是魔法.\n但打到后面就很疲倦了, 除非换几个角色玩一下给点新鲜感, 最后4代能用的角色数量也确实跟良子的胃袋一样塞的满满的.\n画面/性能 # 1/2是PSV游戏, 没什么好苛求的, 但画质是PSP水平的, 一股GTASA的味.\n3/4 target PS4后肉眼可见的进步, 难绷多边形不会有了, 高于我觉得画质烂的阈值.\n3/4的渲染这块3渲2做的并不是很好, 不管头发, 面部还是建筑都是金属度很高的质感, 尤其人物面部阴影, 阴影区域亮的跟黄金一样.\n闪1/2性能不好评价, 用deck玩肯定跑的动, 虽然锁60但屏幕刷新率调一下也OK. 闪2经常玩一半声音没了, 然后在下一次加载时卡死, 似乎是云豹移植的锅.\n闪3开始画质飞跃, 但性能优化一般, 主要是MSAA, 巨大的shadow map和软阴影导致的.\n在deck上用FXAA, 把阴影调成分辨率最低距离最近, 后处理选中档, 画质也是OK的, 闪3能跑60, 闪4有进一步优化, 可以跑90.\npc的话带这类老游戏还是OK的, 我的4k显示器开FXAA锯齿也很少, 同样阴影也得开小一点, 别的无脑拉高.\n音乐 # 日常/战斗音乐较为一般, 十分制给个五分吧, 起到个烘托情绪的作用, 能听就行.\n每作的ED倒是都很好听, 可以给个八分. 闪1ED I miss you是亚莉莎的告白, 闪3ED哀叹副歌是黎恩的不甘, 闪4ED爱之诗是悲剧的升华.\n至于闪2ED和各作OP, 相比ED就是中规中矩了, 但在结局时再听OP感触会很深.\n剧情 # 注水严重, 极其拖沓, 小孩子过家家. 闪1/2和闪3/4都是一个套路, 奇数作演校园日常番, 偶数作高中生拯救世界.\n日常部分我还挺喜欢, 每次实习都能开新地图, 世界紧张度一点点上调, 新鲜感是够的. 偶数作就水的很严重了, 把奇数作改成开放世界, 然后一个接一个的救人.\n至于断章问题, 咚的一下ed一响, 情绪非常到位. 但分割的下半部分完全可以压缩成一章, 而不是出一整部游戏出来赚钱.\n闪2除了结局别的毫无价值, 闪4倒是开头末日氛围很足, 第一章剧情紧凑, 但救出黎恩之后又是闪2一样水的不行的流程.\n闪4第一章的剧情有新鲜感, 第二章开始略水但可以沉迷打牌和消消乐, 第三章一开头发现还有好长一段我是绷不住了, 开最低难度速通.\n闪1/2是帝国内战, 闪3/4是世界大战, 正派反派换了个边. 大地之龙, 千之阳炎, 翼之闪光, 这些作战名字就很二次元. 最后包了一个惊天大饺子, 4部里的正派反派全部拉进主角团拯救世界.\n至于最终结局, 我更喜欢普通结局, 符合黎恩人设, 升华烂到不行的剧情, 和结城理异曲同工. 这两天一直循环爱之诗, 有点找回p4g通关一直听着Never More心里空落落的感觉了, 但p4g是喜剧的暂时分别, 闪轨是悲剧的结尾.\n大团圆结局就很俗气了, 但4部加起来至少200小时的剧情也是日久生情了, 大家都能美满幸福是好的.\n结语 # 4部粑粑拉完也是不容易, 接下来就等空轨重制了, 后面应该还会按零碧空的顺序补前作, Falcom搞这种大型连续剧真得从头开始玩.\n","date":"2025 April 13","externalUrl":null,"permalink":"/acgn/1744553147504-sennokiseki/","section":"ACGN","summary":"","title":"闪之轨迹游记","type":"acgn"},{"content":"metatron的数学库是手动实现的, 通过模板定义任意维度.\n矩阵构造 # 高维矩阵通过成员的递归定义来实现, 即用一个数组存储每一行, 每一行的类型仍然为矩阵.\n// forward declaration to support the declaration of 0d matrix template\u0026lt;typename T, usize... dims\u0026gt; struct Matrix; template\u0026lt;typename T, usize first_dim, usize... rest_dims\u0026gt; requires (first_dim \u0026gt; 0 \u0026amp;\u0026amp; (... \u0026amp;\u0026amp; (rest_dims \u0026gt; 0))) struct Matrix\u0026lt;T, first_dim, rest_dims...\u0026gt; { using Element = std::conditional_t\u0026lt;sizeof...(rest_dims) == 0, T, Matrix\u0026lt;T, rest_dims...\u0026gt;\u0026gt;; auto static constexpr dimensions = std::array\u0026lt;usize, 1 + sizeof...(rest_dims)\u0026gt;{first_dim, rest_dims... // ... private: std::array\u0026lt;Element, first_dim\u0026gt; data{}; template\u0026lt;typename U, usize... dims\u0026gt; friend struct Matrix; }; 此时构造函数也可以递归实现, 传入行类型的初始化列表即可. 如果列表只有一个元素会用来填充所有行.\nconstexpr Matrix(std::initializer_list\u0026lt;Element const\u0026gt; initializer_list) { if (initializer_list.size() \u0026gt; 1) { std::copy_n(initializer_list.begin(), std::min(first_dim, initializer_list.size()), data.begin()); } else { for (auto\u0026amp; line: data) { line = initializer_list.size() == 1 ? *initializer_list.begin() : Element{}; } } } constexpr Matrix(std::span\u0026lt;Element const\u0026gt; initializer_list) { if (initializer_list.size() \u0026gt; 1) { std::copy_n(initializer_list.begin(), std::min(first_dim, initializer_list.size()), data.begin()); } else { for (auto\u0026amp; line: data) { line = *initializer_list.begin(); } } } 如果构造函数传入标量, 一维矩阵(向量)会依次填充这些向量, 二维矩阵会填充对角线, 高维矩阵则递归构造成员. 同样的, 若参数长度为1, 会填充整个向量或矩阵对角线.\ntemplate\u0026lt;typename U\u0026gt; requires std::is_convertible_v\u0026lt;U, T\u0026gt; explicit constexpr Matrix(U\u0026amp;\u0026amp; scalar) { if constexpr (dimensions.size() == 1) { data.fill(scalar); } else if constexpr (dimensions.size() == 2) { auto constexpr diagonal_n = std::min(dimensions[0], dimensions[1]); for (auto i = 0; i \u0026lt; diagonal_n; i++) { data[i][i] = std::forward\u0026lt;U\u0026gt;(scalar); } } else { for (auto\u0026amp; line: data) { line = Element{std::forward\u0026lt;U\u0026gt;(scalar)}; } } }; template\u0026lt;typename... Args\u0026gt; requires (true \u0026amp;\u0026amp; (std::is_convertible_v\u0026lt;Args, T\u0026gt; \u0026amp;\u0026amp; ...) \u0026amp;\u0026amp; dimensions.size() \u0026gt; 1 \u0026amp;\u0026amp; sizeof...(Args) \u0026lt;= std::min(*(dimensions.end() - 2), *(dimensions.end() - 1)) ) explicit constexpr Matrix(Args\u0026amp;\u0026amp;... args) { if constexpr (dimensions.size() \u0026gt; 2) { for (auto\u0026amp; line: data) { line = {args...}; } } else { [this, args...]\u0026lt;usize... idxs\u0026gt;(std::index_sequence\u0026lt;idxs...\u0026gt;) { ((data[idxs][idxs] = args), ...); }(std::make_index_sequence\u0026lt;sizeof...(Args)\u0026gt;{}); } } 赋值构造函数支持传入比当前矩阵更小的矩阵来填充对应区域, 也可以裁剪更大的矩阵. 在此基础上, 矩阵支持在原有矩阵的基础上继续填充, 例如在向量后再添加两个标量来构造新向量, 同时也支持将除最高维度外各个维度长度相等的两个矩阵拼接.\ntemplate\u0026lt;typename U, typename... Args, usize rhs_first_dim\u0026gt; requires (true \u0026amp;\u0026amp; std::is_convertible_v\u0026lt;U, T\u0026gt; \u0026amp;\u0026amp; (std::is_convertible_v\u0026lt;Args, Element\u0026gt; \u0026amp;\u0026amp; ...) ) constexpr Matrix(Matrix\u0026lt;U, rhs_first_dim, rest_dims...\u0026gt; const\u0026amp; rhs, Args\u0026amp;\u0026amp;... rest) { *this = rhs; if constexpr (first_dim \u0026gt; rhs_first_dim) { [this, rest...]\u0026lt;usize... idxs\u0026gt;(std::index_sequence\u0026lt;idxs...\u0026gt;) { ((data[rhs_first_dim + idxs] = rest), ...); }(std::make_index_sequence\u0026lt;std::min(sizeof...(rest), first_dim - rhs_first_dim)\u0026gt;{}); } } template\u0026lt;usize rhs_first_dim0, usize rhs_first_dim1\u0026gt; constexpr Matrix( Matrix\u0026lt;T, rhs_first_dim0, rest_dims...\u0026gt; const\u0026amp; rhs0, Matrix\u0026lt;T, rhs_first_dim1, rest_dims...\u0026gt; const\u0026amp; rhs1 ) { *this = rhs0; if constexpr (first_dim \u0026gt; rhs_first_dim0) { std::copy_n(rhs1.data.begin(), std::min(first_dim, rhs_first_dim1) - rhs_first_dim0, data.begin() + rhs_first_dim0); } } template\u0026lt;typename U, usize rhs_first_dim, usize... rhs_rest_dims\u0026gt; requires true \u0026amp;\u0026amp; std::is_convertible_v\u0026lt;U, T\u0026gt; \u0026amp;\u0026amp; (sizeof...(rest_dims) == sizeof...(rhs_rest_dims)) auto constexpr operator=(Matrix\u0026lt;U, rhs_first_dim, rhs_rest_dims...\u0026gt; const\u0026amp; rhs) -\u0026gt; Matrix\u0026amp; { std::copy_n(rhs.data.begin(), std::min(first_dim, rhs_first_dim), data.begin()); return *this; } 矩阵乘法 # 加减乘除比较之类的基础运算这里省略(\u0026ldquo;乘\u0026quot;指逐元素相乘), 它们通过重载相应的运算符实现. c++20引入了operator\u0026lt;=\u0026gt;来定义比较, metatron认为矩阵的每个元素都需要满足比较关系, 因此将该运算符重载设为default即可, std::array已经实现了该比较.\n矩阵运算要求两者维度之差不超过1, 且维度较长的向量维度超过1. 例如二维矩阵和向量相乘是可行的, 三维矩阵和向量相乘是无效的, 两个向量相乘则不应该调用矩阵乘法. 这里通过模板检查向量长度, 其中higher_n是高维度的长度, 即超过2的维度.\ntemplate\u0026lt; usize... rhs_dims, usize l_n = dimensions.size(), usize r_n = sizeof...(rhs_dims), usize shorter_n = std::min(l_n, r_n), usize longer_n = std::max(l_n, r_n), usize higher_n = std::max(usize(0), longer_n - 2), std::array\u0026lt;usize, l_n\u0026gt; lds = dimensions, std::array\u0026lt;usize, r_n\u0026gt; rds = {rhs_dims...} \u0026gt; 利用requires可以进一步检查类型是否匹配. 第一个lambda检查高维度是否相等, 第二个lambda检查左矩阵的列与右矩阵的行是否相等, 向量需要特殊处理, 因为维度只有1.\nrequires (true \u0026amp;\u0026amp; longer_n \u0026gt; 1 \u0026amp;\u0026amp; (false || i32(l_n) - i32(r_n) \u0026lt; 2 || i32(r_n) - i32(l_n) \u0026lt; 2 ) // clangd could not use std::abs \u0026amp;\u0026amp; []() -\u0026gt; bool { return std::equal( lds.begin(), lds.begin() + higher_n, rds.begin(), rds.begin() + higher_n ); }() \u0026amp;\u0026amp; []() -\u0026gt; bool { return lds[higher_n + (l_n \u0026gt; 1 ? 1 : 0)] == rds[higher_n]; }() ) 高维矩阵乘法最麻烦的地方在于返回类型, 因为返回值的维度是由左右矩阵共同决定的. 这里通过让编译器自动推导返回值来实现, 因此无需显式定义返回值, 最终的返回值与Product_Matrix相等即可. 维度不等的矩阵乘法最终得到的是较短维度的矩阵, 因此可以通过std::index_sequence以及参数包展开填入每个维度的长度.\nusing Product_Matrix = decltype([]\u0026lt;usize... dims\u0026gt;(std::index_sequence\u0026lt;dims...\u0026gt;) { return Matrix\u0026lt;T, ( dims \u0026lt; higher_n ? lds[dims] : dims == higher_n ? (l_n \u0026lt; r_n ? rds[higher_n + 1] : lds[higher_n]) : rds[higher_n + 1] )...\u0026gt;{}; }(std::make_index_sequence\u0026lt;shorter_n\u0026gt;{})); 矩阵乘法的实际运算这里省略. 为了与逐元素乘法区分, 这里使用管道运算符|定义矩阵乘法.\nauto constexpr operator|( Matrix\u0026lt;T, rhs_dims...\u0026gt; const\u0026amp; rhs ) const { // ... } 由于向量使用频率更大, metatron提供了别名以及dot, cross等各类辅助函数.\ntemplate\u0026lt;typename T, usize size\u0026gt; using Vector = Matrix\u0026lt;T, size\u0026gt;; 矩阵变换 # 变换类中会存储变换矩阵及其逆矩阵, 矩阵通过config中的参数生成.\nstruct Transform final { struct Config { math::Vector\u0026lt;f32, 3\u0026gt; translation{}; math::Vector\u0026lt;f32, 3\u0026gt; scaling{1.f}; math::Quaternion\u0026lt;f32\u0026gt; rotation{0.f, 0.f, 0.f, 1.f}; auto operator\u0026lt;=\u0026gt;(Config const\u0026amp; rhs) const = default; } config; mutable math::Matrix\u0026lt;f32, 4, 4\u0026gt; transform; mutable math::Matrix\u0026lt;f32, 4, 4\u0026gt; inv_transform; // ... }; 在执行变换之前会调用update来更新矩阵, 比较config而不是transform是因为只需要比较10个元素.\nauto Transform::update(bool force) const -\u0026gt; void { if (force || config != old_config) { auto translation = math::Matrix\u0026lt;f32, 4, 4\u0026gt;{ {1.f, 0.f, 0.f, config.translation[0]}, {0.f, 1.f, 0.f, config.translation[1]}, {0.f, 0.f, 1.f, config.translation[2]}, {0.f, 0.f, 0.f, 1.f} }; auto scaling = math::Matrix\u0026lt;f32, 4, 4\u0026gt;{ config.scaling[0], config.scaling[1], config.scaling[2], 1.f }; auto rotation = math::Matrix\u0026lt;f32, 4, 4\u0026gt;{config.rotation}; old_config = config; transform = translation | rotation | scaling; inv_transform = math::inverse(transform); } } 变换通过concept定义可以变换的类型. operator|用于执行变换, operator^则执行逆变换.\ntemplate\u0026lt;typename T\u0026gt; concept Transformable = false || std::is_same_v\u0026lt;std::remove_cvref_t\u0026lt;T\u0026gt;, math::Vector\u0026lt;f32, 4\u0026gt;\u0026gt; || std::is_same_v\u0026lt;std::remove_cvref_t\u0026lt;T\u0026gt;, math::Ray\u0026gt; || std::is_same_v\u0026lt;std::remove_cvref_t\u0026lt;T\u0026gt;, math::Ray_Differential\u0026gt;; struct Transform final { // ... template\u0026lt;Transformable T\u0026gt; auto operator|(T\u0026amp;\u0026amp; rhs) const -\u0026gt; std::remove_cvref_t\u0026lt;T\u0026gt; { // ... } template\u0026lt;Transformable T\u0026gt; auto operator^(T\u0026amp;\u0026amp; rhs) const -\u0026gt; std::remove_cvref_t\u0026lt;T\u0026gt; { // ... } // ... }; 矩阵效率 # 由于用行主序存储, (\u0026hellip;(M2 | (M1 | (M0 | x))))这样的矩阵向量运算是较为容易自动向量化的, 由于改变运算符顺序不太可能, 通过函数来实现又比较丑陋, 目前代码中都是手动添加括号来进行连续矩阵运算.\n","date":"2025 April 12","externalUrl":null,"permalink":"/render/1744433421399-metatron-dev-2/","section":"Rendering","summary":"","title":"Metatron Dev. II: 矩阵运算","type":"render"},{"content":"","date":"2025 March 13","externalUrl":null,"permalink":"/tags/jovian/","section":"Tags","summary":"","title":"Jovian","type":"tags"},{"content":"由于一直想在steamdeck上手动管理代理, 但即使SteamOS有默认的/nix路径, NixOS模块仍然无法使用, 因此无法通过systemctl service在启动时自动创建tun. 了解了Jovian-NixOS这个项目后我决定nix化我的deck.\n简介 # Jovian-NixOS将Valve上游的更新迁移到NixOS上, 同时通过模块提供与SteamOS类似的体验. Jovian致力于运行在各类x86_64设备上, 但目前只重点维护steamdeck.\n安装 # Jovian-NixOS的安装是相对最复杂的, 但并Jovian并没有提供专门的安装镜像(有篇23年的文章会让你生成镜像, 现在已经不支持了), 遵循一般的NixOS安装过程即可, 我会讲一下我遇到的坑.\n由于steamdeck只有一个usb-c接口, 最好使用micro sd卡(tf卡)安装(淘宝上搜sd卡都是大号的, 害我还得再买tf卡), 把usb口留给键盘. 插入tf卡时会有类似弹簧的手感, 再用点劲往里推听到咔哒一声才算是装上了. 拓展坞理论上也是可行的, 我并没有尝试. 长按音量-键然后按开机键就可以进入引导菜单了.\nsteamdeck的wifi是高通网卡, 不是每个内核版本的驱动都比较稳定. 我在安装时6.11.11-valve7版本的内核会驱动加载失败, 升级到valve8后可以检测到网卡, 但是通过nmcli上网仍然容易失败, 最后通过删除所有已知网络并重启来解决. 无法连接网络会导致卡在logo界面, 最好插上键盘通过ctrl+alt+f[2, 3, 4 \u0026hellip;]切换tty去解决问题. 安装时建议打开openssh, 不然不方便远程控制.\n配置中硬件与内核相关的参数可以删掉, Jovian的模块里会配置这些内容. 同时也不要在配置里指定内核包, 未经过Valve patch的内核很有可能出问题, 比如我一开始使用6.12会导致屏幕有雪花噪点且gamescope无法启动.\n对于硬盘分区, 我是通过disko将硬盘格式化为开启zstd压缩的btrfs. disko支持用flake中的disko配置来自动做硬盘分区. 执行disko的nix run命令之前最好通过NIX_CONFIG环境变量开启试验特性, 比如我的配置用到了管道操作符, 但是在命令中无论在哪个位置插入\u0026ndash;extra-experimental-features都无法开启这个特性, 必须通过环境变量.\n配置 # Jovian的配置基本是开箱即用的, 有以下这些配置就够了, 更多的选项可以看官网或者源码. 这里desktopSession是steamdeck切换桌面选项后会打开的桌面, gamescope-wayland代表仍然打开steam ui, 这里还可以选择gnome或KDE. updater.splash是开机的logo, 可以选择steamdeck, jovian和当前主板的logo.\njovian.steam = { enable = true; autoStart = true; desktopSession = \u0026#34;gamescope-wayland\u0026#34;; updater.splash = \u0026#34;jovian\u0026#34;; user = \u0026#34;deck\u0026#34;; }; jovian = { devices.steamdeck.enable = true; hardware.has.amd.gpu = true; }; deckyloader的话Jovian可以通过模块开启, 但因为我不需要tommon我就没有安装, steamdeck有了好看的steam娘启动画面后我也不需要用decky里的自定义启动画面了. Jovian对decky的支持问题还挺多的, decky跟nixos不太合得来, 之前SteamOS的时候每次系统更新可能都需要重新安装decky, 挺麻烦的.\n体验 # 基本和steamdeck一致, 也不会因为系统的关系影响硬件识别, deck用户该拿的福利还是会有. 同时因为我可以很方便的把NixOS配置搬过来, 用steamdeck做一些开发也会方便很多, 不会被SteamOS限制修改系统环境了. 我在steamdeck上安装fish和我的nixvim配置模块后和普通的linux设备体验很像了.\n之前steamos时通过tomoon开启代理会导致ssh过去速度异常的慢, 用我自己的sing-box配置完全解决了这个问题. sing-box需要配置steamserver.net走直连, 这样steam下载才不会走代理.\n问题也是有的, 除了上面所说的网卡问题之外, Jovian-NixOS现在不支持CJK字体, 似乎几个月了还没修好, 当然游戏里还是会有中文的.\n","date":"2025 March 13","externalUrl":null,"permalink":"/unix/1741878748543-jovian-nixos/","section":"Unix","summary":"","title":"Jovian-NixOS: steamdeck完全nix化","type":"unix"},{"content":"","date":"2025 March 13","externalUrl":null,"permalink":"/tags/nixos/","section":"Tags","summary":"","title":"Nixos","type":"tags"},{"content":"","date":"2025 March 13","externalUrl":null,"permalink":"/tags/steamdeck/","section":"Tags","summary":"","title":"Steamdeck","type":"tags"},{"content":"","date":"2025 March 13","externalUrl":null,"permalink":"/unix/","section":"Unix","summary":"","title":"Unix","type":"unix"},{"content":"今天正式开始开发metatron, 名字由来第一版发布再说. 这些文章主要记录一些相对独有的开发成果, 烂大街的就不提了.\n工具链 # 原本计划使用c++20 modules, 因为懒得分离定义和实现. linux上只有clang对模块有正式支持, 但当clang的exe为符号链接时模块无法找到系统头文件, 而NixOS更是封装了一层bash. 官方推荐手动设置-I/path/to/system/headers, 但最后clang会引用到gcc的头文件, 导致找不到定义. 即使不用模块, 现在nixos-24.11的clang也有封装问题, 同样找不到系统头文件. 之后试过用c++23 import std;, 但cmake即使打开实验特性也会报only support libc++.\nrust也是个选择, 但rust的trait和impl其实也一定程度分离了定义和实现. 加上我对c++还是有好感的, 也希望项目里能练习一些新特性, 最后还是fallback到更稳妥的gcc+headers\n编辑器 # 使用自己配置的nixvim, 测试模块时发现clangd默认不支持c++20语法特性, 需要通过.clangd文件设置.\nCompileFlags: Add: [-std=c++20] 构建系统 # 为了兼容性使用CMake, 构建流程的设计目标如下:\n模块可被独立链接 自动分析依赖关系 第三方依赖可配置 项目结构 # 整体结构分为以下处理单元集合:\next: 第三方依赖 src: 项目内模块 exe: 可执行程序 此外还有额外的文件夹:\ncmake: 自定义的cmake函数 分批处理 # 将ext/src/exe下面的子文件作为最小处理单元, metatron_classify负责收集处理单元. path是单元集合目录, 目录下的单元会使用相似的构建方式, 例如exe下的单元都会通过add_executable创建target. mode记录当前处理模式, 同样可设置为\u0026quot;ext\u0026quot;|\u0026quot;src\u0026quot;|\u0026quot;exe\u0026quot;, 主要用于单元构建时选择不同的策略. 为防止冲突模块名会添加metatron-的前缀.\nfunction(metatron_classify path mode) if (IS_DIRECTORY ${path}) file(GLOB units RELATIVE ${path} ${path}/*) foreach(unit ${units}) if(IS_DIRECTORY ${path}/${unit}) metatron_evaluate(metatron-${unit} ${path}/${unit} ${mode}) endif() endforeach() endif() endfunction() 单元设置 # 每个单元下都可以通过setup.cmake做一些设置, 例如exe/renderer/setup.cmake, 大部分工作都在这里完成, CMakeLists.txt只做简单的配置与全局变量定义. metatron-build用于收集所有构建单元, 然后再分析依赖关系.\ncmake_minimum_required(VERSION 3.30.5) project(metatron-renderer LANGUAGES CXX) set(CMAKE_CXX_STANDARD 20) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/lib) set(metatron-root ${CMAKE_CURRENT_LIST_DIR}) set(metatron-bin ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}) set(metatron-lib ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/lib) define_property(TARGET PROPERTY metatron-units) define_property(TARGET PROPERTY metatron-path) define_property(TARGET PROPERTY metatron-mode) define_property(TARGET PROPERTY metatron-access) include(cmake/classify.cmake) include(cmake/evaluate.cmake) include(cmake/link.cmake) add_library(metatron-build INTERFACE) set_property(TARGET metatron-build PROPERTY metatron-units) metatron_classify(${metatron-root}/lib \u0026#34;ext\u0026#34;) metatron_classify(${metatron-root}/src \u0026#34;src\u0026#34;) metatron_classify(${metatron-root}/exe \u0026#34;exe\u0026#34;) get_property(metatron-units TARGET metatron-build PROPERTY metatron-units) foreach(unit ${metatron-units}) metatron_link(${unit}) endforeach() 对于处理单元集合, setup.cmake只是调用metatron_classify.\nmessage(STATUS \u0026#34;processing libraries ...\u0026#34;) metatron_classify(\u0026#34;${metatron-root}/src\u0026#34; \u0026#34;src\u0026#34;) 对于exe/src, setup.cmake主要用于分析依赖关系, 将依赖的模块存储在metatron-deps中.\nlist(APPEND metatron-deps mimalloc) 对于lib, setup.cmake还会设置第三方库的构建选项. 第三方库也需要设置metatron-deps, 主要用于以统一的格式设置依赖.\nset(MI_USE_CXX ON CACHE BOOL \u0026#34;\u0026#34;) set(MI_BUILD_STATIC OFF CACHE BOOL \u0026#34;\u0026#34;) set(MI_BUILD_OBJECT OFF CACHE BOOL \u0026#34;\u0026#34;) set(MI_BUILD_TESTS OFF CACHE BOOL \u0026#34;\u0026#34;) add_subdirectory(${path}/mimalloc) list(APPEND metatron-deps mimalloc) 求解模块 # 模块生成过程在metatron_evaluate中.\n对于ext, 创建interface target, 用于传递与第三方库的依赖关系, 并不会生成实际构建结果.\nmessage(STATUS \u0026#34;build external library ${target}\u0026#34;) add_library(${target} INTERFACE) src/exe下如果有cpp文件, 则创建target, 传递头文件目录的依赖, 最后会生成动态库或可执行文件. 模块的头文件必须位于include/metatron/${unit}/, 这样头文件都可以通过#include \u0026lt;metatron/${unit}/...\u0026gt;引入, 且分析完依赖关系后, 只有依赖的模块的头文件会被补全.\nif(${mode} STREQUAL \u0026#34;exe\u0026#34;) message(STATUS \u0026#34;build executable ${target}\u0026#34;) add_executable(${target} ${sources}) else() message(STATUS \u0026#34;build library ${target}\u0026#34;) add_library(${target} SHARED EXCLUDE_FROM_ALL ${sources}) endif() target_include_directories(${target} PUBLIC ${path}/include) 构建单元如果是纯头文件库, 或者是只用于收集依赖并传播的接口库, 采用和lib类似的处理方式, 因为只需要被include或target链接.\nif(headers) message(STATUS \u0026#34;build header-only library ${target}\u0026#34;) else() message(STATUS \u0026#34;build interface library ${target}\u0026#34;) endif() add_library(${target} INTERFACE) target_include_directories(${target} INTERFACE ${path}/include) set(mode \u0026#34;inc\u0026#34;) 最后设置target属性用于依赖分析.\nset_property(TARGET ${target} PROPERTY metatron-path ${path}) set_property(TARGET ${target} PROPERTY metatron-mode ${mode}) if(${mode} STREQUAL \u0026#34;ext\u0026#34; OR ${mode} STREQUAL \u0026#34;inc\u0026#34;) set_property(TARGET ${target} PROPERTY metatron-access INTERFACE) else() set_property(TARGET ${target} PROPERTY metatron-access PUBLIC) endif() 链接依赖 # 获取target属性.\nset(target metatron-${unit}) get_property(path TARGET ${target} PROPERTY metatron-path) get_property(mode TARGET ${target} PROPERTY metatron-mode) get_property(access TARGET ${target} PROPERTY metatron-access) 执行setup.cmake中的自定义构建流程.\n# execute setup file set(metatron-deps) set(setup-file ${path}/setup.cmake) if(EXISTS ${setup-file}) include(${setup-file}) endif() 获取依赖项, 由于构建系统自动添加前缀, src/exe需要重命名依赖项.\n# solve dependencies set(linked-libs) foreach(dep ${metatron-deps}) if(${mode} STREQUAL \u0026#34;ext\u0026#34;) list(APPEND linked-libs ${dep}) else() list(APPEND linked-libs metatron-${dep}) endif() endforeach() 执行target链接.\n# link dependencies if(linked-libs) message(STATUS \u0026#34;${target} link libraries ${linked-libs}\u0026#34;) target_link_libraries(${target} ${access} ${linked-libs}) endif() 构建运行 # 为避免cmake命令行参数不一致导致的问题, 项目中含有CMakePresets.json.\n{ \u0026#34;cmakeMinimumRequired\u0026#34;: { \u0026#34;major\u0026#34;: 3, \u0026#34;minor\u0026#34;: 30, \u0026#34;patch\u0026#34;: 5 }, \u0026#34;configurePresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;generator\u0026#34;: \u0026#34;Ninja\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_EXPORT_COMPILE_COMMANDS\u0026#34;: \u0026#34;ON\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;linux-native-dev\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/build/${presetName}\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Debug\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;linux-native-rel\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/build/${presetName}\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Release\u0026#34; } } ], \u0026#34;version\u0026#34;: 8 } 运行cmake -B build --preset linux-native-dev即可生成构建目标, cmake --build build启动构建.\n无论neovim还是vscode的CMake插件我都使用过一段时间, 其实和命令行也没差多少, 无非是可以打开编辑器自动生成, 对于我自己的项目确实没必要了.\n","date":"2025 February 16","externalUrl":null,"permalink":"/render/1739688931824-metatron-dev-1/","section":"Rendering","summary":"","title":"Metatron Dev. I: 构建系统","type":"render"},{"content":"","date":"2025 January 21","externalUrl":null,"permalink":"/tags/pbrt/","section":"Tags","summary":"","title":"Pbrt","type":"tags"},{"content":" 辐射转移方程 # LTE忽略了介质, 而辐射转移方程(radiative transfer equation, RTE)会考虑介质, 因此也被叫做体积光线传播方程(volumetric light transport equation). RTE通常为积分微分方程, 因为外散射过程涉及到积分. 令\\(p\u0026rsquo;=p+t\\omega\\), 其余符号见之前章节, 此时RTE形式如下.\n$$ \\begin{equation} \\frac{\\partial L_o(p\u0026rsquo;,\\omega)}{\\partial t} = -\\sigma_t(p\u0026rsquo;,\\omega)L_i(p\u0026rsquo;,-\\omega)+\\sigma_t(p\u0026rsquo;,\\omega)L_s(p\u0026rsquo;,\\omega) \\end{equation} $$\n对于\\(L_i(p,\\omega)\\), 它的变化是体渲染的逆过程, 等式右侧需要乘上\\(-1\\), 解积分方程可得如下结果.\n$$ \\begin{equation} L_i(p\u0026rsquo;,\\omega)=\\frac{-\\int_0^{t} T_r(p\u0026rsquo;\u0026rsquo; \\to p)\\sigma_t(p\u0026rsquo;\u0026rsquo;,\\omega)L_s(p\u0026rsquo;\u0026rsquo;,-\\omega)dt\u0026rsquo;+C}{T_r(p\u0026rsquo; \\to p)} \\end{equation} $$\n若第一个散射点位于\\(t_s\\), 该处可以是由表面BSDF表示的散射, 也可以是介质相位方程表示的散射. 由于\\(L_i(p_s, \\omega)=L_o(p_s,-\\omega)\\), 此时得到如下结果.\n$$ \\begin{equation} L_i(p\u0026rsquo;,\\omega)=\\frac{-\\int_0^t T_r(p\u0026rsquo;\u0026rsquo; \\to p)\\sigma_t(p\u0026rsquo;\u0026rsquo;,\\omega)L_s(p\u0026rsquo;\u0026rsquo;,-\\omega)dt\u0026rsquo;+L_o(p_s,-\\omega)T_r(p_s \\to p)+\\int_0^{t_s} T_r(p\u0026rsquo;\u0026rsquo; \\to p)\\sigma_t(p\u0026rsquo;\u0026rsquo;,\\omega)L_s(p\u0026rsquo;\u0026rsquo;,-\\omega)dt\u0026rsquo;}{T_r(p\u0026rsquo; \\to p)} \\end{equation} $$\n根据上式可得\\(L_i(p,\\omega)\\), 若光路上没有任何交点, 则无穷远处辐亮度为0, 只剩下积分项.\n$$ \\begin{equation} L_i(p,\\omega)=L_o(p_s, -\\omega)T_r(p_s \\to p)+\\int_0^{t_s} \\sigma_t(p\u0026rsquo;,\\omega)T_r(p\u0026rsquo; \\to p)L_s(p\u0026rsquo;,-\\omega)dt \\end{equation} $$\n空散射扩展 # Monte Carlo需要根据与\\(L_i(p,\\omega)\\)中积分项相似的分布来提高采样效率, 异质介质的\\(\\sigma_t(p)\\)是复杂的分布不利于从分布中采样. 如果在一定范围内添加空散射\\(\\sigma_n(p)\\)构造同质介质\\(\\sigma_{\\text{maj}}(p)\\), 即将\\(\\sigma_t(p)\\)转为常数或分段常数\\(\\sigma_{\\text{maj}}(p)\\), 可以有效提高渲染效率. 在RTE右侧添加\\(-\\sigma_n(p)L_i(p,\\omega)+\\sigma_n(p)L_i(p,\\omega)\\)可得如下结果, 此时衰减过程使用\\(\\sigma_{\\text{maj}}(p)\\), 光线传播过程中在自发光与散射之外也会在任意\\(\\sigma_n(p)\\)不为0处发生空散射.\n$$ \\begin{equation} \\begin{aligned} \\frac{\\partial L_i(p\u0026rsquo;,\\omega)}{\\partial t} \u0026amp;=\\sigma_{\\text{maj}}(p\u0026rsquo;)L_i(p\u0026rsquo;,\\omega)-\\sigma_{\\text{maj}}(p\u0026rsquo;)L_n(p\u0026rsquo;,-\\omega)\\\\ \u0026amp;=(\\sigma_a(p\u0026rsquo;,\\omega)+\\sigma_s(p\u0026rsquo;,\\omega)+\\sigma_n(p\u0026rsquo;,\\omega))L_i(p\u0026rsquo;,\\omega)-\\sigma_a(p\u0026rsquo;,\\omega)L_e(p,-\\omega)-\\sigma_s(p\u0026rsquo;,\\omega)\\int_\\Theta p(p\u0026rsquo;,\\omega_i,-\\omega)L_i(p\u0026rsquo;,\\omega_i)d\\omega_i-\\sigma_n(p\u0026rsquo;,\\omega)L_i(p\u0026rsquo;,\\omega) \\end{aligned} \\end{equation} $$\n此时可以得到相交点为\\(p_s\\)时在\\(p\\)处的\\(L_i(p,\\omega)\\).\n$$ \\begin{equation} L_i(p,\\omega)=L_o(p_s,-\\omega)T_{\\text{maj}}(p_s \\to p)+\\int_0^{t_s} \\sigma_{\\text{maj}}(p\u0026rsquo;)T_{\\text{maj}}(p\u0026rsquo; \\to p)L_n(p\u0026rsquo;,-\\omega)dt \\end{equation} $$\n采样主透射率 # pbrt中Medium是\\(\\sigma_{\\text{maj}}\\)的分段函数, 积分可以按如下方式表示. 此时可以执行递归采样, 首先采样\\(T_{\\text{maj}}^1\\), 若得到的\\(t\u0026rsquo;_1\u0026lt;t_1\\)则采样第一项, 采样结果为\\(\\frac{\\sigma_{\\text{maj}}^1 T_{\\text{maj}}^1(p \\to p\u0026rsquo;)f(p\u0026rsquo;)}{p_1(t\u0026rsquo;_1)}=f(p\u0026rsquo;)\\), 若\\(t\u0026rsquo;_1\u0026gt;t_2\\)则采样第二项, 采样结果为\\(\\frac{T_{\\text{maj}}^1(p \\to p_1)\\sigma_{\\text{maj}}^2 T_{\\text{maj}}^2(p \\to p\u0026rsquo;)f(p\u0026rsquo;)}{P(t\u0026rsquo;_1 \u0026gt; t_1)p_1(t\u0026rsquo;_1)}=f(p\u0026rsquo;)\\), 如此一直递归, 可以看出采样结果始终为\\(f(p\u0026rsquo;)\\).\n$$ \\begin{equation} \\begin{aligned} \u0026amp;\\int_0^t \\sigma_{\\text{maj}}(p\u0026rsquo;)T_{\\text{maj}}(p \\to p\u0026rsquo;)f(p\u0026rsquo;)dt\u0026rsquo;\\\\ \u0026amp;=\\sigma_{\\text{maj}}^1\\int_0^{t_1}T_{\\text{maj}}^1(p \\to p\u0026rsquo;)f(p\u0026rsquo;)dt\u0026rsquo;\\\\ \u0026amp;+T_{\\text{maj}}^1(p \\to p_1)\\sigma_{\\text{maj}}^2 \\int_{t_1}^{t_2}T_{\\text{maj}}^2(p_1 \\to p\u0026rsquo;)f(p\u0026rsquo;)dt\u0026rsquo;\\\\ \u0026amp;+T_{\\text{maj}}^1(p \\to p_1)T_{\\text{maj}}^2(p_1 \\to p_2)\\sigma_{\\text{maj}}^3 \\int_{t_2}^{t_3}T_{\\text{maj}}^3(p_2 \\to p\u0026rsquo;)f(p\u0026rsquo;)dt\u0026rsquo;\\\\ \u0026amp;+ \\cdots \\end{aligned} \\end{equation} $$\npbrt通过在SampleT_maj中实现采样RTE中的积分项, 上式中的\\(f\\)对应\\(L_n\\). pbrt会根据概率选择\\(L_n\\)的三项, 这会在callback中实现. 选择\\(\\sigma_a\\)或\\(\\sigma_s\\)项会完成本次采样, 而由于\\(\\sigma_n\\)项包含\\(L_i\\), pbrt会继续递归计算\\(L_i\\), 在SampleT_maj中表现为不退出循环.\ntemplate \u0026lt;typename ConcreteMedium, typename F\u0026gt; PBRT_CPU_GPU SampledSpectrum SampleT_maj(Ray ray, Float tMax, Float u, RNG \u0026amp;rng, const SampledWavelengths \u0026amp;lambda, F callback) { // Normalize ray direction and update _tMax_ accordingly tMax *= Length(ray.d); ray.d = Normalize(ray.d); // Initialize _MajorantIterator_ for ray majorant sampling ConcreteMedium *medium = ray.medium.Cast\u0026lt;ConcreteMedium\u0026gt;(); typename ConcreteMedium::MajorantIterator iter = medium-\u0026gt;SampleRay(ray, tMax, lambda); // Generate ray majorant samples until termination SampledSpectrum T_maj(1.f); bool done = false; while (!done) { // Get next majorant segment from iterator and sample it pstd::optional\u0026lt;RayMajorantSegment\u0026gt; seg = iter.Next(); if (!seg) return T_maj; // Handle zero-valued majorant for current segment if (seg-\u0026gt;sigma_maj[0] == 0) { Float dt = seg-\u0026gt;tMax - seg-\u0026gt;tMin; // Handle infinite _dt_ for ray majorant segment if (IsInf(dt)) dt = std::numeric_limits\u0026lt;Float\u0026gt;::max(); T_maj *= FastExp(-dt * seg-\u0026gt;sigma_maj); continue; } // Generate samples along current majorant segment Float tMin = seg-\u0026gt;tMin; while (true) { // Try to generate sample along current majorant segment Float t = tMin + SampleExponential(u, seg-\u0026gt;sigma_maj[0]); PBRT_DBG(\u0026#34;Sampled t = %f from tMin %f u %f sigma_maj[0] %f\\n\u0026#34;, t, tMin, u, seg-\u0026gt;sigma_maj[0]); u = rng.Uniform\u0026lt;Float\u0026gt;(); if (t \u0026lt; seg-\u0026gt;tMax) { // Call callback function for sample within segment PBRT_DBG(\u0026#34;t \u0026lt; seg-\u0026gt;tMax\\n\u0026#34;); T_maj *= FastExp(-(t - tMin) * seg-\u0026gt;sigma_maj); MediumProperties mp = medium-\u0026gt;SamplePoint(ray(t), lambda); if (!callback(ray(t), mp, seg-\u0026gt;sigma_maj, T_maj)) { // Returning out of doubly-nested while loop is not as good perf. wise // on the GPU vs using \u0026#34;done\u0026#34; here. done = true; break; } T_maj = SampledSpectrum(1.f); tMin = t; } else { // Handle sample past end of majorant segment Float dt = seg-\u0026gt;tMax - tMin; // Handle infinite _dt_ for ray majorant segment if (IsInf(dt)) dt = std::numeric_limits\u0026lt;Float\u0026gt;::max(); T_maj *= FastExp(-dt * seg-\u0026gt;sigma_maj); PBRT_DBG(\u0026#34;Past end, added dt %f * maj[0] %f\\n\u0026#34;, dt, seg-\u0026gt;sigma_maj[0]); break; } } } return SampledSpectrum(1.f); } 泛化路径空间 # 这里主要参考Light transport on path-space manifolds第三章和A null-scattering path integral formulation of light transport, 证明涉及到泛函分析, 本人水平不够, 这里只讨论证明结果.\n令\\(A\\)为表面空间, \\(V\\)为体积空间, \\(V_\\emptyset\\)为空散射空间, 此时路径空间定义如下.\n$$ \\begin{equation} P=\\bigcup_{n=1}^{\\infty}(A \\cup V \\cup V_\\emptyset)^{n} \\end{equation} $$\n对于长度为\\(n\\)的路径, 其微分项如下.\n$$ \\begin{equation} \\begin{aligned} d\\bar{p}_n\u0026amp;=\\prod_{i=1}^n dp_i\\\\ dp_i\u0026amp;= \\begin{cases} dA(p_i) \u0026amp; p_i \\in A\\\\ dV(p_i) \u0026amp; p_i \\in V\\\\ dV_\\emptyset(p_i) \u0026amp; p_i \\in V_\\emptyset \\end{cases} \\end{aligned} \\end{equation} $$\n立体角与表面积微分的转换之前介绍过, 由于引入了空间中的介质, 我们需要立体角与体积微分的转换关系. 将体积积分视为在一个不断扩张的球上积分, 球表面积微分与立体角转换关系为\\(d\\omega=\\frac{dA}{t^2}\\), 通过Fubini定理可以得到体积微分.\n$$ \\begin{equation} \\begin{aligned} \u0026amp;\\int_\\Theta\\int_0^\\infty f(p\u0026rsquo;)V(p \\leftrightarrow p\u0026rsquo;) dt d\\omega\\\\ =\u0026amp;\\int_0^\\infty \\frac{1}{t^2}\\int_\\Theta f(p\u0026rsquo;)V(p \\leftrightarrow p\u0026rsquo;) dA(p\u0026rsquo;) dt\\\\ =\u0026amp;\\int_V \\frac{V(p \\leftrightarrow p\u0026rsquo;)}{\\Vert p - p\u0026rsquo; \\Vert^2} f(p\u0026rsquo;) dV(p\u0026rsquo;) \\end{aligned} \\end{equation} $$\n对于空散射体积空间, 由于不发生散射以改变光路, 空散射顶点必须位于相邻的实散射顶点形成的边上, 此时通过Dirac delta分布表示.\n$$ \\begin{equation} dV_\\emptyset(p_i)=d\\delta_{p_i^{r-} \\leftrightarrow p_i^{r+}}(p_i) \\end{equation} $$\n可以看出体积微分与表面积微分相比缺失了余弦项, 同时不难看出只有某个位于表面时, 其上的余弦项才会被考虑, 此时可以定义泛化几何方程. 空散射由于不改变光路不需要求解几何方程.\n$$ \\begin{equation} \\begin{aligned} \\hat{G}(p \\leftrightarrow p\u0026rsquo;)\u0026amp;=V(p \\leftrightarrow p\u0026rsquo;)\\frac{D(p,p\u0026rsquo;)D(p\u0026rsquo;,p)}{\\Vert p-p\u0026rsquo; \\Vert^2}\\\\ D(x, y)\u0026amp;= \\begin{cases} |n_x \\cdot \\frac{x-y}{\\Vert x-y \\Vert}| \u0026amp; p \\in A\\\\ 1 \u0026amp; p \\in V \\end{cases} \\end{aligned} \\end{equation} $$\n在介质中同样可以发生散射, 这由相位方程和散射率决定, 因此需要定义泛化的BSDF, 其中\\(\\chi+\\)为Heaviside函数, 参数为正时为1否则为0, 对于空散射这始终为1, 用于限制空散射顶点位于边上.\n$$ \\begin{equation} \\begin{aligned} \\hat{f}(p_{i+1} \\to p_i \\to p_{i-1})= \\begin{cases} f(p_{i+1} \\to p_i \\to p_{i-1}) \u0026amp; p_i \\in A\\\\ \\sigma_s(p_i)p(p_{i+1} \\to p_i \\to p_{i-1}) \u0026amp; p_i \\in V\\\\ \\sigma_n(p_i)\\chi^+((p_i-p_{i-1})(p_{i+1}-p_i)) \u0026amp; p_i \\in V_\\emptyset \\end{cases} \\end{aligned} \\end{equation} $$\n此时可以得到泛化路径通量, 其中\\(m\\)为实散射顶点数量, \\(r_i\\)为实散射点, 透射率求和从0开始是因为\\(p_0\\)已知.\n$$ \\begin{equation} \\hat{T}(\\bar{p}_n)=\\prod_{i=1}^{n-1}\\hat{f}(p_{i+1} \\to p_i \\to p_{i-1})\\prod_{i=0}^{n-1}T_r(p_{i+1} \\to p_i)\\prod_{i=1}^{m-1}\\hat{G}(r_{i+1} \\leftrightarrow r_i) \\end{equation} $$\n自发光亮度同样具有泛化形式, 空散射顶点不会发光.\n$$ \\begin{equation} \\begin{aligned} \\hat{L_e}(p_n \\to p_{n-1})= \\begin{cases} L_e(p_n \\to p_{n-1}) \u0026amp; p_i \\in A\\\\ \\sigma_a(p_n)L_e(p_n \\to p_{n-1}) \u0026amp; p_i \\in V \\end{cases} \\end{aligned} \\end{equation} $$\n\\(p_0\\)为相机, 所有长度为\\(n+1\\)的路径如下.\n$$ \\begin{equation} \\hat{P}(\\bar{p}_n)=\\int_{P_{n}}\\hat{L_e}(p_n \\to p_{n-1})\\hat{T}(\\bar{p}_n)d\\bar{p}_{n} \\end{equation} $$\n此时Monte Carlo结果如下, 同时可以定义辐射通量权重\\(\\beta(\\bar{p}_n)\\).\n$$ \\begin{equation} \\begin{aligned} \\hat{P}(\\bar{p}_n) \u0026amp;=\\hat{L_e}(p_n \\to p_{n-1})\\beta(\\bar{p}_n)\\\\ \u0026amp;=\\frac{\\hat{L_e}(p_n \\to p_{n-1})\\hat{T}(\\bar{p}_n)}{p(\\bar{p}_n)} \\end{aligned} \\end{equation} $$\n求解路径空间积分 # 令\\(p_\\text{maj}(p_{i+1}|p_i,\\omega_i)\\)为从\\(p_i\\)在\\(\\omega_i\\)方向上采样到\\(p_{i+1}\\)的概率, \\(p_e(p_i)\\)为在\\(p_i\\)选择吸收, 实散射或空散射的概率, 概率分别为\\(\\frac{\\sigma_{\\{a,s,n\\}}(p_i)}{\\sigma_{\\text{maj}}(p_i)}\\), \\(p_\\omega(\\omega_{i+1}|r_i)\\)为实散射入射方向为\\(\\omega_{i+1}\\)的概率, \\(G\\)用于抵消微分转换. 场景中没有表面散射时Monte Carlo结果如下, 根据之前的结论可以看出部分项可以抵消, 同时由于只有\\(p_n\\)为光源, 当且仅当在\\(p_n\\)选择吸收.\n$$ \\begin{equation} \\begin{aligned} \\hat{P}(\\bar{p}_n) \u0026amp;=\\frac{\\hat{T}(\\bar{p}_n)\\hat{L}_e(p_n \\to p_{n-1})}{\\prod_{i=0}^{n-1}p_{\\text{maj}}(p_{i+1}|p_i,\\omega_i)\\prod_{i=1}^{n}p_e(p_i)\\prod_{i=1}^{m-1}p_\\omega(\\omega_{i+1}|r_i)\\hat{G}(r_i \\leftrightarrow r_{i+1})}\\\\ \u0026amp;=\\frac{\\hat{L}_e(p_n \\to p_{n-1})\\prod_{i=1}^{n-1}\\hat{f}(p_{i+1} \\to p_i \\to p_{i-1})}{\\prod_{i=0}^{n-1}\\sigma_{\\text{maj}}(p_{i+1})\\prod_{i=1}^{n}p_e(p_i)\\prod_{i=1}^{m-1}p_\\omega(\\omega_{i+1}|r_i)}\\\\ \u0026amp;=\\frac{\\hat{L}_e(p_n \\to p_{n-1})\\prod_{i=1}^{n-1}\\hat{f}(p_{i+1} \\to p_i \\to p_{i-1})}{\\sigma_{a}(p_n)\\prod_{i=1}^{n-1}\\sigma_{\\{s,n\\}}(p_i)\\prod_{i=1}^{m-1}p_\\omega(\\omega_{i+1}|r_i)} \\end{aligned} \\end{equation} $$\n若场景中没有表面散射, 此时\\(\\hat{f}\\)和\\(\\hat{L}_e\\)都是确定的, 可以进一步简化.\n$$ \\begin{equation} \\hat{P}(\\bar{p}_n)=\\prod_{i=1}^{m-1}\\frac{p(r_{i+1} \\to r_i \\to r_{i-1})}{p_\\omega(\\omega_{i+1}|r_i)}L_e(p_n \\to p_{n-1}) \\end{equation} $$\n体散射积分器 # 简单体积积分器 # SimpleVolPathIntegrator不支持光源采样与表面散射, 即只用来渲染体积效果. 该类的成员只有maxDepth, 表示路径顶点数.\nclass SimpleVolPathIntegrator : public RayIntegrator { public: // SimpleVolPathIntegrator Public Methods // ... private: // SimpleVolPathIntegrator Private Members int maxDepth; }; Li执行路径追踪, 与PathIntegrator的积分过程类似. 由于体数据可能随波长变化, Li只保留一个波长样本以简化计算.\nLi首先计算光线求交, 因为场景中仍然会有一些几何物体, 例如用于表示介质分界的几何形状, 或者不进行散射的面积光源. 此时可以获取光线传播的最大距离, 体渲染样本不会超过这个范围.\nLi通过SampleT_maj获取体渲染样本并执行差值跟踪, 在回调函数中首先选取介质事件, 根据吸收率, 散射率与空散射率进行概率选择.\n// Compute medium event probabilities for interaction Float pAbsorb = mp.sigma_a[0] / sigma_maj[0]; Float pScatter = mp.sigma_s[0] / sigma_maj[0]; Float pNull = std::max\u0026lt;Float\u0026gt;(0, 1 - pAbsorb - pScatter); // Randomly sample medium scattering event for delta tracking int mode = SampleDiscrete({pAbsorb, pScatter, pNull}, uMode); 若为吸收则停止采样, 获取光照并返回结果.\nL += beta * mp.Le; terminated = true; return false; 若为散射则根据相位方程采样散射方向, 由于是实散射路径深度会增加. 发生散射返回false, 因为路径已经被改变, 不能再执行当前SampleT_maj. 注意到由于可以直接从Henyey-Greenstein中采样, 而pbrt目前只实现了这一种相位函数. 这里ps-\u0026gt;p / ps-\u0026gt;pdf始终为1.\n// Stop path sampling if maximum depth has been reached if (depth++ \u0026gt;= maxDepth) { terminated = true; return false; } // Sample phase function for medium scattering event Point2f u{rng.Uniform\u0026lt;Float\u0026gt;(), rng.Uniform\u0026lt;Float\u0026gt;()}; pstd::optional\u0026lt;PhaseFunctionSample\u0026gt; ps = mp.phase.Sample_p(-ray.d, u); if (!ps) { terminated = true; return false; } // Update state for recursive evaluation of $L_\\roman{i}$ beta *= ps-\u0026gt;p / ps-\u0026gt;pdf; ray.o = p; ray.d = ps-\u0026gt;wi; scattered = true; return false; 若为空散射则返回true以继续采样, 同时由于只有空散射会继续执行当前回调函数, uMode需要重新生成.\nuMode = rng.Uniform\u0026lt;Float\u0026gt;(); return true; 路径追踪结束后, 若与表面相交则获取面积光源, 否则使用无限光源.\nif (terminated) return L; if (scattered) continue; // Add emission to surviving ray if (si) L += beta * si-\u0026gt;intr.Le(-ray.d, lambda); else { for (const auto \u0026amp;light : infiniteLights) L += beta * light.Le(ray, lambda); return L; } pbrt会检查是否有发生散射的几何物体, 在SimpleVolPathIntegrator中这是无效的.\nBSDF bsdf = si-\u0026gt;intr.GetBSDF(ray, lambda, camera, buf, sampler); if (!bsdf) si-\u0026gt;intr.SkipIntersection(\u0026amp;ray, si-\u0026gt;tHit); else { // Report error if BSDF returns a valid sample Float uc = sampler.Get1D(); Point2f u = sampler.Get2D(); if (bsdf.Sample_f(-ray.d, uc, u)) ErrorExit(\u0026#34;SimpleVolPathIntegrator doesn\u0026#39;t support surface scattering.\u0026#34;); else break; } 改进采样技术 # VolPathIntegrator支持表面散射, 多重波长介质光谱属性以及光源重要性抽样. 采样时若样本距离超过表面相交点, 则可以进行表面散射.\n彩色介质 # 光谱变化介质属性的实现问题主要在于采样, 如果只采用单个波长做重要性抽样, 会降低其余波长的采样效果. 例如采样\\(\\sigma_{\\text{maj}}\\)时, 其余波长下可能会发生更多的空散射. 但如果为每个波长分别积分, 这在时间开销上又是低效的. 同时, 对于前文的路径追踪求解方法, 这会导致有些项无法抵消, 极有可能增大方差.\n多个波长上不同的概率分布可以通过单抽样MIS解决, pbrt使用均匀分布来选择波长概率分布, 由于构造光谱渲染使用的波长时已经完成了概率选择, 这里直接选用第一个波长. 单抽样MIS下平衡启发式是较优的, pbrt直接通过各个分布密度的归一化实现. 单抽样MIS形式如下.\n$$ \\begin{equation} \\begin{aligned} f_\\lambda(x) \u0026amp;=\\frac{p_{\\lambda_1}(x)}{\\frac{1}{n}\\sum_1^n p_{\\lambda_i}(x)}\\frac{\\left[f_{\\lambda_1}(x),f_{\\lambda_2}(x),\\dots,f_{\\lambda_n}(x)\\right]}{p_{\\lambda_1}(x)}\\\\ \u0026amp;=\\frac{\\left[f_{\\lambda_1}(x),f_{\\lambda_2}(x),\\dots,f_{\\lambda_n}(x)\\right]}{\\frac{1}{n}\\sum_1^n p_{\\lambda_i}(x)} \\end{aligned} \\end{equation} $$\n直接光照 # 引入体渲染后, 直接光源与表面间的透射率也需要被考虑进PDF, 因此pbrt对路径追踪与直接光照使用不同的采样技术. 路径追踪采用SimpleVolPathIntegrator使用的差值跟踪, pbrt称之为单向路径采样, PDF用\\(p_u\\)表示. 直接光照则采用比率跟踪获取透射率, 称之为光源路径采样, PDF用\\(p_l\\)表示.\n单向路径采样概率如下, \\(p_s\\)为在\\(p_{n-1}\\)选择散射到并沿\\(\\omega_n\\)传播的概率, \\(p_{\\emptyset}\\)为实散射之间的空散射顶点对应的概率, 最后一项的\\(T_{\\text{maj}}(p_m \\to r_n)\\)代表着所有采样到超过\\(p_n\\)的点的累积概率.\n$$ \\begin{equation} \\begin{aligned} p_u(\\bar{p}_n) \u0026amp;=p_u(\\bar{p}_{n-1})p_s(r_{n-1})p_{\\emptyset}(r_{n-1},r_n)\\\\ \u0026amp;=p_u(\\bar{p}_{n-1})\\frac{\\sigma_s(p_{n-1})}{\\sigma_{\\text{maj}}(p_{n-1})}p_\\omega(r_n|r_{n-1}, \\omega_n)(\\prod_{k=1}^m\\frac{\\sigma_n(p_k)}{\\sigma_{\\text{maj}}(p_k)}\\sigma_{\\text{maj}}(p_k)T_{\\text{maj}}(p_{k-1} \\to p_k))T_{\\text{maj}}(p_m \\to r_n)\\\\ \u0026amp;=p_u(\\bar{p}_{n-1})\\frac{\\sigma_s(p_{n-1})}{\\sigma_{\\text{maj}}(p_{n-1})}p_\\omega(r_n|r_{n-1}, \\omega_n)(\\prod_{k=1}^m\\sigma_n(p_k)T_{\\text{maj}}(p_{k-1} \\to p_k))T_{\\text{maj}}(p_m \\to r_n) \\end{aligned} \\end{equation} $$\n光源路径采样的概率与单向路径采样类似, 由于直接光照下散射点与光源之间不会发生散射, 这里不包含选择折射的概率.\n$$ \\begin{equation} \\begin{aligned} p_l(\\bar{p}_n) \u0026amp;=p_u(\\bar{p}_{n-1})p_s(r_{n-1})p_{\\emptyset}(r_{n-1},r_n)\\\\ \u0026amp;=p_u(\\bar{p}_{n-1})\\frac{\\sigma_s(p_{n-1})}{\\sigma_{\\text{maj}}(p_{n-1})}p_{l,\\omega}(\\omega_n)(\\prod_{k=1}^m\\sigma_{\\text{maj}}(p_k)T_{\\text{maj}}(p_{k-1} \\to p_k))T_{\\text{maj}}(p_m \\to r_n) \\end{aligned} \\end{equation} $$\n与光谱单抽样MIS结合后的结果如下.\n$$ \\begin{equation} \\begin{aligned} \\hat{P}(\\bar{p}_n) \u0026amp;=\\omega_u(\\bar{p}_n)\\frac{\\hat{T}(\\bar{p}_n)L_e(p_n \\to p_{n-1})}{p_{u,\\lambda_1}(\\bar{p}_n)}+\\omega_l(\\bar{p}\u0026rsquo;_n)\\frac{\\hat{T}(\\bar{p}\u0026rsquo;_n)L_e(p\u0026rsquo;_n \\to p\u0026rsquo;_{n-1})}{p_{l,\\lambda_1}(\\bar{p}\u0026rsquo;_n)} \\end{aligned} \\end{equation} $$\n平衡权重如下.\n$$ \\begin{equation} \\begin{aligned} \\omega_u(\\bar{p}_n)=\\frac{p_{u,\\lambda_1}(\\bar{p}_n)}{\\frac{1}{m}\\left(\\sum_{i=1}^m p_{u,\\lambda_i}(\\bar{p}_n)+\\sum_{i=1}^m p_{l,\\lambda_i}(\\bar{p}\u0026rsquo;_n)\\right)}\\\\ \\omega_l(\\bar{p}_n)=\\frac{p_{l,\\lambda_1}(\\bar{p}_n)}{\\frac{1}{m}\\left(\\sum_{i=1}^m p_{u,\\lambda_i}(\\bar{p}_n)+\\sum_{i=1}^m p_{l,\\lambda_i}(\\bar{p}\u0026rsquo;_n)\\right)} \\end{aligned} \\end{equation} $$\n改进的体积积分器 # VolPathIntegrator的成员与PathIntegrator类似, 构造函数只做成员初始化.\nclass VolPathIntegrator : public RayIntegrator { public: // VolPathIntegrator Public Methods // ... private: // VolPathIntegrator Private Methods // ... // VolPathIntegrator Private Members int maxDepth; LightSampler lightSampler; bool regularize; }; 可以看出平衡权重的分子与采样项分母可以抵消, 但这可能会导致\\(\\beta\\)溢出, 例如BSDF采样结果过大, 分母上的PDF可以有效防止溢出. 同样的平衡权重也需要考虑浮点数精度, 因此定义重缩放路径概率.\n$$ \\begin{equation} \\begin{aligned} r_{u,\\lambda_i}(\\bar{p}_n)=\\frac{p_{u,\\lambda_i}(\\bar{p}_n)}{p_{\\text{path}}(\\bar{p}_n)}\\\\ r_{l,\\lambda_i}(\\bar{p}_n)=\\frac{p_{l,\\lambda_i}(\\bar{p}_n)}{p_{\\text{path}}(\\bar{p}_n)}\\\\ \\end{aligned} \\end{equation} $$\n\\(p_{\\text{path}}\\)是采样当前路径的概率, 在单向路径采样中为\\(p_{u,\\lambda_1}\\), 在光源路径采样中为\\(p_{l,\\lambda_1}\\), 因此重缩放后的平衡权重如下. 注意这两项中的\\(p_{\\text{path}}\\)是不同的, 这里只是防止数值误差的手段, 和之前的权重实际上是一致的.\n$$ \\begin{equation} \\begin{aligned} \\omega_u(\\bar{p}_n)=\\frac{1}{\\frac{1}{m}\\left(\\sum_{i=1}^m r_{u,\\lambda_i}(\\bar{p}_n)+\\sum_{i=1}^m r_{l,\\lambda_i}(\\bar{p}\u0026rsquo;_n)\\right)}\\\\ \\omega_l(\\bar{p}_n)=\\frac{1}{\\frac{1}{m}\\left(\\sum_{i=1}^m r_{u,\\lambda_i}(\\bar{p}_n)+\\sum_{i=1}^m r_{l,\\lambda_i}(\\bar{p}\u0026rsquo;_n)\\right)} \\end{aligned} \\end{equation} $$\nVolPathIntegrator中所有采样点都会添加自发光, 因为是Monte Carlo, 所以这只是多统计了一条路径来提高统计效率, 不影响最终结果. 令新添加的路径顶点为\\(p\u0026rsquo;\\), 光照结果如下. 由于MIS, \\(p_{\\text{maj}}\\)中的\\(T_{\\text{maj}}\\)不会再被抵消, 同时由于这条路径始终添加自发光\\(p_e\\)也始终为1.\n$$ \\begin{equation} \\begin{aligned} \\hat{P}(\\left[\\bar{p}_n + p\u0026rsquo;\\right]) \u0026amp;=\\beta(\\left[\\bar{p}_n+p\u0026rsquo;\\right])\\sigma_a(p\u0026rsquo;)L_e(p\u0026rsquo; \\to p_n)\\\\ \u0026amp;=\\frac{\\beta(\\bar{p}_n)T_{\\text{maj}(p_n \\to p\u0026rsquo;)}}{p_e(p\u0026rsquo;)p_{\\text{maj}}(p\u0026rsquo;|p_n,\\omega)}\\sigma_a(p\u0026rsquo;)L_e(p\u0026rsquo; \\to p_n) \\end{aligned} \\end{equation} $$\n由于波长的影响这里同样需要做MIS, MIS权重如下.\n$$ \\begin{equation} \\omega_e(\\left[\\bar{p}_n + p\u0026rsquo;\\right])=\\frac{1}{\\frac{1}{m}\\sum_{i=1}^m r_{e,\\lambda_i}([\\bar{p}_n+p\u0026rsquo;])} \\end{equation} $$\n代码实现如下.\nif (depth \u0026lt; maxDepth \u0026amp;\u0026amp; mp.Le) { // Compute $\\beta\u0026#39;$ at new path vertex Float pdf = sigma_maj[0] * T_maj[0]; SampledSpectrum betap = beta * T_maj / pdf; // Compute rescaled path probability for absorption at path vertex SampledSpectrum r_e = r_u * sigma_maj * T_maj / pdf; // Update _L_ for medium emission if (r_e) L += betap * mp.sigma_a * mp.Le / r_e.Average(); } 之后按照与SimpleVolPathIntegrator一样的方法选择散射事件. 由于自发光已经被统计过, 选择吸收时只停止追踪, 不做其它操作. 这里再次强调一下我的理解, Monte Carlo方法选择某条路径的概率是任意的, 只需要符合实际使用的概率就行, 使用不同的PDF只是方差上有区别, 因此每次统计都选择自发光时概率设置为1没有问题, 这里通过散射事件的概率来选择也没有问题.\nterminated = true; return false; 实散射事件中选择当前顶点概率为\\(\\sigma_{\\text{maj}}(p\u0026rsquo;)T_{\\text{maj}}(p_n \\to p\u0026rsquo;)\\), 选择实散射概率为\\(\\frac{\\sigma_s(p\u0026rsquo;)}{\\sigma_{\\text{maj}}(p\u0026rsquo;)}\\), 这里\\(\\sigma_{\\text{maj}}(p\u0026rsquo;)\\)被抵消. 这里\\(\\beta\\)只更新了与选择顶点相关的部分, 散射部分还没添加, 因此不必在这里纠结.\nFloat pdf = T_maj[0] * mp.sigma_s[0]; beta *= T_maj * mp.sigma_s / pdf; r_u *= T_maj * mp.sigma_s / pdf; 直接光照部分后续再介绍, Li开头是计算了距离最近的表面的距离的, 采样不会超过这个距离, 因此这里还没有接触到表面, 需要使用相位函数. 对于直接光照路径, 它的顶点除光源外与单向路径\\(\\bar{p}_n\\)是相同的, 因此\\(r_l(\\left[\\bar{p}_n \\to p\u0026rsquo;\\right])\\)可以直接从\\(r_u(\\bar{p}_n)\\)中推导出来, 这里除以ps-\u0026gt;pdf是因为MIS使用的\\(p_{\\text{path}}\\)为\\(p_{u,\\lambda_1}\\), 分子上的光源路径概率后续再更新. \\(r_u(\\left[\\bar{p}_n \\to p\\right])\\)不需要更新是因为相位方程与波长无关, 分子分母抵消了.\n// Sample direct lighting at volume-scattering event MediumInteraction intr(p, -ray.d, ray.time, ray.medium, mp.phase); L += SampleLd(intr, nullptr, lambda, sampler, beta, r_u); // Sample new direction at real-scattering event Point2f u = sampler.Get2D(); pstd::optional\u0026lt;PhaseFunctionSample\u0026gt; ps = intr.phase.Sample_p(-ray.d, u); if (!ps || ps-\u0026gt;pdf == 0) terminated = true; else { // Update ray path state for indirect volume scattering beta *= ps-\u0026gt;p / ps-\u0026gt;pdf; r_l = r_u / ps-\u0026gt;pdf; prevIntrContext = LightSampleContext(intr); scattered = true; ray.o = p; ray.d = ps-\u0026gt;wi; specularBounce = false; anyNonSpecularBounces = true; } 空散射事件中概率中的\\(\\sigma_{\\text{maj}}(p\u0026rsquo;)\\)同样被抵消. 光源路径采样认为当前采样是计算与光源之间的透射率, 因此在路径传播过程中不需要选择散射事件, 只需要记录选择顶点的概率, 因此不包含\\(\\frac{\\sigma_n(p\u0026rsquo;)}{\\sigma_{\\text{maj}}(p\u0026rsquo;)}\\), 分母上的pdf同样是因为MIS使用的\\(p_{\\text{path}}\\)为\\(p_{u,\\lambda_1}\\).\nSampledSpectrum sigma_n = ClampZero(sigma_maj - mp.sigma_a - mp.sigma_s); Float pdf = T_maj[0] * sigma_n[0]; beta *= T_maj * sigma_n / pdf; if (pdf == 0) beta = SampledSpectrum(0.f); r_u *= T_maj * sigma_n / pdf; r_l *= T_maj * sigma_maj / pdf; return beta \u0026amp;\u0026amp; r_u; 退出SampleT_maj后, 如路径大于最大深度, 遇到吸收事件, 散射PDF为0或任意一个波长的\\(\\beta\\)或\\(r_u\\)为0, 则返回光照结果. 若遇到散射事件则继续循环.\nif (terminated || !beta || !r_u) return L; if (scattered) continue; 剩下的情况是没有发生任何散射事件或只经历了空散射, 这部分的实现在SampleT_maj中, 因为介质迭代器迭代到末尾而返回当前累计的\\(T_\\text{maj}\\). 没有散射事件则返回值在各个波长上都为\\(1\\), 不影响这些系数; 若只经历空散射则代表光线沿直线从介质起点传播到终点, 最后一个采样点超过了介质最大距离, 根据之前章节的结论, 这种情况概率可以从CDF中获取, 值为\\(T_{\\text{maj}}\\). \\(\\beta\\)分子乘上\\(T_{\\text{maj}}\\)是因为路径通量需要统计透射率, \\(r_u\\)和\\(r_l\\)则是各个波长上超过最大距离的概率.\nbeta *= T_maj / T_maj[0]; r_u *= T_maj / T_maj[0]; r_l *= T_maj / T_maj[0]; 处理与物体表面相交的情况, 此时若已经达到最大深度, 则统计表面自发光后就结束路径追踪.\n// Terminate path if maximum depth reached if (depth++ \u0026gt;= maxDepth) return L; 获取直接光照, 同样使用SampleLd. 与PathIntegrator一样, 由于镜面反射概率分布为Dirac delta分布, 无需统计直接光照.\n// Sample illumination from lights to find attenuated path contribution if (IsNonSpecular(bsdf.Flags())) { L += SampleLd(isect, \u0026amp;bsdf, lambda, sampler, beta, r_u); DCHECK(IsInf(L.y(lambda)) == false); } prevIntrContext = LightSampleContext(isect); 根据BSDF生成追踪路径.\n// Sample BSDF to get new volumetric path direction Vector3f wo = isect.wo; Float u = sampler.Get1D(); pstd::optional\u0026lt;BSDFSample\u0026gt; bs = bsdf.Sample_f(wo, u, sampler.Get2D()); if (!bs) break; 更新\\(\\beta\\)与\\(r_l\\), \\(r_u\\)因为BSDF与波长无关, 并不需要更新. \\(\\beta\\)更新时添加的余弦项可参照泛化路径空间的定义. \\(r_l\\)与之前一样只更新分母上的PDF, pdfIsProportional与某些特殊材质相关, 具体见后续章节.\n// Update _beta_ and rescaled path probabilities for BSDF scattering beta *= bs-\u0026gt;f * AbsDot(bs-\u0026gt;wi, isect.shading.n) / bs-\u0026gt;pdf; if (bs-\u0026gt;pdfIsProportional) r_l = r_u / bsdf.PDF(wo, bs-\u0026gt;wi); else r_l = r_u / bs-\u0026gt;pdf; 俄罗斯轮盘部分与PathIntegrator类似, 在其基础上添加了\\(r_u\\)相关的系数, \\(r_u\\)在各个波长上的均值越小退出概率越小. 猜测这里是因为较小的\\(r_u\\)代表当前使用的波长越重要.\nSampledSpectrum rrBeta = beta * etaScale / r_u.Average(); Float uRR = sampler.Get1D(); PBRT_DBG(\u0026#34;%s\\n\u0026#34;, StringPrintf(\u0026#34;etaScale %f -\u0026gt; rrBeta %s\u0026#34;, etaScale, rrBeta).c_str()); if (rrBeta.MaxComponentValue() \u0026lt; 1 \u0026amp;\u0026amp; depth \u0026gt; 1) { Float q = std::max\u0026lt;Float\u0026gt;(0, 1 - rrBeta.MaxComponentValue()); if (uRR \u0026lt; q) break; beta /= 1 - q; } 估计直接光照 # SampleLd实现直接光照, 与PathIntegrator相比这里需要计算透射率.\n散射点可能是表面或体积, 若为表面则和PathIntegrator一样对交点做偏移, 使得反射时位于面外, 折射时位于面内.\nLightSampleContext ctx; if (bsdf) { ctx = LightSampleContext(intr.AsSurface()); // Try to nudge the light sampling position to correct side of the surface BxDFFlags flags = bsdf-\u0026gt;Flags(); if (IsReflective(flags) \u0026amp;\u0026amp; !IsTransmissive(flags)) ctx.pi = intr.OffsetRayOrigin(intr.wo); else if (IsTransmissive(flags) \u0026amp;\u0026amp; !IsReflective(flags)) ctx.pi = intr.OffsetRayOrigin(-intr.wo); } else ctx = LightSampleContext(intr); 生成随机变量并采样光源, 与PathIntegrator一致.\nFloat u = sampler.Get1D(); pstd::optional\u0026lt;SampledLight\u0026gt; sampledLight = lightSampler.Sample(ctx, u); Point2f uLight = sampler.Get2D(); if (!sampledLight) return SampledSpectrum(0.f); Light light = sampledLight-\u0026gt;light; DCHECK(light \u0026amp;\u0026amp; sampledLight-\u0026gt;p != 0); // Sample a point on the light source pstd::optional\u0026lt;LightLiSample\u0026gt; ls = light.SampleLi(ctx, uLight, lambda, true); if (!ls || !ls-\u0026gt;L || ls-\u0026gt;pdf == 0) return SampledSpectrum(0.f); Float p_l = sampledLight-\u0026gt;p * ls-\u0026gt;pdf; 分别处理BSDF与相位方程. BSDF的计算方式与PathIntegrator一致, 注意这里\\(\\hat{f}\\)把\\(D(p,p\u0026rsquo;)\\)即余弦项包括进去了. \\(\\hat{f}\\)没有包含\\(\\sigma_s\\), 因为已经包括在\\(\\beta\\)中了.\n// Evaluate BSDF or phase function for light sample direction Float scatterPDF; SampledSpectrum f_hat; Vector3f wo = intr.wo, wi = ls-\u0026gt;wi; if (bsdf) { // Update _f_hat_ and _scatterPDF_ accounting for the BSDF f_hat = bsdf-\u0026gt;f(wo, wi) * AbsDot(wi, intr.AsSurface().shading.n); scatterPDF = bsdf-\u0026gt;PDF(wo, wi); } else { // Update _f_hat_ and _scatterPDF_ accounting for the phase function CHECK(intr.IsMediumInteraction()); PhaseFunction phase = intr.AsMedium().phase; f_hat = SampledSpectrum(phase.p(wo, wi)); scatterPDF = phase.PDF(wo, wi); } if (!f_hat) return SampledSpectrum(0.f); SampleLd中会记录单独的\\(r_u\\)与\\(r_l\\), 因为此时\\(p_{\\text{path}}\\)为\\(p_l\\)而非\\(p_u\\).\n// Declare path state variables for ray to light source Ray lightRay = intr.SpawnRayTo(ls-\u0026gt;pLight); SampledSpectrum T_ray(1.f), r_l(1.f), r_u(1.f); RNG rng(Hash(lightRay.o), Hash(lightRay.d)); 首先判断是否与光源相交, 如果在与光源相交前就与物体相交则不产生贡献, SpawnRayTo不会将光线归一化, 因此这里通过1 - ShadowEpsilon保证不会与光源相交. 同时与介质分界面相交也是有可能的, 且介质分界面与光源之间可能还会有物体, 但是此时仍然应该先计算透射率, 例如可能在当前相交的介质里透射率就变为0了.\n// Trace ray through media to estimate transmittance pstd::optional\u0026lt;ShapeIntersection\u0026gt; si = Intersect(lightRay, 1 - ShadowEpsilon); // Handle opaque surface along ray\u0026#39;s path if (si \u0026amp;\u0026amp; si-\u0026gt;intr.material) return SampledSpectrum(0.f); 路径追踪过程中透射率的计算使用比率跟踪. 之前的章节推导出的结论是只在每个空散射顶点记录\\(\\frac{\\sigma_n(p)}{\\sigma_{\\text{maj}}(p)}\\), 这里因为MIS导致的概率不同需要使用完整形式.\n// Update ray transmittance estimate at sampled point // Update _T_ray_ and PDFs using ratio-tracking estimator SampledSpectrum sigma_n = ClampZero(sigma_maj - mp.sigma_a - mp.sigma_s); Float pdf = T_maj[0] * sigma_maj[0]; T_ray *= T_maj * sigma_n / pdf; r_l *= T_maj * sigma_maj / pdf; r_u *= T_maj * sigma_n / pdf; 如果直接根据当前透射率作为俄罗斯轮盘使用的概率, 比率跟踪会转化为差值跟踪, 透射率只能为0或1. pbrt认为这过于激进, 因此只在添加MIS后的透射率过小时执行俄罗斯轮盘.\nSampledSpectrum Tr = T_ray / (r_l + r_u).Average(); if (Tr.MaxComponentValue() \u0026lt; 0.05f) { Float q = 0.75f; if (rng.Uniform\u0026lt;Float\u0026gt;() \u0026lt; q) T_ray = SampledSpectrum(0.); else T_ray /= 1 - q; } 与前文介绍的一样, 超过最大距离时仍然要更新透射率与重缩放路径概率. 按之前章节的定义这里\\(T_r\\)应该乘1, 同样由于MIS之前的推导不再成立.\nT_ray *= T_maj / T_maj[0]; r_l *= T_maj / T_maj[0]; r_u *= T_maj / T_maj[0]; 透射率为0立即返回, 没有相交代表使用的是无限光源且已经离开场景, 若都不满足则生成新的光线继续循环.\nif (!T_ray) return SampledSpectrum(0.f); if (!si) break; lightRay = si-\u0026gt;intr.SpawnRayTo(ls-\u0026gt;pLight); 在发生散射之前\\(r_u\\)和\\(r_l\\)是相等的, 因此这里将这里单独计算的\\(r_u\\)和\\(r_l\\)直接乘上\\(r_{\\text{path}}\\)即可. 理论上这里应该beta = beta / lightPDF; r_l /= lightPDF; r_u /= lightPDF, 由于lightPDF被抵消因此这里省略. 与PathIntegrator一样, Delta光源无法通过散射接触到, 这使得\\(r_u\\)为0, 因此只统计\\(r_l\\).\nr_l *= r_p * lightPDF; r_u *= r_p * scatterPDF; if (IsDeltaLight(light.Type())) return beta * f_hat * T_ray * ls-\u0026gt;L / r_l.Average(); else return beta * f_hat * T_ray * ls-\u0026gt;L / (r_l + r_u).Average(); 与PathIntegrator类似, 散射光线不与场景相交则计算无限光源的光照, 第一次散射或镜面反射不考虑直接光照, 否则根据选择光源以及选择光源相交点的概率添加MIS.\n// Accumulate contributions from infinite light sources for (const auto \u0026amp;light : infiniteLights) { if (SampledSpectrum Le = light.Le(ray, lambda); Le) { if (depth == 0 || specularBounce) L += beta * Le / r_u.Average(); else { // Add infinite light contribution using both PDFs with MIS Float p_l = lightSampler.PMF(prevIntrContext, light) * light.PDF_Li(prevIntrContext, ray.d, true); r_l *= p_l; L += beta * Le / (r_u + r_l).Average(); } } } 若有下一个相交点则处理方式类似, 没有自发光时选择这个光源的概率为0, 无需统计.\nSurfaceInteraction \u0026amp;isect = si-\u0026gt;intr; if (SampledSpectrum Le = isect.Le(-ray.d, lambda); Le) { // Add contribution of emission from intersected surface if (depth == 0 || specularBounce) L += beta * Le / r_u.Average(); else { // Add surface light contribution using both PDFs with MIS Light areaLight(isect.areaLight); Float p_l = lightSampler.PMF(prevIntrContext, areaLight) * areaLight.PDF_Li(prevIntrContext, ray.d, true); r_l *= p_l; L += beta * Le / (r_u + r_l).Average(); } } 分层材质散射 # 在两层具有不同BSDF的表面之间填充介质, 即可形成分层材质, pbrt通过LayeredBxDF定义. 这是之前章节介绍的ThinDielectricBxDF的泛化, 假设光线从同一个点入射与出射, 并添加了中间介质的散射.\n一维辐射转移方程 # 将辐射转移方程转化为只与距离表面的深度有关, 即去除起始点相关参数, 此时辐射转移方程如下. \\(|\\omega_z|\\)是传播方向与表面法线的点积, 改项用于调整不同\\(\\omega\\)下的传播距离.\n$$ \\begin{equation} \\frac{\\partial L_o(z,\\omega)}{\\partial z} = -\\frac{\\sigma_t(z)}{|\\omega_z|}L_i(z,-\\omega)+\\frac{\\sigma_t(z)}{|\\omega_z|}L_s(z,\\omega) \\end{equation} $$\n推导出的\\(L_i\\)如下, \\(z_i\\)为介质交界面的深度. 具体推导过程见辐射转移方程章节.\n$$ \\begin{equation} \\begin{aligned} \u0026amp;L_i(z,\\omega)=T_r(z \\to z_i)L_o(z_i,-\\omega)+\\int_z^{z_i} \\frac{\\sigma_t(z\u0026rsquo;)}{|\\omega_z|}T_r(z \\to z\u0026rsquo;,\\omega)L_s(z\u0026rsquo;,-\\omega)dz\u0026rsquo;\\\\ \u0026amp;T_r(z_0 \\to z_1,\\omega)=e^{-\\int_{z_0}^{z_1}\\frac{\\sigma_t(z\u0026rsquo;)}{|\\cos\\theta|}dz\u0026rsquo;} \\end{aligned} \\end{equation} $$\npbrt认为LayeredBxDF中的\\(\\sigma_t\\)在所有波长上都为常数, 因此不需要空散射.\n分层BxDF # LayeredBxDF的值并不是确定的, pbrt通过定义一个虚拟Delta光源来计算, 在Monte Carlo下这是无偏的.\n$$ \\begin{equation} L_o(\\omega_o)=\\int_\\Omega f(\\omega_o,\\omega)L_i(\\omega)\\cos\\theta d\\omega=\\int_\\Omega f(\\omega_o,\\omega)\\delta(\\omega-\\omega_i)d\\omega=f(\\omega_o,\\omega_i) \\end{equation} $$\nLayeredBxDF允许设置两层BSDF和一种同质介质, 当然这两层BSDF的类型也可以是LayeredBxDF, 以此实现更多层数. pbrt认为\\(\\sigma_t\\)为常数, 不包含自发光, 因此用户通过albedo定义\\(\\sigma_s\\), 同时也可以定义厚度控制光线传播. maxDepth与nSamples是Monte Carlo的相关参数.\ntemplate \u0026lt;typename TopBxDF, typename BottomBxDF, bool twoSided\u0026gt; class LayeredBxDF { public: // LayeredBxDF Public Methods // ... private: // LayeredBxDF Private Methods // ... // LayeredBxDF Private Members TopBxDF top; BottomBxDF bottom; Float thickness, g; SampledSpectrum albedo; int maxDepth, nSamples; }; Tr返回透射率, 基于同质介质的假设.\nstatic Float Tr(Float dz, Vector3f w) { return FastExp(-std::abs(dz / w.z)); } 基于交换两层BSDF的需求, pbrt定义了TopOrBottomBxDF, 赋值时根据参数类型判断是TopBxDF或BottomBxDF.\ntemplate \u0026lt;typename TopBxDF, typename BottomBxDF\u0026gt; class TopOrBottomBxDF { public: // TopOrBottomBxDF Public Methods TopOrBottomBxDF() = default; PBRT_CPU_GPU TopOrBottomBxDF \u0026amp;operator=(const TopBxDF *t) { top = t; bottom = nullptr; return *this; } PBRT_CPU_GPU TopOrBottomBxDF \u0026amp;operator=(const BottomBxDF *b) { bottom = b; top = nullptr; return *this; } PBRT_CPU_GPU SampledSpectrum f(Vector3f wo, Vector3f wi, TransportMode mode) const { return top ? top-\u0026gt;f(wo, wi, mode) : bottom-\u0026gt;f(wo, wi, mode); } // ... private: const TopBxDF *top = nullptr; const BottomBxDF *bottom = nullptr; }; BSDF求解 # BSDF通过多次采样路径求均值获取. 若为单侧材质, 则根据位于内侧或外侧决定接触的材质. 若为双侧材质, 即某个材质被两个相同的材质夹在中间, 则接触的材质是确定的. 在双侧材质时若入射或出射方向指向面内则切换方向, 便于法线参与计算.\n// Set _wo_ and _wi_ for layered BSDF evaluation if (twoSided \u0026amp;\u0026amp; wo.z \u0026lt; 0) { wo = -wo; wi = -wi; } // Determine entrance interface for layered BSDF TopOrBottomBxDF\u0026lt;TopBxDF, BottomBxDF\u0026gt; enterInterface; bool enteredTop = twoSided || wo.z \u0026gt; 0; if (enteredTop) enterInterface = \u0026amp;top; else enterInterface = \u0026amp;bottom; 根据入射与出射方向是否位于同一半球判断出射位置的材质, 同时也会记录非出射退出的材质, 位于同一半球时这个材质上只会发生反射, 否则光线无法出射. 该步同时也确定出射位置的深度.\nTopOrBottomBxDF\u0026lt;TopBxDF, BottomBxDF\u0026gt; exitInterface, nonExitInterface; if (SameHemisphere(wo, wi) ^ enteredTop) { exitInterface = \u0026amp;bottom; nonExitInterface = \u0026amp;top; } else { exitInterface = \u0026amp;top; nonExitInterface = \u0026amp;bottom; } Float exitZ = (SameHemisphere(wo, wi) ^ enteredTop) ? 0 : thickness; 位于同一半球时需要添加入射表面的反射.\n// Account for reflection at the entrance interface if (SameHemisphere(wo, wi)) f = nSamples * enterInterface.f(wo, wi, mode); 其余BSDF都需要通过Monte Carlo获取结果, 所以接口没有提供随机数相关参数, pbrt在LayeredBxDF内部提供相关功能.\nRNG rng(Hash(GetOptions().seed, wo), Hash(wi)); auto r = [\u0026amp;rng]() { return std::min\u0026lt;Float\u0026gt;(rng.Uniform\u0026lt;Float\u0026gt;(), OneMinusEpsilon); }; 光照结果是半球上的积分, 反射已经计算所以只考虑透射, 根据BTDF在入射面采样当前出射光线的入射方向.\nFloat uc = r(); pstd::optional\u0026lt;BSDFSample\u0026gt; wos = enterInterface.Sample_f(wo, uc, Point2f(r(), r()), mode, BxDFReflTransFlags::Transmission); if (!wos || !wos-\u0026gt;f || wos-\u0026gt;pdf == 0 || wos-\u0026gt;wi.z == 0) continue; 根据BSDF/相位方程或虚拟光源进入表面后的折射方向来计算虚拟光源的光照都是可行的, 因此pbrt使用MIS. 注意到这里mode取反, 因为这里光线是从光源发出的, 而非常规的从相机逆向追踪, 因此对不对称散射的处理方式不同, 具体见之前章节的介绍.\nuc = r(); pstd::optional\u0026lt;BSDFSample\u0026gt; wis = exitInterface.Sample_f(wi, uc, Point2f(r(), r()), !mode, BxDFReflTransFlags::Transmission); if (!wis || !wis-\u0026gt;f || wis-\u0026gt;pdf == 0 || wis-\u0026gt;wi.z == 0) continue; 由于逆向追踪的特性这里同样需要记录\\(\\beta\\).\nSampledSpectrum beta = wos-\u0026gt;f * AbsCosTheta(wos-\u0026gt;wi) / wos-\u0026gt;pdf; Float z = enteredTop ? thickness : 0; Vector3f w = wos-\u0026gt;wi; HGPhaseFunction phase(g); LayeredBxDF的俄罗斯轮盘策略相对保守, 因为计算开销较小.\nif (depth \u0026gt; 3 \u0026amp;\u0026amp; beta.MaxComponentValue() \u0026lt; 0.25f) { Float q = std::max\u0026lt;Float\u0026gt;(0, 1 - beta.MaxComponentValue()); if (r() \u0026lt; q) break; beta /= 1 - q; } 如果没有介质散射, 即albedo未定义, 则直接抵达表面. 这对应\\(L_i\\)的非积分项.\nz = (z == thickness) ? 0 : thickness; beta *= Tr(thickness, w); 有介质散射就采用体渲染抽样, 通过Clamp将深度限制在表面内部. 这里对应\\(L_i\\)的积分项, 由于与比率跟踪使用相同的采样方法, 这里不需要选择概率, 具体见比率跟踪的证明. sigma_t应该是albedo, 大概是收敛的比较快bug一直没改.\n// Sample medium scattering for layered BSDF evaluation Float sigma_t = 1; Float dz = SampleExponential(r(), sigma_t / std::abs(w.z)); Float zp = w.z \u0026gt; 0 ? (z + dz) : (z - dz); DCHECK_RARE(1e-5, z == zp); if (z == zp) continue; if (0 \u0026lt; zp \u0026amp;\u0026amp; zp \u0026lt; thickness) { // ... } z = Clamp(zp, 0, thickness); 若采样点位于介质内部, 接下来在顶点根据相位方程以及虚拟光源折射方向执行MIS, 同时更新\\(\\beta\\)与折射方向.\n// Account for scattering through _exitInterface_ using _wis_ Float wt = 1; if (!IsSpecular(exitInterface.Flags())) wt = PowerHeuristic(1, wis-\u0026gt;pdf, 1, phase.PDF(-w, -wis-\u0026gt;wi)); f += beta * albedo * phase.p(-w, -wis-\u0026gt;wi) * wt * Tr(zp - exitZ, wis-\u0026gt;wi) * wis-\u0026gt;f / wis-\u0026gt;pdf; // Sample phase function and update layered path state Point2f u{r(), r()}; pstd::optional\u0026lt;PhaseFunctionSample\u0026gt; ps = phase.Sample_p(-w, u); if (!ps || ps-\u0026gt;pdf == 0 || ps-\u0026gt;wi.z == 0) continue; beta *= albedo * ps-\u0026gt;p / ps-\u0026gt;pdf; w = ps-\u0026gt;wi; z = zp; // Possibly account for scattering through _exitInterface_ if (((z \u0026lt; exitZ \u0026amp;\u0026amp; w.z \u0026gt; 0) || (z \u0026gt; exitZ \u0026amp;\u0026amp; w.z \u0026lt; 0)) \u0026amp;\u0026amp; !IsSpecular(exitInterface.Flags())) { // Account for scattering through _exitInterface_ SampledSpectrum fExit = exitInterface.f(-w, wi, mode); if (fExit) { Float exitPDF = exitInterface.PDF( -w, wi, mode, BxDFReflTransFlags::Transmission); Float wt = PowerHeuristic(1, ps-\u0026gt;pdf, 1, exitPDF); f += beta * Tr(zp - exitZ, ps-\u0026gt;wi) * fExit * wt; } } 若到达出射表面, 由于上一个顶点已经计算了与出射表面相交并接触虚拟光源的概率, 这里只统计反射. 若到达非出射表面, 则处理方式与介质内部散射点类似, 使用BSDF做MIS, 这里忽略这部分代码.\nFloat uc = r(); pstd::optional\u0026lt;BSDFSample\u0026gt; bs = exitInterface.Sample_f( -w, uc, Point2f(r(), r()), mode, BxDFReflTransFlags::Reflection); if (!bs || !bs-\u0026gt;f || bs-\u0026gt;pdf == 0 || bs-\u0026gt;wi.z == 0) break; beta *= bs-\u0026gt;f * AbsCosTheta(bs-\u0026gt;wi) / bs-\u0026gt;pdf; w = bs-\u0026gt;wi; BSDF采样 # Sample_f通过不断采样路径直到到达出射表面来实现, 此时\\(\\beta\\)与路径PDF的比值和BSDF与当前入射方向对应PDF的比值相等, 因此Sample_f返回前者, 这里不做证明. 显然这里返回的PDF无法用于MIS, 需要调用PDF获取.\nPDF求解 # 令底部表面BRDF为\\(f^-_r\\), 顶部表面BRDF为\\(f^+_r\\), BTDF为\\(f^+_t\\), 此时PDF形式如下, 代表无限次的反射与折射. 由于该PDF只会被MIS使用, 因此只随机统计第二项且内部散射不再统计.\n$$ \\begin{equation} p(\\omega_o,\\omega_i)=p^+_r(\\omega_o,\\omega_i)+\\int_\\Theta\\int_\\Theta p^+_t(\\omega_o,\\omega\u0026rsquo;)p^-_r(-\\omega\u0026rsquo;,\\omega\u0026rsquo;\u0026rsquo;)p^+_t(-\\omega\u0026rsquo;\u0026rsquo;,\\omega_i)d\\omega\u0026rsquo;d\\omega\u0026rsquo;\u0026rsquo;+\\cdots \\end{equation} $$\n为保证与f中的随机采样不相关, 这里使用不同的hash.\nRNG rng(Hash(GetOptions().seed, wi), Hash(wo)); auto r = [\u0026amp;rng]() { return std::min\u0026lt;Float\u0026gt;(rng.Uniform\u0026lt;Float\u0026gt;(), OneMinusEpsilon); }; 若入射/出射方向位于同侧, 估计结果的第一项可以直接给出.\nbool enteredTop = twoSided || wo.z \u0026gt; 0; Float pdfSum = 0; if (SameHemisphere(wo, wi)) { auto reflFlag = BxDFReflTransFlags::Reflection; pdfSum += enteredTop ? nSamples * top.PDF(wo, wi, mode, reflFlag) : nSamples * bottom.PDF(wo, wi, mode, reflFlag); } 位于同侧时随机统计的光线传播为TRT, pbrt使用两种采样策略进行MIS, 第一种为分别根据入射/出射方向采样相邻的内部传播方向, 第二种为根据出射方向采样相邻的内部传播方向, 然后根据该方向采样与入射方向相邻的内部传播方向. MIS化简后的表达式如下, 由于采样结果与采样概率相等很多项都可以抵消.\n$$ \\begin{equation} p(\\omega_o,\\omega_i)\\approx w(\\omega_1\u0026rsquo;\u0026rsquo;)p^-_r(-\\omega\u0026rsquo;,\\omega_1\u0026rsquo;\u0026rsquo;)+w(\\omega_2\u0026rsquo;\u0026rsquo;)p^+_t(-\\omega_2\u0026rsquo;\u0026rsquo;,\\omega_i) \\end{equation} $$\n两种采样方式都需要用到wos, wis只应用在第一种.\nauto trans = BxDFReflTransFlags::Transmission; pstd::optional\u0026lt;BSDFSample\u0026gt; wos, wis; wos = tInterface.Sample_f(wo, r(), {r(), r()}, mode, trans); wis = tInterface.Sample_f(wi, r(), {r(), r()}, !mode, trans); tInterface为镜面反射时wos与wis的采样结果是确定的, 不做MIS.\nif (!IsNonSpecular(tInterface.Flags())) pdfSum += rInterface.PDF(-wos-\u0026gt;wi, -wis-\u0026gt;wi, mode); tInterface不为镜面反射时获取rInterface的采样结果.\npstd::optional\u0026lt;BSDFSample\u0026gt; rs = rInterface.Sample_f(-wos-\u0026gt;wi, r(), {r(), r()}, mode); 若rInterface为镜面反射rs采样结果确定, 同样不采用MIS.\nif (!IsNonSpecular(rInterface.Flags())) pdfSum += tInterface.PDF(-rs-\u0026gt;wi, wi, mode); 两个平面都为非镜面反射时应用MIS.\n// Compute MIS-weighted estimate of Equation // (\\ref{eq:pdf-triple-canceled-one}) Float rPDF = rInterface.PDF(-wos-\u0026gt;wi, -wis-\u0026gt;wi, mode); Float wt = PowerHeuristic(1, wis-\u0026gt;pdf, 1, rPDF); pdfSum += wt * rPDF; Float tPDF = tInterface.PDF(-rs-\u0026gt;wi, wi, mode); wt = PowerHeuristic(1, rs-\u0026gt;pdf, 1, tPDF); pdfSum += wt * tPDF; 入射/出射方向不在同一半球时的光线传播为TT, 与TRT的实现类似.\n高次项与散射通过均匀分布来估计, 与统计项混合得到估计结果.\nreturn Lerp(0.9f, 1 / (4 * Pi), pdfSum / nSamples); 涂层漫反射与涂层导体材质 # 在漫反射或导体材质表面添加一层绝缘体可以更好的模拟某些材质, pbrt通过CoatedDiffuseBxDF与CoatedConductorBxDF实现, 实现方式与LayeredBxDF类似.\n// CoatedDiffuseBxDF Definition class CoatedDiffuseBxDF : public LayeredBxDF\u0026lt;DielectricBxDF, DiffuseBxDF, true\u0026gt; { public: // CoatedDiffuseBxDF Public Methods using LayeredBxDF::LayeredBxDF; PBRT_CPU_GPU static constexpr const char *Name() { return \u0026#34;CoatedDiffuseBxDF\u0026#34;; } }; // CoatedConductorBxDF Definition class CoatedConductorBxDF : public LayeredBxDF\u0026lt;DielectricBxDF, ConductorBxDF, true\u0026gt; { public: // CoatedConductorBxDF Public Methods PBRT_CPU_GPU static constexpr const char *Name() { return \u0026#34;CoatedConductorBxDF\u0026#34;; } using LayeredBxDF::LayeredBxDF; }; ","date":"2025 January 21","externalUrl":null,"permalink":"/render/1737459715051-pbrt-v4-episode-14/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. XIV: 光线传播: 体渲染","type":"render"},{"content":" 光线传播方程 # 光线传播方程(light transport equation, LTE)描述场景中的辐亮度分布. 本章不考虑介质, 下一章再介绍.\n基础推导 # pbrt中的LTE不考虑波动光学, 并认为场景中的辐亮度分布是守恒的. LTE的核心是能量守恒, 离开系统与进入系统的能量的差值和发出与吸收的能量的差值是相等的. 令\\(t(p,\\omega)\\)为光线投射方程, 代表从\\(p\\)点出发方向为\\(\\omega\\)的光线的第一个相交点, 此时空间中任意一点的辐亮度可以按如下方式表示.\n$$ \\begin{equation} L(p,\\omega_o)=L_e(p,\\omega_o)+\\int_\\Theta f(p,\\omega_o,\\omega_i)L(t(p,\\omega_i),-\\omega_i)|\\cos\\theta_i| d\\omega_i \\end{equation} $$\nLTE解析式 # 只有较为简单的LTE才具有解析形式, 例如场景中辐亮度处处相等, 且表面都为Lambertian BRDF.\nLTE表面形式 # LTE的复杂度部分原因为光线投射方程只能隐式表达场景中几何物体的关系, pbrt通过过将LTE的积分转为面积上的积分来显示表达几何物体的分布. 令\\(L(p\u0026rsquo; \\to p)=L(p\u0026rsquo;,\\omega)\\), \\(f(p\u0026rsquo;\u0026rsquo; \\to p\u0026rsquo; \\to p)=f(p\u0026rsquo;,\\omega_o,\\omega_i)\\), 根据立体角转面积的Jacobian行列式, 可以得到如下LTE. 其中\\(V\\)为可见性方程, 两点互相可见为1, 否则为0, 这可以通过追踪光线获取, \\(G\\)为几何方程.\n$$ \\begin{equation} \\begin{aligned} L(p\u0026rsquo; \\to p) \u0026amp;=L_e(p\u0026rsquo; \\to p) + \\int_A f(p\u0026rsquo;\u0026rsquo; \\to p\u0026rsquo; \\to p)L(p\u0026rsquo;\u0026rsquo; \\to p\u0026rsquo;)V(p \\longleftrightarrow p\u0026rsquo;)\\frac{|\\cos\\theta||\\cos\\theta\u0026rsquo;|}{\\Vert p-p\u0026rsquo; \\Vert^2}dA(p\u0026rsquo;\u0026rsquo;)\\\\ \u0026amp;=L_e(p\u0026rsquo; \\to p) + \\int_A f(p\u0026rsquo;\u0026rsquo; \\to p\u0026rsquo; \\to p)L(p\u0026rsquo;\u0026rsquo; \\to p\u0026rsquo;)G(p \\longleftrightarrow p\u0026rsquo;)dA(p\u0026rsquo;\u0026rsquo;)\\\\ \\end{aligned} \\end{equation} $$\n路径空间积分 # \\(p_0\\)为相机位置, 所有具有\\(n+1\\)个顶点的光线传播路径的积分如下, T为路径通量.\n$$ \\begin{equation} \\begin{aligned} P(\\bar{p}_n) \u0026amp;=\\underbrace{\\int_A\\int_A\\cdots\\int_A}_{n} L_e(p_n \\to p_{n-1})(\\prod_{i=1}^{n-1} f(p_{i+1} \\to p_i \\to p_{i-1})G(p_{i+1} \\longleftrightarrow p_i))dA(p_1) \\cdots dA(p_n)\\\\ \u0026amp;=\\underbrace{\\int_A\\int_A\\cdots\\int_A}_{n} L_e(p_n \\to p_{n-1})T(\\bar{p}_n)dA(p_1) \\cdots dA(p_n) \\end{aligned} \\end{equation} $$\n此时路径追踪的统计结果如下.\n$$ \\begin{equation} L(p_0) \\approx \\sum_{n=1}^\\infty \\frac{P(\\bar{p}_n)}{p(\\bar{p}_n)} \\end{equation} $$\n被积函数中的Delta分布 # 部分光源的BSDF是Delta分布, 此时可以将积分转为解析式.\n被积函数分解 # 分解后的积分可以根据对渲染结果的影响使用不同精度的积分方法, 例如直接光照与间接光照的分解, 小光源与大光源的分解, 以及BSDF中Delta项与非Delta项的分解.\n路径追踪 # 路径追踪(path tracing)与Kajiya渲染方程在同一篇论文中被提出, pbrt将使用路径积分形式.\n概述 # 由于能量守恒, 反射次数越多的光线散射的光线越少, 通过在路径的每个顶点执行俄罗斯轮盘可以有效的执行这一过程.\n路径采样 # 根据物体的面积分配概率, 然后采样多个点形成光路, 显然这样采样出的路径极有可能由于遮挡等原因而无效, 方差较高.\n增量路径构造 # 在每次到达顶点时根据BSDF选择下一个顶点所在的方向可以有效的构造光线路径, 其形式如下. 注意到由于光线已经沿着之前的路径传播到当前点, 因此都是可见的, 不需要再加上可见性方程.\n$$ \\begin{equation} P(\\bar{p}_i)\\approx\\frac{L_e(p_i \\to p_{i-1})f(p_i \\to p_{i-1} \\to p_{i-2})G(p_i \\longleftrightarrow p_{i-1})}{p_e(p_i)}(\\prod_{j=1}^{i-2}\\frac{f(p_{j+1} \\to p_j \\to p_{j-1})|\\cos\\theta_j|}{p_\\omega(\\omega_j)}) \\end{equation} $$\n简单路径积分器 # SimplePathIntegrator定义如下, maxDepth设置最大路径顶点数, 若sampleLights和sampleBSDF为true则会根据它们的概率分布来采样.\nclass SimplePathIntegrator : public RayIntegrator { public: // SimplePathIntegrator Public Methods SimplePathIntegrator(int maxDepth, bool sampleLights, bool sampleBSDF, Camera camera, Sampler sampler, Primitive aggregate, std::vector\u0026lt;Light\u0026gt; lights); SampledSpectrum Li(RayDifferential ray, SampledWavelengths \u0026amp;lambda, Sampler sampler, ScratchBuffer \u0026amp;scratchBuffer, VisibleSurface *visibleSurface) const; static std::unique_ptr\u0026lt;SimplePathIntegrator\u0026gt; Create( const ParameterDictionary \u0026amp;parameters, Camera camera, Sampler sampler, Primitive aggregate, std::vector\u0026lt;Light\u0026gt; lights, const FileLoc *loc); std::string ToString() const; private: // SimplePathIntegrator Private Members int maxDepth; bool sampleLights, sampleBSDF; UniformLightSampler lightSampler; }; 路径传播过程中会记录路径通量权重, 每次到达新顶点都会更新, 其定义如下. \\(\\beta\\)中包含了历史顶点的信息, 因此只有当前顶点的状态需要被记录.\n$$ \\begin{equation} \\beta = \\prod_{j=1}^{i-2}\\frac{f(p_{j+1} \\to p_j \\to p_{j-1})|\\cos\\theta_j|}{p_\\omega(\\omega_j)} \\end{equation} $$\n判断光线是否与物体相交.\n// Find next _SimplePathIntegrator_ vertex and accumulate contribution // Intersect _ray_ with scene pstd::optional\u0026lt;ShapeIntersection\u0026gt; si = Intersect(ray); 若不采样光线, pbrt不会计算直接光照, 只会在光线刚好与光源相交时添加光照. 没有与表面相交时获取环境光源, 否则获取表面的自发光. 注意到这里会考虑上一个相交点是镜面反射的情况, 因为此时光线的传播路径是确定的, 无法采样光源.\n// Account for infinite lights if ray has no intersection if (!si) { if (!sampleLights || specularBounce) for (const auto \u0026amp;light : infiniteLights) L += beta * light.Le(ray, lambda); break; } // Account for emissive surface if light was not sampled SurfaceInteraction \u0026amp;isect = si-\u0026gt;intr; if (!sampleLights || specularBounce) L += beta * isect.Le(-ray.d, lambda); 相交判断完成后会根据maxDepth决定是否退出路径追踪.\n// End path if maximum depth reached if (depth++ == maxDepth) break; 若得到了未设置的BSDF, 这代表与介质分界面相交, 光线应该按照当前路径继续传播.\n// Get BSDF and skip over medium boundaries BSDF bsdf = isect.GetBSDF(ray, lambda, camera, scratchBuffer, sampler); if (!bsdf) { specularBounce = true; isect.SkipIntersection(\u0026amp;ray, si-\u0026gt;tHit); continue; } 若sampleLights为true, 此时摄像机接收到的直接光照的表达式如下, \\(p_l(\\omega_i)\\)为当前光源采样到当前入射方向的概率, \\(p(l)\\)为积分器采样到当前光源的概率.\n$$ \\begin{equation} P(\\bar{p}_i)=\\frac{L_e(p_i \\to p_{i-1})f(p_i \\to p_{i-1} \\to p_{i-2})|\\cos\\theta_i|V(p_i \\longleftrightarrow p_{i-1})}{p_l(\\omega_i)p(l)}\\beta \\end{equation} $$\n直接光源的采样过程如下, 通过Unoccluded判断光源是否被遮挡.\n// Sample direct illumination if _sampleLights_ is true Vector3f wo = -ray.d; if (sampleLights) { pstd::optional\u0026lt;SampledLight\u0026gt; sampledLight = lightSampler.Sample(sampler.Get1D()); if (sampledLight) { // Sample point on _sampledLight_ to estimate direct illumination Point2f uLight = sampler.Get2D(); pstd::optional\u0026lt;LightLiSample\u0026gt; ls = sampledLight-\u0026gt;light.SampleLi(isect, uLight, lambda); if (ls \u0026amp;\u0026amp; ls-\u0026gt;L \u0026amp;\u0026amp; ls-\u0026gt;pdf \u0026gt; 0) { // Evaluate BSDF for light and possibly add scattered radiance Vector3f wi = ls-\u0026gt;wi; SampledSpectrum f = bsdf.f(wo, wi) * AbsDot(wi, isect.shading.n); if (f \u0026amp;\u0026amp; Unoccluded(isect, ls-\u0026gt;pLight)) L += beta * f * ls-\u0026gt;L / (sampledLight-\u0026gt;p * ls-\u0026gt;pdf); } } } 若sampleBSDF为true则采样BSDF.\n// Sample BSDF for new path direction Float u = sampler.Get1D(); pstd::optional\u0026lt;BSDFSample\u0026gt; bs = bsdf.Sample_f(wo, u, sampler.Get2D()); if (!bs) break; beta *= bs-\u0026gt;f * AbsDot(bs-\u0026gt;wi, isect.shading.n) / bs-\u0026gt;pdf; specularBounce = bs-\u0026gt;IsSpecular(); ray = isect.SpawnRay(bs-\u0026gt;wi); 否则均匀采样入射方向, 保证不折射的表面不会采样到朝向表面内侧的方向.\n// Uniformly sample sphere or hemisphere to get new path direction Float pdf; Vector3f wi; BxDFFlags flags = bsdf.Flags(); if (IsReflective(flags) \u0026amp;\u0026amp; IsTransmissive(flags)) { wi = SampleUniformSphere(sampler.Get2D()); pdf = UniformSpherePDF(); } else { wi = SampleUniformHemisphere(sampler.Get2D()); pdf = UniformHemispherePDF(); if (IsReflective(flags) \u0026amp;\u0026amp; Dot(wo, isect.n) * Dot(wi, isect.n) \u0026lt; 0) wi = -wi; else if (IsTransmissive(flags) \u0026amp;\u0026amp; Dot(wo, isect.n) * Dot(wi, isect.n) \u0026gt; 0) wi = -wi; } beta *= bsdf.f(wo, wi) * AbsDot(wi, isect.shading.n) / pdf; specularBounce = false; ray = isect.SpawnRay(wi); 路径积分器 # PathIntegrator中使用了更多的优化算法, 例如直接光照的MIS, 光源采样使用BVHLightSampler, 俄罗斯轮盘停止光线传播, 以及路径正则化等算法.\n由于根据BSDF采样传播方向可能导致无法与光源相交, 根据光源采样的直接光照似乎效率更高. 但这也有例外, 例如对于光滑表面可能有效的传播方向只有很小的一个范围, 光源不一定在这个范围中, 或者位于一个PDF很小的方向, 这会导致较大的方差. 这种有多种采样方式且不同情况下它们的效率不同的情况, 需要使用之前章节介绍的MIS, 其形式如下.\n$$ \\begin{equation} \\begin{aligned} P(\\bar{p}_i)\\approx \u0026amp;w_l(\\omega_l)\\frac{L_e(p_l \\to p_{i-1})f(p_l \\to p_{i-1} \\to p_{i-2})|\\cos\\theta_l|V(p_l \\longleftrightarrow p_{i-1})}{p_l(\\omega_l)}\\beta +\\\\ \u0026amp;w_b(\\omega_b)\\frac{L_e(p_b \\to p_{i-1})f(p_b \\to p_{i-1} \\to p_{i-2})|\\cos\\theta_l|V(p_b \\longleftrightarrow p_{i-1})}{p_b(\\omega_b)}\\beta \\end{aligned} \\end{equation} $$\nPathIntegrator定义如下, 可见与SimplePathIntegrator相比这里不再支持关闭直接光照与BSDF采样, lightSampler可以为任意类型, 支持通过regularize设置路径正则化.\nclass PathIntegrator : public RayIntegrator { public: // PathIntegrator Public Methods PathIntegrator(int maxDepth, Camera camera, Sampler sampler, Primitive aggregate, std::vector\u0026lt;Light\u0026gt; lights, const std::string \u0026amp;lightSampleStrategy = \u0026#34;bvh\u0026#34;, bool regularize = false); SampledSpectrum Li(RayDifferential ray, SampledWavelengths \u0026amp;lambda, Sampler sampler, ScratchBuffer \u0026amp;scratchBuffer, VisibleSurface *visibleSurface) const; static std::unique_ptr\u0026lt;PathIntegrator\u0026gt; Create(const ParameterDictionary \u0026amp;parameters, Camera camera, Sampler sampler, Primitive aggregate, std::vector\u0026lt;Light\u0026gt; lights, const FileLoc *loc); std::string ToString() const; private: // PathIntegrator Private Methods SampledSpectrum SampleLd(const SurfaceInteraction \u0026amp;intr, const BSDF *bsdf, SampledWavelengths \u0026amp;lambda, Sampler sampler) const; // PathIntegrator Private Members int maxDepth; LightSampler lightSampler; bool regularize; }; 若Film需要VisibleSurface, 在第一次相交时pbrt会提供其信息, 通过Owen扰动的Halton样本生成低差异性序列以计算半球-方向反射量, 即反照率, 这会用于图像空间降噪.\n// Initialize _visibleSurf_ at first intersection if (depth == 0 \u0026amp;\u0026amp; visibleSurf) { // Estimate BSDF\u0026#39;s albedo // Define sample arrays _ucRho_ and _uRho_ for reflectance estimate constexpr int nRhoSamples = 16; const Float ucRho[nRhoSamples] = { 0.75741637, 0.37870818, 0.7083487, 0.18935409, 0.9149363, 0.35417435, 0.5990858, 0.09467703, 0.8578725, 0.45746812, 0.686759, 0.17708716, 0.9674518, 0.2995429, 0.5083201, 0.047338516}; const Point2f uRho[nRhoSamples] = { Point2f(0.855985, 0.570367), Point2f(0.381823, 0.851844), Point2f(0.285328, 0.764262), Point2f(0.733380, 0.114073), Point2f(0.542663, 0.344465), Point2f(0.127274, 0.414848), Point2f(0.964700, 0.947162), Point2f(0.594089, 0.643463), Point2f(0.095109, 0.170369), Point2f(0.825444, 0.263359), Point2f(0.429467, 0.454469), Point2f(0.244460, 0.816459), Point2f(0.756135, 0.731258), Point2f(0.516165, 0.152852), Point2f(0.180888, 0.214174), Point2f(0.898579, 0.503897)}; SampledSpectrum albedo = bsdf.rho(isect.wo, ucRho, uRho); *visibleSurf = VisibleSurface(isect, albedo, lambda); } SampleLd负责直接光照的采样, 若为镜面反射采样则不需要采样光源.\n// Sample direct illumination from the light sources if (IsNonSpecular(bsdf.Flags())) { ++totalPaths; SampledSpectrum Ld = SampleLd(isect, \u0026amp;bsdf, lambda, sampler); if (!Ld) ++zeroRadiancePaths; L += beta * Ld; } SampleLd时, 若表面为纯反射或折射表面, 计算入射光线的参考点会做相应的偏移, 使得反射时位于面外, 折射时位于面内.\nif (IsReflective(flags) \u0026amp;\u0026amp; !IsTransmissive(flags)) ctx.pi = intr.OffsetRayOrigin(intr.wo); else if (IsTransmissive(flags) \u0026amp;\u0026amp; !IsReflective(flags)) ctx.pi = intr.OffsetRayOrigin(-intr.wo); 通过sampler生成采样光源与入射方向所需的随机变量.\nFloat u = sampler.Get1D(); pstd::optional\u0026lt;SampledLight\u0026gt; sampledLight = lightSampler.Sample(ctx, u); Point2f uLight = sampler.Get2D(); if (!sampledLight) return {}; 跳过无效以及被遮挡的光源.\n// Sample a point on the light source for direct lighting Light light = sampledLight-\u0026gt;light; DCHECK(light \u0026amp;\u0026amp; sampledLight-\u0026gt;p \u0026gt; 0); pstd::optional\u0026lt;LightLiSample\u0026gt; ls = light.SampleLi(ctx, uLight, lambda, true); if (!ls || !ls-\u0026gt;L || ls-\u0026gt;pdf == 0) return {}; // Evaluate BSDF for light sample and check light visibility Vector3f wo = intr.wo, wi = ls-\u0026gt;wi; SampledSpectrum f = bsdf-\u0026gt;f(wo, wi) * AbsDot(wi, intr.shading.n); if (!f || !Unoccluded(intr, ls-\u0026gt;pLight)) return {}; pbrt假设散射光线不可能接触到Delta光源, 因此BSDF的MIS权重为0, 直接光照的MIS权重为1, 否则计算幂启发式.\nFloat p_l = sampledLight-\u0026gt;p * ls-\u0026gt;pdf; if (IsDeltaLight(light.Type())) return ls-\u0026gt;L * f / p_l; else { Float p_b = bsdf-\u0026gt;PDF(wo, wi); Float w_l = PowerHeuristic(1, p_l, 1, p_b); return w_l * ls-\u0026gt;L * f / p_l; } 直接光照完成后采样BSDF并生成路径, etaScale为在折射时由于两侧介质不同导致BTDF需要缩放, 反射模型章节有介绍.\n// Sample BSDF to get new path direction Vector3f wo = -ray.d; Float u = sampler.Get1D(); pstd::optional\u0026lt;BSDFSample\u0026gt; bs = bsdf.Sample_f(wo, u, sampler.Get2D()); if (!bs) break; // Update path state variables after surface scattering beta *= bs-\u0026gt;f * AbsDot(bs-\u0026gt;wi, isect.shading.n) / bs-\u0026gt;pdf; p_b = bs-\u0026gt;pdfIsProportional ? bsdf.PDF(wo, bs-\u0026gt;wi) : bs-\u0026gt;pdf; DCHECK(!IsInf(beta.y(lambda))); specularBounce = bs-\u0026gt;IsSpecular(); anyNonSpecularBounces |= !bs-\u0026gt;IsSpecular(); if (bs-\u0026gt;IsTransmission()) etaScale *= Sqr(bs-\u0026gt;eta); prevIntrCtx = si-\u0026gt;intr; ray = isect.SpawnRay(ray, bsdf, bs-\u0026gt;wi, bs-\u0026gt;flags, bs-\u0026gt;eta); 相交时若相交失败则使用环境光, 否则使用相交表面的自发光. 第一次相交或镜面反射的情况选择直接光照概率为0, 因此直接光照MIS权重为0, BSDF的MIS权重为1. 其余情况则加上BSDF采样对应的MIS权重.\n// Trace ray and find closest path vertex and its BSDF pstd::optional\u0026lt;ShapeIntersection\u0026gt; si = Intersect(ray); // Add emitted light at intersection point or from the environment if (!si) { // Incorporate emission from infinite lights for escaped ray for (const auto \u0026amp;light : infiniteLights) { SampledSpectrum Le = light.Le(ray, lambda); if (depth == 0 || specularBounce) L += beta * Le; else { // Compute MIS weight for infinite light Float p_l = lightSampler.PMF(prevIntrCtx, light) * light.PDF_Li(prevIntrCtx, ray.d, true); Float w_b = PowerHeuristic(1, p_b, 1, p_l); L += beta * w_b * Le; } } break; } // Incorporate emission from surface hit by ray SampledSpectrum Le = si-\u0026gt;intr.Le(-ray.d, lambda); if (Le) { if (depth == 0 || specularBounce) L += beta * Le; else { // Compute MIS weight for area light Light areaLight(si-\u0026gt;intr.areaLight); Float p_l = lightSampler.PMF(prevIntrCtx, areaLight) * areaLight.PDF_Li(prevIntrCtx, ray.d, true); Float w_l = PowerHeuristic(1, p_b, 1, p_l); L += beta * w_l * Le; } } 俄罗斯轮盘的概率选择方式会极大的影响渲染效果, pbrt会将路径通量权重作为俄罗斯轮盘的概率, 同时通过etaScale抵消折射对\\(\\beta\\)的影响, 因为如果光线进入物体后又从当前介质中离开, 折射导致的\\(\\beta\\)的减小会由于连续的介质变化而被抵消, 如果由于折射导致\\(\\beta\\)过小很难再次离开物体会影响渲染效果. 同时pbrt会选用采样波长中的最大\\(\\beta\\), 在高饱和度即部分波长的\\(\\beta\\)远小于其他波长的\\(\\beta\\)的情况下, 这可以有效阻止由于俄罗斯轮盘导致某一个波长的\\(\\beta\\)大于\\(1\\), 因为如果采用平均值而非最大值的话无法判断\\(\\beta\\)的某一项大于\\(1\\).\n// Possibly terminate the path with Russian roulette SampledSpectrum rrBeta = beta * etaScale; if (rrBeta.MaxComponentValue() \u0026lt; 1 \u0026amp;\u0026amp; depth \u0026gt; 1) { Float q = std::max\u0026lt;Float\u0026gt;(0, 1 - rrBeta.MaxComponentValue()); if (sampler.Get1D() \u0026lt; q) break; beta /= 1 - q; DCHECK(!IsInf(beta.y(lambda))); } 路径正则化 # 若间接光照时相交的光源占据较小的立体角, 这会导致PDF过小从而增加方差. 模糊路径上的所有BSDF可以解决该问题, 但也会使得渲染出的场景整体更加粗糙. pbrt只在路径中出现非镜面反射时进行正则化.\nif (regularize \u0026amp;\u0026amp; anyNonSpecularBounces) bsdf.Regularize(); 对于DiffuseBxDF等足够粗糙的BSDF, 正则化是不需要的, 而其他的DieletricBxDF和ConductorBxDF等情况都有可能出现接近镜面反射的情况, 这通过修改TrowbridgeRetizDistribution的粗糙度来实现.\nvoid Regularize() { if (alpha_x \u0026lt; 0.3f) alpha_x = Clamp(2 * alpha_x, 0.1f, 0.3f); if (alpha_y \u0026lt; 0.3f) alpha_y = Clamp(2 * alpha_y, 0.1f, 0.3f); } ","date":"2025 January 18","externalUrl":null,"permalink":"/render/1737167330564-pbrt-v4-episode-13/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. XIII: 光线传播: 表面反射","type":"render"},{"content":" pbrt中不实现无法参与几何光学的光源, 例如只照亮某些物体的光源. 为提高效率, pbrt会根据概率选择光源.\n光源接口 # pbrt中光源通过Light定义.\nclass Light : public TaggedPointer\u0026lt; // Light Source Types PointLight, DistantLight, ProjectionLight, GoniometricLight, SpotLight, DiffuseAreaLight, UniformInfiniteLight, ImageInfiniteLight, PortalImageInfiniteLight \u0026gt; { public: // Light Interface // ... }; 光源需要通过Phi返回其功率(辐射通量)\\(\\phi\\), 这便于通过功率大小采样光源.\nSampledSpectrum Phi(SampledWavelengths lambda) const; 考虑到处理上的便捷性, 光源牺牲了一定的抽象, 通过Type返回类型.\nLightType Type() const; DeltaPosition代表光源只从一个位置发光, 这个名字来自于Dirac delta分布. DeltaDirection代表只向一个方向发光. Area是面积光源, 通过几何形状决定发光区域. Infinite代表无限远的光源, 例如太阳.\nenum class LightType { DeltaPosition, DeltaDirection, Area, Infinite }; 直接采样有光源的方向可以极大的提高效率. 若光源只能从部分方向照亮表面, 直接采用BSDF的分布采样是低效的, 需要根据光源的分布采样. pbrt中这通过SampleLi实现, 若当前点可以被照亮就返回光源信息与PDF. allowIncompletePDF用于跳过PDF较小的样本, 用于MIS补偿.\npstd::optional\u0026lt;LightLiSample\u0026gt; SampleLi(LightSampleContext ctx, Point2f u, SampledWavelengths lambda, bool allowIncompletePDF = false) const; LightSampleContext只存储位置, 表面法线与着色法线.\nclass LightSampleContext { public: // LightSampleContext Public Methods // ... // LightSampleContext Public Members Point3fi pi; Normal3f n, ns; }; LightLiSample结构如下. 根据之前章节介绍的内容, 若为Dirac delta分布且采样到光源, 返回的PDF为1, 因为delta项被抵消了.\nstruct LightLiSample { // LightLiSample Public Methods // ... SampledSpectrum L; Vector3f wi; Float pdf; Interaction pLight; }; L返回当某条光线与面积光源相交时, 它从相交点获取的辐亮度. 只有面积光源可以调用该接口.\nSampledSpectrum L(Point3f p, Normal3f n, Point2f uv, Vector3f w, const SampledWavelengths \u0026amp;lambda) const; Le使得没有与任何物体相交的光线可以获取无限距离光源的辐亮度, 同样只有该类型的光源可以调用.\nSampledSpectrum Le(const Ray \u0026amp;ray, const SampledWavelengths \u0026amp;lambda) const; SampleLe与PDF_Le用于从光源发射光线时的采样.\n光度光源标准 # pbrt允许指定光度单位并负责转为辐射单位.\nLightBase类 # LightBase中的mediumInterface用于指定光源内外的介质, 若为像点光源一样没有内部介质的光源, 则设置内外介质相同.\nclass LightBase { public: // LightBase Public Methods // ... protected: // LightBase Protected Methods // ... // LightBase Protected Members LightType type; Transform renderFromLight; MediumInterface mediumInterface; static InternCache\u0026lt;DenselySampledSpectrum\u0026gt; *spectrumCache; }; 点光源 # 点光源没有实体, 只能通过在立体角上的分布即辐射强度来描述. 这导致辐亮度无法被描述, pbrt通过除以距离的平方使得单位相同, 以及保持能量守恒.\npstd::optional\u0026lt;LightLiSample\u0026gt; SampleLi(LightSampleContext ctx, Point2f u, SampledWavelengths lambda, bool allowIncompletePDF) const { Point3f p = renderFromLight(Point3f(0, 0, 0)); Vector3f wi = Normalize(p - ctx.p()); SampledSpectrum Li = scale * I-\u0026gt;Sample(lambda) / DistanceSquared(p, ctx.p()); return LightLiSample(Li, wi, 1, Interaction(p, \u0026amp;mediumInterface)); } 点光源功率如下.\n$$ \\begin{equation} \\Phi=\\int_\\Theta I d\\omega=4\\pi I \\end{equation} $$\n聚光灯 # pbrt中聚光灯在本地空间中始终位于原点并指向\\(z\\)轴, 通过相对\\(z\\)轴的角度实现衰减. cosFalloffStart定义衰减开始的角度, cosFalloffEnd定义聚光灯最大角度.\nconst DenselySampledSpectrum *Iemit; Float scale, cosFalloffStart, cosFalloffEnd; 聚光灯功率如下.\n$$ \\begin{equation} \\begin{aligned} \u0026amp;2\\pi I(\\int_0^{\\theta_{\\text{start}}} \\sin\\theta d\\theta+\\int_{\\theta_{\\text{start}}}^{\\theta_{\\text{end}}} \\text{smoothstep}(\\cos\\theta,{\\theta_{\\text{end}}},{\\theta_{\\text{start}}})\\sin\\theta d\\theta)\\\\ \u0026amp;=\\pi I(2-\\cos\\theta_{\\text{start}}-\\cos\\theta_{\\text{end}}) \\end{aligned} \\end{equation} $$\n纹理投影光源 # 纹理投影光源根据光线与\\(z=1\\)平面相交的位置决定纹理坐标, 双线性插值采样后得到颜色. 根据之前章节所介绍的, 根据角度和距离可以将\\(dA\\)转为\\(d\\omega\\), 在纹理投影光源中这会影响光线强度, 对于\\(z=1\\)平面转换系数为\\(\\cos^3\\theta\\).\n纹理投影光源的功率通过转为面积上的积分来计算, 由于像素只代表中心点, 最后的结果需要乘上像素的面积.\n$$ \\begin{equation} \\Phi=\\int_\\Theta I(\\omega) d\\omega = \\int_A I(p) \\frac{d\\omega}{dA} dA \\end{equation} $$\n光度测量角度图光源 # 光度测量角度图描述点光源在角度上的分布, 经过等面积投影后存储在图片中. 由于等面积投影中每个像素都代表同样大小的立体角, 因此功率可以像素值通过相加得到.\n远距离光源 # 远距离光源是距离较远的点光源, 这使得其发出的光线方向都是相同的, 例如太阳. 远距离光源只有位于真空介质是有意义的, 否则由于距离过远在传播过程中就已经都被吸收了.\nDistantLight返回的LightLiSample中的光源位置, 是当前参考点沿入射光线方向行进两倍场景半径后的位置, 阴影光线到达这个点可以保证没有被遮挡.\npstd::optional\u0026lt;LightLiSample\u0026gt; SampleLi(LightSampleContext ctx, Point2f u, SampledWavelengths lambda, bool allowIncompletePDF) const { Vector3f wi = Normalize(renderFromLight(Vector3f(0, 0, 1))); Point3f pOutside = ctx.p() + wi * (2 * sceneRadius); return LightLiSample(scale * Lemit-\u0026gt;Sample(lambda), wi, 1, Interaction(pOutside, nullptr)); } 获取场景内所有物体被照射的面积不现实, 远距离光的功率通过乘上场景包围球对应的圆盘的面积来估计, 形式如下.\n$$ \\begin{equation} \\Phi = \\pi r_s^2 \\int_\\Theta L_e \\delta(\\omega - \\omega_e) d\\omega = \\pi r_s^2 L_e \\end{equation} $$\n面积光源 # 面积光源通过将Shape与在其表面上的辐亮度分布结合来实现, 认为某个点的光源方向为法线方向, 其光照计算通常没有解析形式.\nDiffuseAreaLight定义了在Shape表面均匀分布的光源, 支持通过Image确定各个点的光照, 以及通过alpha使得某些点不发光. pbrt通过调用Shape::Sample实现面积光源的采样. pbrt只支持双线性片使用图片面积光源, 否则图片采样需要对几何物体类做出不必要的扩展.\nclass DiffuseAreaLight : public LightBase { public: // DiffuseAreaLight Public Methods // ... private: // DiffuseAreaLight Private Members Shape shape; FloatTexture alpha; Float area; bool twoSided; const DenselySampledSpectrum *Lemit; Float scale; Image image; const RGBColorSpace *imageColorSpace; // DiffuseAreaLight Private Methods // ... }; 由于对于面积光源上的某个点\\(E(p)=L\\int_0^{2\\pi}\\int_0^{\\frac{\\pi}{2}}\\cos\\theta\\sin\\theta d\\theta=\\pi L\\), 功率计算方式如下. 对于通过Image指定光照的光源, 物体面积除以图片面积可以近似每个像素的面积.\nSampledSpectrum DiffuseAreaLight::Phi(SampledWavelengths lambda) const { SampledSpectrum L(0.f); if (image) { // Compute average light image emission for (int y = 0; y \u0026lt; image.Resolution().y; ++y) for (int x = 0; x \u0026lt; image.Resolution().x; ++x) { RGB rgb; for (int c = 0; c \u0026lt; 3; ++c) rgb[c] = image.GetChannel({x, y}, c); L += RGBIlluminantSpectrum(*imageColorSpace, ClampZero(rgb)) .Sample(lambda); } L *= scale / (image.Resolution().x * image.Resolution().y); } else L = Lemit-\u0026gt;Sample(lambda) * scale; return Pi * (twoSided ? 2 : 1) * area * L; } 无限面积光源 # 无限面积光源是包围整个场景的无限远的面积光源, 例如环境光.\n均匀无限光源 # 均匀无限光源通过UniformInfiniteLight定义, 从各个方向发出相同的光. 执行SampleLi时UniformInfiniteLight可以传入allowIncompletePDF参数, 此时会返回未设置的样本, 因为光源辐亮度为常数, 为避免影响MIS的效果此时不应采样光源.\nUniformInfiniteLight的功率计算方式如下, 直接在场景包围球上求积分即可.\nSampledSpectrum UniformInfiniteLight::Phi(SampledWavelengths lambda) const { return 4 * Pi * Pi * Sqr(sceneRadius) * scale * Lemit-\u0026gt;Sample(lambda); } 图像无限光源 # pbrt通过等面积八面体映射将环境纹理存储在图像中.\npbrt通过PiecewiseConstant2D构建光照分布, 若allowIncompletePDF则在分布中减去平均值来避免采样分布值较小的区域.\n// Initialize sampling PDFs for image infinite area light ImageChannelDesc channelDesc = image.GetChannelDesc({\u0026#34;R\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;B\u0026#34;}); if (!channelDesc) ErrorExit(\u0026#34;%s: image used for ImageInfiniteLight doesn\u0026#39;t have R, G, B \u0026#34; \u0026#34;channels.\u0026#34;, filename); CHECK_EQ(3, channelDesc.size()); CHECK(channelDesc.IsIdentity()); if (image.Resolution().x != image.Resolution().y) ErrorExit(\u0026#34;%s: image resolution (%d, %d) is non-square. It\u0026#39;s unlikely \u0026#34; \u0026#34;this is an equal area environment map.\u0026#34;, filename, image.Resolution().x, image.Resolution().y); Array2D\u0026lt;Float\u0026gt; d = image.GetSamplingDistribution(); Bounds2f domain = Bounds2f(Point2f(0, 0), Point2f(1, 1)); distribution = PiecewiseConstant2D(d, domain, alloc); // Initialize compensated PDF for image infinite area light Float average = std::accumulate(d.begin(), d.end(), 0.) / d.size(); for (Float \u0026amp;v : d) v = std::max\u0026lt;Float\u0026gt;(v - average, 0); if (std::all_of(d.begin(), d.end(), [](Float v) { return v == 0; })) std::fill(d.begin(), d.end(), Float(1)); compensatedDistribution = PiecewiseConstant2D(d, domain, alloc); 由于分布通过图像的\\(uv\\)空间构建, 在转为球面分布时需要添加转换系数.\nFloat pdf = mapPDF / (4 * Pi); ImageInfiniteLight的功率计算方式如下, 由于图片采用等面积映射, 每个像素对应的球面面积可以较为简单的获取.\nSampledSpectrum ImageInfiniteLight::Phi(SampledWavelengths lambda) const { // We\u0026#39;re computing fluence, then converting to power... SampledSpectrum sumL(0.); int width = image.Resolution().x, height = image.Resolution().y; for (int v = 0; v \u0026lt; height; ++v) { for (int u = 0; u \u0026lt; width; ++u) { RGB rgb; for (int c = 0; c \u0026lt; 3; ++c) rgb[c] = image.GetChannel({u, v}, c, WrapMode::OctahedralSphere); sumL += RGBIlluminantSpectrum(*imageColorSpace, ClampZero(rgb)).Sample(lambda); } } // Integrating over the sphere, so 4pi for that. Then one more for Pi // r^2 for the area of the disk receiving illumination... return 4 * Pi * Pi * Sqr(sceneRadius) * scale * sumL / (width * height); } 门户无限光源 # ImageInfiniteLight不考虑光源的可见性, 遮挡会影响采样的效率, pbrt通过PortalImageInfiniteLight解决该问题, 允许用户指定一个四边形的门户.\n门户在等面积八面体映射纹理中会对应一个复杂的形状. pbrt将门户本地空间定义为以门户为\\(z=1\\)平面, 向外为\\(z\\)轴正方向. 此时对纹理重新参数化, 将角度转到\\([0,1]\\)中即可存储, 门户在纹理上会对应某个矩形区域.\n$$ \\begin{equation} (\\alpha,\\beta)=\\left(\\arctan\\frac{x}{z},\\arctan\\frac{y}{z}\\right) \\end{equation} $$\n由于积分通常是在立体角上的积分, 我们需要计算\\(\\frac{d\\omega}{d(u,v)}\\)(因为转换的过程是\\(\\frac{d\\omega}{d(u,v)}d(u,v)\\), pbrt书里搞反了, 见Portal-Masked Environment Map Sampling). 此时由于门户位于\\(x,y\\)平面上, 因此面积与立体角的微分满足\\(d\\omega=\\frac{dA\\cos\\theta}{r^2}=\\frac{dxdy}{r^3}\\), 经整理后得到如下转换关系.\n$$ \\begin{equation} \\frac{d\\omega}{d(u,v)}=\\pi^2\\frac{(1-\\omega_x^2)(1-\\omega_y^2)}{\\omega_z} \\end{equation} $$\n光源采样 # 只使用对当前点贡献较大的光源可以有效提高渲染效率, pbrt通过LightSampler实现光源采样. Sample通过一维随机变量采样, 返回光源与概率, PMF返回指定光源的采样概率. 为实现从光源开始的路径追踪, pbrt提供了与空间位置无关的Sample与PMF.\nclass LightSampler : public TaggedPointer\u0026lt;UniformLightSampler, PowerLightSampler, ExhaustiveLightSampler, BVHLightSampler\u0026gt; { public: // LightSampler Interface using TaggedPointer::TaggedPointer; static LightSampler Create(const std::string \u0026amp;name, pstd::span\u0026lt;const Light\u0026gt; lights, Allocator alloc); std::string ToString() const; PBRT_CPU_GPU inline pstd::optional\u0026lt;SampledLight\u0026gt; Sample(const LightSampleContext \u0026amp;ctx, Float u) const; PBRT_CPU_GPU inline Float PMF(const LightSampleContext \u0026amp;ctx, Light light) const; PBRT_CPU_GPU inline pstd::optional\u0026lt;SampledLight\u0026gt; Sample(Float u) const; PBRT_CPU_GPU inline Float PMF(Light light) const; }; 均匀光源采样 # UniformLightSampler对所有光源均匀采样.\n功率光源采样 # PowerLightSampler根据功率采样光源, 功率从Light::Phi获取.\nBVH光源采样 # BVHLightSampler通过对光源构建包围结构来加速光源采样.\n每个光源都在空间上影响某块区域, pbrt通过LightBounds表示, 显然这不适用于无限光源, 需要单独处理. \\(\\omega\\)指定主要光源表面法线\\(\\bold{n_m}\\), \\(\\theta_o\\)表示光源表面法线相对主法线的最大变化角度, \\(\\theta_e\\)表示相对于某个法线的最大的可以接收光照的角度.\nclass LightBounds { public: // LightBounds Public Methods LightBounds() = default; LightBounds(const Bounds3f \u0026amp;b, Vector3f w, Float phi, Float cosTheta_o, Float cosTheta_e, bool twoSided); PBRT_CPU_GPU Point3f Centroid() const { return (bounds.pMin + bounds.pMax) / 2; } PBRT_CPU_GPU Float Importance(Point3f p, Normal3f n) const; std::string ToString() const; // LightBounds Public Members Bounds3f bounds; Float phi = 0; Vector3f w; Float cosTheta_o, cosTheta_e; bool twoSided; }; Importance是LightBounds的关键方法, 负责返回光源对表面上某个点的贡献. 连接表面点与光源包围盒中心, 令该向量为\\(\\bold{d_b}\\), 与\\(\\bold{n_m}\\)形成的角度为\\(\\theta_w\\), 包围盒对应的包围球与该点的切线和该向量形成的角度为\\(\\theta_b\\).\n\\(\\theta_w-\\theta_o\\)代表使用最接近表面点的法线\\(\\bold{n_p}\\), 与\\(\\bold{d_b}\\)形成的角度为\\(\\theta_n\\). \\(\\bold{n_p}\\)实际位于的光源表面可以是光源包围盒内的任意位置, 令某具有\\(\\bold{n_p}\\)的位置与表面点连接的向量\\(\\bold{d_p}\\)和\\(\\bold{n_p}\\)的夹角为\\(\\theta_p\\), 和\\(\\bold{d_b}\\)夹角为\\(\\bold{\\theta_s}\\).\n根据\\(\\bold{d_b}\\), \\(\\bold{d_p}\\), \\(\\bold{n_p}\\)形成的三角形, 可以看出\\(\\theta_p=\\theta_n-\\theta_s\\), 而\\(\\theta_s\\)最小为\\(\\theta_b\\), 此时得到最小值\\(\\theta\u0026rsquo;=\\max(0,\\theta_w-\\theta_o-\\theta_b)\\), 若大于\\(\\theta_e\\)则可以认为该点无法被照亮. 令表面法线与\\(\\bold{d_b}\\)形成的角度为\\(\\theta_i\\), 令\\(\\theta\u0026rsquo;_i=\\max(0,\\theta_i-\\theta_b)\\), 该角度为\\(\\bold{d_p}\\)与表面法线的最大角度, 即光源产生最大贡献的角度. 此时可以得到贡献值\\(I=\\frac{\\phi\\cos\\theta\u0026rsquo;\\cos\\theta\u0026rsquo;_i}{d^2}\\).\nPBRT_CPU_GPU Float LightBounds::Importance(Point3f p, Normal3f n) const { // Return importance for light bounds at reference point // Compute clamped squared distance to reference point Point3f pc = (bounds.pMin + bounds.pMax) / 2; Float d2 = DistanceSquared(p, pc); d2 = std::max(d2, Length(bounds.Diagonal()) / 2); // Define cosine and sine clamped subtraction lambdas auto cosSubClamped = [](Float sinTheta_a, Float cosTheta_a, Float sinTheta_b, Float cosTheta_b) -\u0026gt; Float { if (cosTheta_a \u0026gt; cosTheta_b) return 1; return cosTheta_a * cosTheta_b + sinTheta_a * sinTheta_b; }; auto sinSubClamped = [](Float sinTheta_a, Float cosTheta_a, Float sinTheta_b, Float cosTheta_b) -\u0026gt; Float { if (cosTheta_a \u0026gt; cosTheta_b) return 0; return sinTheta_a * cosTheta_b - cosTheta_a * sinTheta_b; }; // Compute sine and cosine of angle to vector _w_, $\\theta_\\roman{w}$ Vector3f wi = Normalize(p - pc); Float cosTheta_w = Dot(Vector3f(w), wi); if (twoSided) cosTheta_w = std::abs(cosTheta_w); Float sinTheta_w = SafeSqrt(1 - Sqr(cosTheta_w)); // Compute $\\cos\\,\\theta_\\roman{\\+b}$ for reference point Float cosTheta_b = BoundSubtendedDirections(bounds, p).cosTheta; Float sinTheta_b = SafeSqrt(1 - Sqr(cosTheta_b)); // Compute $\\cos\\,\\theta\u0026#39;$ and test against $\\cos\\,\\theta_\\roman{e}$ Float sinTheta_o = SafeSqrt(1 - Sqr(cosTheta_o)); Float cosTheta_x = cosSubClamped(sinTheta_w, cosTheta_w, sinTheta_o, cosTheta_o); Float sinTheta_x = sinSubClamped(sinTheta_w, cosTheta_w, sinTheta_o, cosTheta_o); Float cosThetap = cosSubClamped(sinTheta_x, cosTheta_x, sinTheta_b, cosTheta_b); if (cosThetap \u0026lt;= cosTheta_e) return 0; // Return final importance at reference point Float importance = phi * cosThetap / d2; DCHECK_GE(importance, -1e-3); // Account for $\\cos\\theta_\\roman{i}$ in importance at surfaces if (n != Normal3f(0, 0, 0)) { Float cosTheta_i = AbsDot(wi, n); Float sinTheta_i = SafeSqrt(1 - Sqr(cosTheta_i)); Float cosThetap_i = cosSubClamped(sinTheta_i, cosTheta_i, sinTheta_b, cosTheta_b); importance *= cosThetap_i; } importance = std::max\u0026lt;Float\u0026gt;(importance, 0); return importance; } 光源包围结构实现 # 无限光源返回未设置的std::optional\u0026lt;LightBounds\u0026gt;.\npstd::optional\u0026lt;LightBounds\u0026gt; Bounds() const { return {}; } 点光源可以照亮任意方向.\npstd::optional\u0026lt;LightBounds\u0026gt; PointLight::Bounds() const { Point3f p = renderFromLight(Point3f(0, 0, 0)); Float phi = 4 * Pi * scale * I-\u0026gt;MaxValue(); return LightBounds(Bounds3f(p, p), Vector3f(0, 0, 1), phi, std::cos(Pi), std::cos(Pi / 2), false); } 聚光灯的\\(\\theta_o\\)为非衰减区域的角度, \\(\\theta_e\\)为衰减区域的角度. 对于两个只有锥体大小不同的聚光灯, 若它们照亮同一个点, 该点对这两个光源的采样概率应该是相同的. 因此二者的\\(\\phi\\)应设置为与锥体无关的, 锥体已经在Importance中被考虑了, 不需要再次将其添加到\\(\\phi\\)中.\npstd::optional\u0026lt;LightBounds\u0026gt; SpotLight::Bounds() const { Point3f p = renderFromLight(Point3f(0, 0, 0)); Vector3f w = Normalize(renderFromLight(Vector3f(0, 0, 1))); Float phi = scale * Iemit-\u0026gt;MaxValue() * 4 * Pi; Float cosTheta_e = std::cos(std::acos(cosFalloffEnd) - std::acos(cosFalloffStart)); return LightBounds(Bounds3f(p, p), w, phi, cosFalloffStart, cosTheta_e, false); } 纹理投影光源\\(\\theta_o\\)为0, 因为只有一个方向, \\(\\theta_e\\)与图片尺寸有关, \\(\\phi\\)根据图片像素计算.\npstd::optional\u0026lt;LightBounds\u0026gt; ProjectionLight::Bounds() const { Float sum = 0; for (int v = 0; v \u0026lt; image.Resolution().y; ++v) for (int u = 0; u \u0026lt; image.Resolution().x; ++u) sum += std::max({image.GetChannel({u, v}, 0), image.GetChannel({u, v}, 1), image.GetChannel({u, v}, 2)}); Float phi = scale * sum / (image.Resolution().x * image.Resolution().y); Point3f pCorner(screenBounds.pMax.x, screenBounds.pMax.y, 0); Vector3f wCorner = Normalize(Vector3f(lightFromScreen(pCorner))); Float cosTotalWidth = CosTheta(wCorner); Point3f p = renderFromLight(Point3f(0, 0, 0)); Vector3f w = Normalize(renderFromLight(Vector3f(0, 0, 1))); return LightBounds(Bounds3f(p, p), w, phi, std::cos(0.f), cosTotalWidth, false); } 光度测量角度图光源与点光源类似, \\(\\phi\\)根据实际数据计算.\npstd::optional\u0026lt;LightBounds\u0026gt; GoniometricLight::Bounds() const { Float sumY = 0; for (int y = 0; y \u0026lt; image.Resolution().y; ++y) for (int x = 0; x \u0026lt; image.Resolution().x; ++x) sumY += image.GetChannel({x, y}, 0); Float phi = scale * Iemit-\u0026gt;MaxValue() * 4 * Pi * sumY / (image.Resolution().x * image.Resolution().y); Point3f p = renderFromLight(Point3f(0, 0, 0)); // Bound it as an isotropic point light. return LightBounds(Bounds3f(p, p), Vector3f(0, 0, 1), phi, std::cos(Pi), std::cos(Pi / 2), false); } 面积光源的法线与角度根据Shape::NormalBounds获取, 若光源为图片则\\(\\phi\\)为平均值. Importance中已经考虑了双面的情况, 因此\\(\\phi\\)不需要考虑双面.\npstd::optional\u0026lt;LightBounds\u0026gt; DiffuseAreaLight::Bounds() const { // Compute _phi_ for diffuse area light bounds Float phi = 0; if (image) { // Compute average _DiffuseAreaLight_ image channel value // Assume no distortion in the mapping, FWIW... for (int y = 0; y \u0026lt; image.Resolution().y; ++y) for (int x = 0; x \u0026lt; image.Resolution().x; ++x) for (int c = 0; c \u0026lt; 3; ++c) phi += image.GetChannel({x, y}, c); phi /= 3 * image.Resolution().x * image.Resolution().y; } else phi = Lemit-\u0026gt;MaxValue(); phi *= scale * area * Pi; DirectionCone nb = shape.NormalBounds(); return LightBounds(shape.Bounds(), nb.w, phi, nb.cosTheta, std::cos(Pi / 2), twoSided); } 紧凑包围结构光源 # 为提高缓存效率, 尤其是在GPU上, pbrt实现CompactLightBounds来进一步减小存储开销, 主要通过\\(\\omega\\)的单位向量压缩, 以及\\(\\cos\\theta\\)和包围盒对角坐标的量化来实现.\nclass CompactLightBounds { public: // CompactLightBounds Public Methods // ... private: // CompactLightBounds Private Methods // ... // CompactLightBounds Private Members OctahedralVector w; Float phi = 0; struct { unsigned int qCosTheta_o : 15; unsigned int qCosTheta_e : 15; unsigned int twoSided : 1; }; uint16_t qb[2][3]; }; \\(\\cos\\theta\\)采用\\(15\\)位量化, 通过转为正数后乘上\\(2^{15}-1=32767\\)实现.\nstatic unsigned int QuantizeCos(Float c) { return pstd::floor(32767.f * ((c + 1) / 2)); } 构造函数中的allb指定包围盒的最大范围, 以及为基准进行量化.\nfor (int c = 0; c \u0026lt; 3; ++c) { qb[0][c] = pstd::floor(QuantizeBounds(lb.bounds[0][c], allb.pMin[c], allb.pMax[c])); qb[1][c] = pstd::ceil(QuantizeBounds(lb.bounds[1][c], allb.pMin[c], allb.pMax[c])); } 量化通过乘上\\(2^{16}-1=65535\\)实现.\nstatic Float QuantizeBounds(Float c, Float min, Float max) { if (min == max) return 0; return 65535.f * Clamp((c - min) / (max - min), 0, 1); } 光源包围结构层级 # BVHLightSampler是pbrt中大部分积分器的默认采样器, 通过根据LightBounds构建BVH提高效率.\nLightBVHNode存储BVH节点, 在CompactLightBounds的基础上添加序列化后的节点编号与叶节点标记, 采用32位对齐以提高cache效率.\nstruct alignas(32) LightBVHNode { // LightBVHNode Public Methods LightBVHNode() = default; PBRT_CPU_GPU static LightBVHNode MakeLeaf(unsigned int lightIndex, const CompactLightBounds \u0026amp;cb) { return LightBVHNode{cb, {lightIndex, 1}}; } PBRT_CPU_GPU static LightBVHNode MakeInterior(unsigned int child1Index, const CompactLightBounds \u0026amp;cb) { return LightBVHNode{cb, {child1Index, 0}}; } PBRT_CPU_GPU pstd::optional\u0026lt;SampledLight\u0026gt; Sample(const LightSampleContext \u0026amp;ctx, Float u) const; std::string ToString() const; // LightBVHNode Public Members CompactLightBounds lightBounds; struct { unsigned int childOrLightIndex : 31; unsigned int isLeaf : 1; }; }; pbrt通过整数记录BVH遍历过程, \\(01\\)分别代表左子树与右子树.\nHashMap\u0026lt;Light, uint32_t\u0026gt; lightToBitTrail; 构建BVH时的节点开销与光源角度有关, 形式如下.\n$$ \\begin{equation} M_\\Omega=\\int_0^{2\\pi}(\\int_0^{\\theta_o}\\sin\\theta\u0026rsquo;d\\theta\u0026rsquo;+\\int_{\\theta_o}^{\\min(\\theta_o+\\theta_e,\\pi)}\\cos(\\theta\u0026rsquo;-\\theta_o)\\sin\\theta\u0026rsquo;d\\theta\u0026rsquo;)d\\phi \\end{equation} $$\n此外开销还与功率, 包围盒面积以及对角线相对于当前分割轴的关系有关. 若包围盒较为细长则面积会减小, 同时导致开销减小, 因为它们占据较大的立体角但实际上贡献不大.\nFloat Kr = MaxComponentValue(bounds.Diagonal()) / bounds.Diagonal()[dim]; return b.phi * M_omega * Kr * b.bounds.SurfaceArea(); Sample中首先判断是否采样无限光源, 若是则采用均匀分布. 每个无限光源的采样概率都与BVH的采样概率相同.\n// Compute infinite light sampling probability _pInfinite_ Float pInfinite = Float(infiniteLights.size()) / Float(infiniteLights.size() + (nodes.empty() ? 0 : 1)); if (u \u0026lt; pInfinite) { // Sample infinite lights with uniform probability u /= pInfinite; int index = std::min\u0026lt;int\u0026gt;(u * infiniteLights.size(), infiniteLights.size() - 1); Float pmf = pInfinite / infiniteLights.size(); return SampledLight{infiniteLights[index], pmf}; } 若采样BVH, 则根据子节点的Importance按概率选择遍历路径.\n// Traverse light BVH to sample light if (nodes.empty()) return {}; // Declare common variables for light BVH traversal Point3f p = ctx.p(); Normal3f n = ctx.ns; u = std::min\u0026lt;Float\u0026gt;((u - pInfinite) / (1 - pInfinite), OneMinusEpsilon); int nodeIndex = 0; Float pmf = 1 - pInfinite; while (true) { // Process light BVH node for light sampling LightBVHNode node = nodes[nodeIndex]; if (!node.isLeaf) { // Compute light BVH child node importances const LightBVHNode *children[2] = {\u0026amp;nodes[nodeIndex + 1], \u0026amp;nodes[node.childOrLightIndex]}; Float ci[2] = { children[0]-\u0026gt;lightBounds.Importance(p, n, allLightBounds), children[1]-\u0026gt;lightBounds.Importance(p, n, allLightBounds)}; if (ci[0] == 0 \u0026amp;\u0026amp; ci[1] == 0) return {}; // Randomly sample light BVH child node Float nodePMF; int child = SampleDiscrete(ci, u, \u0026amp;nodePMF, \u0026amp;u); pmf *= nodePMF; nodeIndex = (child == 0) ? (nodeIndex + 1) : node.childOrLightIndex; } else { // Confirm light has nonzero importance before returning light sample if (nodeIndex \u0026gt; 0) DCHECK_GT(node.lightBounds.Importance(p, n, allLightBounds), 0); if (nodeIndex \u0026gt; 0 || node.lightBounds.Importance(p, n, allLightBounds) \u0026gt; 0) return SampledLight{lights[node.childOrLightIndex], pmf}; return {}; } } 根据lightToBitTrail可以计算采样概率.\nPBRT_CPU_GPU Float PMF(const LightSampleContext \u0026amp;ctx, Light light) const { // Handle infinite _light_ PMF computation if (!lightToBitTrail.HasKey(light)) return 1.f / (infiniteLights.size() + (nodes.empty() ? 0 : 1)); // Initialize local variables for BVH traversal for PMF computation uint32_t bitTrail = lightToBitTrail[light]; Point3f p = ctx.p(); Normal3f n = ctx.ns; // Compute infinite light sampling probability _pInfinite_ Float pInfinite = Float(infiniteLights.size()) / Float(infiniteLights.size() + (nodes.empty() ? 0 : 1)); Float pmf = 1 - pInfinite; int nodeIndex = 0; // Compute light\u0026#39;s PMF by walking down tree nodes to the light while (true) { const LightBVHNode *node = \u0026amp;nodes[nodeIndex]; if (node-\u0026gt;isLeaf) { DCHECK_EQ(light, lights[node-\u0026gt;childOrLightIndex]); return pmf; } // Compute child importances and update PMF for current node const LightBVHNode *child0 = \u0026amp;nodes[nodeIndex + 1]; const LightBVHNode *child1 = \u0026amp;nodes[node-\u0026gt;childOrLightIndex]; Float ci[2] = {child0-\u0026gt;lightBounds.Importance(p, n, allLightBounds), child1-\u0026gt;lightBounds.Importance(p, n, allLightBounds)}; DCHECK_GT(ci[bitTrail \u0026amp; 1], 0); pmf *= ci[bitTrail \u0026amp; 1] / (ci[0] + ci[1]); // Use _bitTrail_ to find next node index and update its value nodeIndex = (bitTrail \u0026amp; 1) ? node-\u0026gt;childOrLightIndex : (nodeIndex + 1); bitTrail \u0026gt;\u0026gt;= 1; } } ","date":"2025 January 2","externalUrl":null,"permalink":"/render/1735792253400-pbrt-v4-episode-12/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. XII: 光源","type":"render"},{"content":" 体散射过程 # 吸收, 自发光与散射影响传输介质中辐亮度的分布, 这些系数与位置和方向有关, pbrt认为介质中粒子的位置是独立的.\n吸收 # 吸收由介质的吸收系数\\(\\sigma_a\\)表示, 代表光线在介质中经过单位距离后被吸收的概率, 吸收后辐亮度变化如下形式. 这里入射光方向为负的原因在之前章节有介绍过, 只是方便计算.\n$$ \\begin{equation} dL_o(p,\\omega)=-\\sigma_a(p,\\omega)L_i(p,-\\omega)dt \\end{equation} $$\n自发光 # 介质中的化学, 热或核过程使得经过它的光线的辐亮度增加, 其形式如下. 自发光是吸收的逆过程, 因此二者系数相同. 注意到pbrt中\\(L_e\\)与\\(L_i\\)无关, 在几何光学中这是成立的.\n$$ \\begin{equation} dL_o(p,\\omega)=\\sigma_a(p,\\omega)L_e(p,\\omega)dt \\end{equation} $$\n外散射与衰减 # 粒子间的碰撞导致粒子的运动方向被改变, 从而导致辐亮度的衰减, 这被称为外散射. 将吸收与外散射系数结合即可得到衰减系数\\(\\sigma_t(p,\\omega)=\\sigma_a(p,\\omega)+\\sigma_s(p,\\omega)\\). 此时可以定义单散射反照率\\(\\rho(p,\\omega)=\\frac{\\sigma_s(p,\\omega)}{\\sigma_t(p,\\omega)}\\), 这表示散射事件中散射的概率. 同时也可以定义平均自由程\\(\\frac{1}{\\sigma_t(p,\\omega)}\\), 这表示衰减系数为\\(\\sigma_t(p,\\omega)\\)时粒子在与其它粒子交互前运动的平均距离.\n$$ \\begin{equation} dL_o(p,\\omega)=-\\sigma_s(p,\\omega)L_i(p,-\\omega)dt \\end{equation} $$\n内散射 # 其它光线中的粒子通过外散射成为当前光线中的粒子, 使得辐亮度增加, 这被称为内散射. 定义相位方程\\(p(\\omega,\\omega\u0026rsquo;)\\)为光线方向为\\(\\omega\\)时外散射到\\(\\omega\u0026rsquo;\\)的概率, 这与BSDF类似但是需要归一化, 此时可以定义内散射.\n$$ \\begin{equation} dL_o(p,\\omega)=\\sigma_s(p,\\omega)\\int_\\Theta p(p,\\omega_i,\\omega)L_i(p,\\omega_i)d\\omega_idt \\end{equation} $$\n此时可以得到辐亮度总增加量.\n$$ \\begin{equation} \\begin{aligned} dL_o(p,\\omega) \u0026amp;=\\sigma_t(p,\\omega)L_s(p,\\omega)dt\\\\ \u0026amp;=\\sigma_t(p,\\omega)(\\frac{\\sigma_a(p,\\omega)}{\\sigma_t(p,\\omega)}L_e(p,\\omega)+\\frac{\\sigma_s(p,\\omega)}{\\sigma_t(p,\\omega)}\\int_\\Theta p(p,\\omega_i,\\omega)L_i(p,\\omega_i)d\\omega_i)dt \\end{aligned} \\end{equation} $$\n透射率 # 根据微分方程可以得到透射率, 本节不考虑辐亮度增益.\n$$ \\begin{equation} T_r(p \\to p\u0026rsquo;) = e^{-\\int_0^d \\sigma_t(p + t\\omega, \\omega)dt} \\end{equation} $$\n根据光线的传播过程可知透射率是可逆的.\n$$ \\begin{equation} T_r(p \\to p\u0026rsquo;)=T_r(p\u0026rsquo; \\to p) \\end{equation} $$\n透射率可以被分解, 这是积分的性质决定的.\n$$ \\begin{equation} T_r(p \\to p\u0026rsquo;\u0026rsquo;)=T_r(p \\to p\u0026rsquo;)T_r(p\u0026rsquo; \\to p\u0026rsquo;\u0026rsquo;) \\end{equation} $$\n衰减系数的积分被称为光学厚度. 根据Jensen不等式可知, \\(E[e^{-X}] \\ne e^{-E[X]}\\), 因此通过在积分路径上抽样进行Monte Carlo积分是有偏估计.\n$$ \\begin{equation} \\tau(p \\to p\u0026rsquo;)=\\int_0^d \\sigma_t(p+t\\omega,\\omega)dt \\end{equation} $$\n路径追踪任务是光线传播的逆过程, 因此\\(-dL(p)=-\\sigma_t(p,\\omega)L(p)dt\\). pbrt中下列公式都是由这一条件推导出的, 但是并没有注明, 因此尝试推导时会得到相反的结论, 具体推导过程见Integral formulations of volumetric transmittance.\n根据微分方程可以得到\\(L(p,\\omega)-L(p+d\\omega,\\omega)=\\int_0^d -\\sigma_t(p+t\\omega)L(p+t\\omega,\\omega)dt\\), 已知\\(T_r(p \\leftarrow p + d\\omega)=\\frac{L(p,\\omega)}{L(p + d\\omega,\\omega)}\\), 代入前式可以得到以下积分. 此时可以通过Monte Carlo得到透射率的无偏估计, 但较为复杂.\n$$ \\begin{equation} T_r(p \\leftarrow p + d\\omega)=1 - \\int_0^d \\sigma_t(p+t\\omega)T_r(p + t\\omega \\leftarrow p+d\\omega)dt \\end{equation} $$\n空散射 # 定义一个\\(\\sigma_{\\text{maj}}(p,\\omega)\\)作为主衰减系数(为减小方差, pbrt将其设置为大于等于任意一处的衰减系数), 此时可以定义空散射(null-scattering)系数, 由此可得\\(\\sigma_{\\text{maj}}(p,\\omega)=\\sigma_a(p,\\omega)+\\sigma_s(p,\\omega)+\\sigma_n(p,\\omega)\\)在介质中为常数或分段常数.\n$$ \\begin{equation} \\sigma_n(p,\\omega)=\\sigma_{\\text{maj}}(p,\\omega)-\\sigma_t(p,\\omega) \\end{equation} $$\n此时微分方程转为如下形式.\n$$ \\begin{equation} -\\frac{dL(p,\\omega)}{dt}+\\sigma_{\\text{maj}}(p,\\omega)L(p,\\omega)=\\sigma_n(p,\\omega)L(p,\\omega) \\end{equation} $$\n定义\\(h(t)\\)与\\(g(t)\\), 可以得到如下结果.\n$$ \\begin{equation} \\begin{aligned} h(t)\u0026amp;=e^{-\\int_0^t \\sigma_{\\text{maj}}(p+t\u0026rsquo;\\omega,\\omega) dt\u0026rsquo;}\\\\ \\frac{dh(t)}{dt}\u0026amp;=-h(t)\\sigma_{\\text{maj}}(p+t\\omega,\\omega)\\\\ g(t)\u0026amp;=\\sigma_n(p+t\\omega,\\omega)L(p+t\\omega,\\omega) \\end{aligned} \\end{equation} $$\n微分方程两边同乘\\(h(t)\\)以及之后再次积分可得如下结果.\n$$ \\begin{equation} \\begin{aligned} -h(t)\\frac{dL(p+t\\omega,\\omega)}{dt}-L(p+t\\omega,\\omega)\\frac{dh(t)}{dt}\u0026amp;=h(t)g(t)\\\\ h(0)L(p,\\omega)-h(d)L(p+d\\omega,\\omega)\u0026amp;=\\int_0^d h(t)g(t)dt \\end{aligned} \\end{equation} $$\n两边同除\\(h(0)L(p+d\\omega,\\omega)\\)后可得下式.\n$$ \\begin{equation} \\begin{aligned} T_r(p \\leftarrow p+d\\omega) \u0026amp;=\\frac{h(d)}{h(0)}+\\int_0^d \\frac{h(t)g(t)}{h(0){L(p+d\\omega,\\omega)}}\\\\ \u0026amp;=e^{-\\int_0^d \\sigma_\\text{maj}(p+t\\omega,\\omega)dt}+\\int_0^d e^{-\\int_0^t \\sigma_\\text{maj}(p+t\u0026rsquo;\\omega,\\omega)dt\u0026rsquo;}\\sigma_n(p+t\\omega,\\omega)T_r(p+t\\omega \\leftarrow p+d\\omega)dt \\end{aligned} \\end{equation} $$\n计算上式的Monte Carlo需要使用一个与积分项成比例的分布, pbrt使用\\(p_{\\text{maj}}(t) \\propto e^{\\int_0^t -\\sigma_{\\text{maj}}(p+t\u0026rsquo;\\omega, \\omega)dt\u0026rsquo;}\\), 归一化后得到以下PDF.\n$$ \\begin{equation} p_{\\text{maj}}(t)=\\sigma_{\\text{maj}}(p,\\omega)e^{-\\int_0^t \\sigma_{\\text{maj}}(p+t\u0026rsquo;\\omega,\\omega) dt\u0026rsquo;} \\end{equation} $$\n将积分项视为\\(t\u0026rsquo; \\ge d\\)时为0的分段函数, Monte Carlo采样可以得到如下结果, 这被称为下一跳(next-flight)估计器, \\(t\u0026rsquo; \\ge d\\)时停止递归采样过程. 在均匀介质下这是无偏的, 不均匀介质下效果一般.\n$$ \\begin{equation} T_r(p \\leftarrow p+d\\omega) \\approx e^{-\\int_0^d\\sigma_{\\text{maj}}(p+t\\omega,\\omega)dt}+ \\begin{cases} \\frac{\\sigma_n(p+t\u0026rsquo;\\omega,\\omega)}{\\sigma_{\\text{maj}}(p+t\u0026rsquo;\\omega,\\omega)}T_r(p+t\u0026rsquo;\\omega \\leftarrow p+d\\omega) \u0026amp; t\u0026rsquo;\u0026lt;d\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} \\end{equation} $$\n随机选取其中一项也可以进行Monte Carlo, 由于CDF具有\\(P(t\u0026rsquo; \\ge d)=e^{-\\int_0^d\\sigma_{\\text{maj}}dt}\\)的性质, 可以将该值作为选择概率. 注意到下一跳估计器中是在\\((0,\\infty)\\)上的积分, 而这里是在\\((0,d)\\)上的积分, 因此需要通过将PDF除以\\(1-e^{-\\int_0^d\\sigma_{\\text{maj}}(p+t\\omega,\\omega)dt}\\)来归一化, Monte Carlo时正好与\\(\\frac{1}{1-p_e}\\)抵消. 此时可以得到比率跟踪(ratio-tracking)估计器, 这是pbrt采用的算法.\n$$ \\begin{equation} \\begin{aligned} T_r(p \\leftarrow p+d\\omega) \u0026amp;\\approx \\begin{cases} \\frac{e^{-\\int_0^d\\sigma_{\\text{maj}}(p+t\\omega,\\omega)dt}}{p_e} \u0026amp; \\text{with}\\ \\text{probability}\\ p_e\\\\ \\frac{1}{1-p_e}\\int_0^d e^{-\\int_0^t\\sigma_{\\text{maj}}(p+t\u0026rsquo;\\omega,\\omega)dt\u0026rsquo;}\\sigma_n(p+t\\omega,\\omega)T_r(p+t\\omega \\leftarrow p+d\\omega)dt \u0026amp; \\text{otherwise} \\end{cases}\\\\ \u0026amp;\\approx \\begin{cases} 1 \u0026amp; t\u0026rsquo; \u0026gt; d\\\\ \\frac{\\sigma_n(p+t\u0026rsquo;\\omega,\\omega)}{\\sigma_{\\text{maj}}(p+t\u0026rsquo;\\omega,\\omega)}T_r(p+t\u0026rsquo;\\omega \\leftarrow p+d\\omega) \u0026amp; \\text{otherwise} \\end{cases}\\\\ \u0026amp;\\approx \\prod_{i=1}^n \\frac{\\sigma_n(p+t_i\\omega,\\omega)}{\\sigma_{\\text{maj}}(p+t_i\\omega,\\omega)} \\end{aligned} \\end{equation} $$\n比率跟踪估计器在透射率已经很小时仍然会继续采样, 可以通过俄罗斯轮盘解决该问题, 将俄罗斯轮盘概率设置为\\(\\frac{\\sigma_n(p+t\u0026rsquo;\\omega,\\omega)}{\\sigma_{\\text{maj}}(p+t\u0026rsquo;\\omega,\\omega)}\\)可以将其抵消, 这被称为差值跟踪(delta-tracking)估计器, 透射率只能为0或1.\n$$ \\begin{equation} \\begin{aligned} T_r(p \\leftarrow p+d\\omega)\u0026amp;\\approx \\begin{cases} 1 \u0026amp; t\u0026rsquo; \u0026gt; d\\\\ T_r(p+t\u0026rsquo;\\omega \\leftarrow p+d\\omega) \u0026amp; t\u0026rsquo; \\le d\\ \\text{and}\\ \\text{with}\\ \\text{probability}\\ \\frac{\\sigma_n(p+t\u0026rsquo;\\omega,\\omega)}{\\sigma_{\\text{maj}}}\\\\ 0 \u0026amp; \\text{otherwise} \\end{cases} \\end{aligned} \\end{equation} $$\n相位函数 # 只与入射方向和出射方向的夹角有关的相位函数被称为对称相位函数, 否则就是需要用四个维度表示的非对称相位函数. 各个方向均匀分布的相位函数为各向同性相位函数, 只有\\(p(\\omega_i,\\omega_o)=\\frac{1}{\\int_0^{2\\pi}\\int_0^\\pi \\sin\\theta d\\theta d\\phi}=\\frac{1}{4\\pi}\\)满足该条件, 否则为各向异性.\npbrt的相位函数定义在PhaseFunction中, 目前只有HGPhaseFunction一种实现.\nclass PhaseFunction : public TaggedPointer\u0026lt;HGPhaseFunction\u0026gt; { public: // PhaseFunction Interface using TaggedPointer::TaggedPointer; std::string ToString() const; PBRT_CPU_GPU inline Float p(Vector3f wo, Vector3f wi) const; PBRT_CPU_GPU inline pstd::optional\u0026lt;PhaseFunctionSample\u0026gt; Sample_p(Vector3f wo, Point2f u) const; PBRT_CPU_GPU inline Float PDF(Vector3f wo, Vector3f wi) const; }; Henyey–Greenstein相位函数 # Henyey-Greenstein相位函数来自于对测量散射数据的拟合, 其形式如下. 原文中\\(\\cos\\theta\\)符号为负, 由于pbrt中入射光线朝外, 这里符号设置为正.\n$$ \\begin{equation} p_{HG}(\\cos\\theta)=\\frac{1}{4\\pi}\\frac{1-g^2}{(1+g^2+2g\\cos\\theta)^{\\frac{3}{2}}} \\end{equation} $$\nHenyey-Greenstein中的\\(g\\)为非对称系数, 它来自于某种相位函数的积分, 这使得任意的相位函数都可以被转为Henyey-Greenstein相位函数. g位于\\((-1,1)\\)中, 接近\\(1\\)时\\(\\omega\\)附近的分布密度较大, 接近\\(-1\\)时\\(-\\omega\\)附近分布密度较大.\n$$ \\begin{equation} g=\\int_\\Theta p(-\\omega\\cdot\\omega\u0026rsquo;)(\\omega\\cdot\\omega\u0026rsquo;)d\\omega\u0026rsquo;=2\\pi\\int_0^\\pi p(-\\cos\\theta)\\cos\\theta\\sin\\theta d\\theta \\end{equation} $$\n逆变换法得到的\\(\\cos\\theta\\)如下, \\(\\epsilon\\)为服从均匀分布的随机变量.\n$$ \\begin{equation} \\begin{aligned} \\cos\\theta= \\begin{cases} -\\frac{1}{2g}(1+g^2-(\\frac{1-g^2}{1+g-2g\\epsilon})^2) \u0026amp; g \\ne 0\\\\ 1-2\\epsilon \u0026amp; g=0 \\end{cases} \\end{aligned} \\end{equation} $$\n介质 # Medium类定义介质, NanoVDBMedium这一派生类用于NanoVDB格式的介质, 本节不讨论第三方API的调用.\nclass Medium : public TaggedPointer\u0026lt; // Medium Types HomogeneousMedium, GridMedium, RGBGridMedium, CloudMedium, NanoVDBMedium \u0026gt; { public: // Medium Interface using TaggedPointer::TaggedPointer; static Medium Create(const std::string \u0026amp;name, const ParameterDictionary \u0026amp;parameters, const Transform \u0026amp;renderFromMedium, const FileLoc *loc, Allocator alloc); std::string ToString() const; PBRT_CPU_GPU bool IsEmissive() const; PBRT_CPU_GPU MediumProperties SamplePoint(Point3f p, const SampledWavelengths \u0026amp;lambda) const; // Medium Public Methods RayMajorantIterator SampleRay(Ray ray, Float tMax, const SampledWavelengths \u0026amp;lambda, ScratchBuffer \u0026amp;buf) const; }; SamplePoint返回介质在空间中某个点处的性质.\nstruct MediumProperties { SampledSpectrum sigma_a, sigma_s; PhaseFunction phase; SampledSpectrum Le; }; SampleRay返回多个RayMajorantSegment, 用于存储每一段的\\(\\sigma_{\\text{maj}}\\). RayMajorantIterator可以每次只返回一段, 减小内存开销.\nstruct RayMajorantSegment { Float tMin, tMax; SampledSpectrum sigma_maj; }; pbrt通过在各个类中组合Medium对象来表示当前介质, 例如Camera中的介质表示相机当前所处位置的介质, Light中的介质初始化时与相机的介质相同, 随着路径追踪的推进而修改. 若介质为空指针则代表位于真空中.\npbrt通过Primitive表示介质的边界, 它会存储MediumInterface用于表示图元两侧的介质. pbrt不会检查介质是否有效, 例如将相机的介质设置为与实际所处的Primitive的某一侧的介质不同是被允许的. 实际只有透明物体需要在相交时将MediumInterface传入SurfaceInteraction.\nstruct MediumInterface { // ... // MediumInterface Public Members Medium inside, outside; }; pbrt中类似云的介质也需要一个Primitive来表示范围, 但是并不会改变光线传播路径. 这可以通过将BSDF设置为两侧IOR相同的完美透射实现, 但为了降低复杂度, pbrt通过将材质设置为空指针来表示不改变光线路径.\n均匀介质 # 介质中\\(\\sigma_a\\), \\(\\sigma_s\\), \\(L_e\\)处处相等的介质为均匀介质, pbrt中用HomogeneousMedium表示.\nclass HomogeneousMedium { public: // HomogeneousMedium Public Type Definitions using MajorantIterator = HomogeneousMajorantIterator; // ... private: // HomogeneousMedium Private Data DenselySampledSpectrum sigma_a_spec, sigma_s_spec, Le_spec; HGPhaseFunction phase; }; 均匀介质不需要进行空散射, 因此HomogeneousMajorantIterator只存储一段RayMajorantSegment.\nPBRT_CPU_GPU pstd::optional\u0026lt;RayMajorantSegment\u0026gt; Next() { if (called) return {}; called = true; return seg; } DDA主值迭代器 # 为保证平均自由程不会过大, 不均匀介质需要分段的\\(\\sigma_{\\text{maj}}\\)来更好的拟合介质分布, 因此其余的介质类都将每段存储在网格中, 光线被它所经过的网格分割.\nstruct MajorantGrid { // ... // MajorantGrid Public Members Bounds3f bounds; pstd::vector\u0026lt;Float\u0026gt; voxels; Point3i res; }; 类似于数字微分分析器(digital differential analyzer, DDA)画线算法, pbrt通过DDAMajorantIterator来迭代当前所经过的网格.\nPBRT_CPU_GPU pstd::optional\u0026lt;RayMajorantSegment\u0026gt; Next() { if (tMin \u0026gt;= tMax) return {}; // Find _stepAxis_ for stepping to next voxel and exit point _tVoxelExit_ int bits = ((nextCrossingT[0] \u0026lt; nextCrossingT[1]) \u0026lt;\u0026lt; 2) + ((nextCrossingT[0] \u0026lt; nextCrossingT[2]) \u0026lt;\u0026lt; 1) + ((nextCrossingT[1] \u0026lt; nextCrossingT[2])); const int cmpToAxis[8] = {2, 1, 2, 1, 2, 2, 0, 0}; int stepAxis = cmpToAxis[bits]; Float tVoxelExit = std::min(tMax, nextCrossingT[stepAxis]); // Get _maxDensity_ for current voxel and initialize _RayMajorantSegment_, _seg_ SampledSpectrum sigma_maj = sigma_t * grid-\u0026gt;Lookup(voxel[0], voxel[1], voxel[2]); RayMajorantSegment seg{tMin, tVoxelExit, sigma_maj}; // Advance to next voxel in maximum density grid tMin = tVoxelExit; if (nextCrossingT[stepAxis] \u0026gt; tMax) tMin = tMax; voxel[stepAxis] += step[stepAxis]; if (voxel[stepAxis] == voxelLimit[stepAxis]) tMin = tMax; nextCrossingT[stepAxis] += deltaT[stepAxis]; return seg; } 网格介质 # pbrt通过GridMedium表示网格介质. 网格介质中的\\(\\sigma_a\\)和\\(\\sigma_s\\)是确定的, 通过SampledGrid在不通位置对其施加缩放, \\(sigma_{\\text{maj}}\\)也通过记录当前网格的最大缩放系数来实现.\nfor (int z = 0; z \u0026lt; majorantGrid.res.z; ++z) for (int y = 0; y \u0026lt; majorantGrid.res.y; ++y) for (int x = 0; x \u0026lt; majorantGrid.res.x; ++x) { Bounds3f bounds = majorantGrid.VoxelBounds(x, y, z); majorantGrid.Set(x, y, z, densityGrid.MaxValue(bounds)); } 自发光有两种实现方式, 第一种为设置空间上各个位置的色温, 第二种为设置\\(L_e\\)以及各个位置的缩放系数.\npstd::optional\u0026lt;SampledGrid\u0026lt;Float\u0026gt;\u0026gt; temperatureGrid; DenselySampledSpectrum Le_spec; SampledGrid\u0026lt;Float\u0026gt; LeScale; RGB网格介质 # RGBGridMedium通过RGB网格存储介质信息. 选取区域内的RGB的最大值后转为RGBUnboundedSpectrum, 然后取最大值作为主值, 这样的结果与直接取区域内RGBUnboundedSpectrum的最大值是不同的, 因此pbrt采用RGBUnboundedSpectrum类型而非RGB类型的网格.\nclass RGBGridMedium { public: // RGBGridMedium Public Type Definitions using MajorantIterator = DDAMajorantIterator; // ... private: // RGBGridMedium Private Members Bounds3f bounds; Transform renderFromMedium; pstd::optional\u0026lt;SampledGrid\u0026lt;RGBIlluminantSpectrum\u0026gt;\u0026gt; LeGrid; Float LeScale; HGPhaseFunction phase; pstd::optional\u0026lt;SampledGrid\u0026lt;RGBUnboundedSpectrum\u0026gt;\u0026gt; sigma_aGrid, sigma_sGrid; Float sigmaScale; MajorantGrid majorantGrid; }; 主值通过取区域内各个点的分布中的最大值实现. RGBUnboundedSpectrum本身不支持比较, 因此通过传入lambda函数max来将其转为float.\nfor (int z = 0; z \u0026lt; majorantGrid.res.z; ++z) for (int y = 0; y \u0026lt; majorantGrid.res.y; ++y) for (int x = 0; x \u0026lt; majorantGrid.res.x; ++x) { Bounds3f bounds = majorantGrid.VoxelBounds(x, y, z); // Initialize _majorantGrid_ voxel for RGB $\\sigmaa$ and $\\sigmas$ auto max = [] PBRT_CPU_GPU(RGBUnboundedSpectrum s) { return s.MaxValue(); }; Float maxSigma_t = (sigma_aGrid ? sigma_aGrid-\u0026gt;MaxValue(bounds, max) : 1) + (sigma_sGrid ? sigma_sGrid-\u0026gt;MaxValue(bounds, max) : 1); majorantGrid.Set(x, y, z, sigmaScale * maxSigma_t); } ","date":"2024 December 27","externalUrl":null,"permalink":"/render/1735285145059-pbrt-v4-episode-11/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. XI: 体散射","type":"render"},{"content":" 纹理描述表面上标量或光谱量在空间上的变化, 材质通过求解表面上某个点的纹理来决定其BSDF参数.\n纹理采样与反走样 # 纹理反走样比光线渲染结果反走样要容易, 某些纹理具有解析形式, 同时也可以做预滤波, 通常来说每个像素不会需要多于一个的纹理样本.\nGenerateRayDifferential获取相邻像素发出的光线的相交结果, 此时可以计算当前像素的\\(\\frac{\\partial p}{\\partial u}\\)和\\(\\frac{\\partial p}{\\partial v}\\), pbrt会根据交点的位置与法线构建切平面, 让相交光线与切平面相交来获取微分估计值.\n对于例如漫反射的难以计算微分的情况以及不支持GenerateRayDifferential的相机, pbrt会将相机变换到朝向交点的方向, 根据相机提供的最小光线位置与方向的微分来生成微分光线, 再变换回渲染空间.\nPBRT_CPU_GPU void Approximate_dp_dxy(Point3f p, Normal3f n, Float time, int samplesPerPixel, Vector3f *dpdx, Vector3f *dpdy) const { // Compute tangent plane equation for ray differential intersections Point3f pCamera = CameraFromRender(p, time); Transform DownZFromCamera = RotateFromTo(Normalize(Vector3f(pCamera)), Vector3f(0, 0, 1)); Point3f pDownZ = DownZFromCamera(pCamera); Normal3f nDownZ = DownZFromCamera(CameraFromRender(n, time)); Float d = nDownZ.z * pDownZ.z; // Find intersection points for approximated camera differential rays Ray xRay(Point3f(0, 0, 0) + minPosDifferentialX, Vector3f(0, 0, 1) + minDirDifferentialX); Float tx = -(Dot(nDownZ, Vector3f(xRay.o)) - d) / Dot(nDownZ, xRay.d); Ray yRay(Point3f(0, 0, 0) + minPosDifferentialY, Vector3f(0, 0, 1) + minDirDifferentialY); Float ty = -(Dot(nDownZ, Vector3f(yRay.o)) - d) / Dot(nDownZ, yRay.d); Point3f px = xRay(tx), py = yRay(ty); // Estimate $\\dpdx$ and $\\dpdy$ in tangent plane at intersection point Float sppScale = GetOptions().disablePixelJitter ? 1 : std::max\u0026lt;Float\u0026gt;(.125, 1 / std::sqrt((Float)samplesPerPixel)); *dpdx = sppScale * RenderFromCamera(DownZFromCamera.ApplyInverse(px - pDownZ), time); *dpdy = sppScale * RenderFromCamera(DownZFromCamera.ApplyInverse(py - pDownZ), time); } 正交投影各个像素上的光线位置变化与渲染空间一致, 光线方向不变, 因此可以直接获取微分. 其它相机会遍历屏幕对角线上的像素, 计算各个像素发射的光线, 比较这些光线以获取光线位置与方向的最小变化值作为微分.\nvoid CameraBase::FindMinimumDifferentials(Camera camera) { minPosDifferentialX = minPosDifferentialY = minDirDifferentialX = minDirDifferentialY = Vector3f(Infinity, Infinity, Infinity); CameraSample sample; sample.pLens = Point2f(0.5, 0.5); sample.time = 0.5; SampledWavelengths lambda = SampledWavelengths::SampleVisible(0.5); int n = 512; for (int i = 0; i \u0026lt; n; ++i) { sample.pFilm.x = Float(i) / (n - 1) * film.FullResolution().x; sample.pFilm.y = Float(i) / (n - 1) * film.FullResolution().y; pstd::optional\u0026lt;CameraRayDifferential\u0026gt; crd = camera.GenerateRayDifferential(sample, lambda); if (!crd) continue; RayDifferential \u0026amp;ray = crd-\u0026gt;ray; Vector3f dox = CameraFromRender(ray.rxOrigin - ray.o, ray.time); if (Length(dox) \u0026lt; Length(minPosDifferentialX)) minPosDifferentialX = dox; Vector3f doy = CameraFromRender(ray.ryOrigin - ray.o, ray.time); if (Length(doy) \u0026lt; Length(minPosDifferentialY)) minPosDifferentialY = doy; ray.d = Normalize(ray.d); ray.rxDirection = Normalize(ray.rxDirection); ray.ryDirection = Normalize(ray.ryDirection); Frame f = Frame::FromZ(ray.d); Vector3f df = f.ToLocal(ray.d); // should be (0, 0, 1); Vector3f dxf = Normalize(f.ToLocal(ray.rxDirection)); Vector3f dyf = Normalize(f.ToLocal(ray.ryDirection)); if (Length(dxf - df) \u0026lt; Length(minDirDifferentialX)) minDirDifferentialX = dxf - df; if (Length(dyf - df) \u0026lt; Length(minDirDifferentialY)) minDirDifferentialY = dyf - df; } LOG_VERBOSE(\u0026#34;Camera min pos differentials: %s, %s\u0026#34;, minPosDifferentialX, minPosDifferentialY); LOG_VERBOSE(\u0026#34;Camera min dir differentials: %s, %s\u0026#34;, minDirDifferentialX, minDirDifferentialY); } 令\\((u, v)\\)为纹理坐标, \\((x,y)\\)为像素坐标, 根据与形状的相交结果可以获取\\(\\frac{\\partial p}{\\partial u}\\)和\\(\\frac{\\partial p}{\\partial v}\\), 根据光线微分可以获取\\(\\frac{\\partial p}{\\partial x}\\)和\\(\\frac{\\partial p}{\\partial y}\\), 通过链式法则可以获取\\(\\frac{\\partial u}{\\partial x}\\), \\(\\frac{\\partial u}{\\partial y}\\), \\(\\frac{\\partial v}{\\partial x}\\)和\\(\\frac{\\partial v}{\\partial y}\\). 这可以通过最小二乘法求解, 其计算过程如下, 此时\\(\\bold{A}=\\begin{bmatrix}\\frac{\\partial p}{\\partial u}\\ \\frac{\\partial p}{\\partial v}\\end{bmatrix}\\),\\(\\bold{b}=\\begin{bmatrix}\\frac{\\partial p}{\\partial x}\\end{bmatrix}\\),\\(\\bold{x}=\\begin{bmatrix}\\frac{\\partial u}{\\partial x}\\\\\\frac{\\partial v}{\\partial x}\\end{bmatrix}\\).\n$$ \\begin{equation} \\begin{aligned} \\bold{A}\\bold{x}\u0026amp;=\\bold{b}\\\\ \\bold{x}\u0026amp;=(\\bold{A}^T \\bold{A})^{-1}\\bold{A}^T \\bold{b} \\end{aligned} \\end{equation} $$\n介质过渡处的光线微分 # 当光线与表示介质过渡但不散射光线的表面相交是, pbrt会返回未设置的BSDF, 光线会将原点设置为交点后继续执行路径追踪, 光线微分也具有同样的行为.\n镜面反射与透射的光线微分 # 通过反射或折射可见的物体同样需要反走样, 例如镜子中的物体.\n反射方向的偏导数如下, 式中的偏导数都是可以计算出来的.\n$$ \\begin{equation} \\begin{aligned} \\frac{\\partial \\omega_i}{\\partial x} \u0026amp;=\\frac{\\partial}{\\partial x}(-\\omega_o+2(\\omega_o\\cdot\\bold{n})\\bold{n})\\\\ \u0026amp;=-\\frac{\\partial\\omega_o}{\\partial x}+2((\\omega_o\\cdot\\bold{n})\\frac{\\partial\\bold{n}}{\\partial x}+\\bold{n}\\frac{\\partial(\\omega_o\\cdot\\bold{n})}{\\partial x})\\\\ \u0026amp;=-\\frac{\\partial\\omega_o}{\\partial x}+2((\\omega_o\\cdot\\bold{n})\\frac{\\partial\\bold{n}}{\\partial x}+\\bold{n}(\\bold{n}\\frac{\\partial\\omega_o}{\\partial x}+\\omega_o\\frac{\\partial\\bold{n}}{\\partial x})) \\end{aligned} \\end{equation} $$\n根据折射光线方向的定义可以得到其微分, 其中\\(\\mu=\\frac{1}{\\eta}(\\omega_o\\cdot\\bold{n})-\\cos\\theta_i\\). \\(\\frac{\\partial\\mu}{\\partial x}\\)中包含\\(\\frac{\\partial\\cos\\theta_i}{\\partial x}\\), 这可以通过Snell定律得到.\n$$ \\begin{equation} \\frac{\\partial\\omega_i}{\\partial x}=-\\frac{1}{\\eta}\\frac{\\partial\\omega_o}{\\partial x}+\\mu\\frac{\\partial\\bold{n}}{\\partial x}+\\frac{\\partial\\mu}{\\partial x}\\bold{n} \\end{equation} $$\n纹理方程滤波 # 反走样需要限制信号带宽, 去除纹理中频率高于Nyquist频率的部分, 对应的卷积如下, \\(f\\)为将像素坐标映射到纹理坐标的函数. 根据之前章节的内容, 我们可以知道其Fourier变换相当于与盒形方程相乘, 这可以直接去除高频部分.\n$$ \\begin{equation} T_b(x,y)=\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}\\text{sinc}(x\u0026rsquo;)\\text{sinc}(y\u0026rsquo;)T\u0026rsquo;(f(x-x\u0026rsquo;,y-y\u0026rsquo;))dx\u0026rsquo;dy' \\end{equation} $$\n限制带宽后还需要还需要执行采样, \\(g\\)为采样所用的滤波器.\n$$ \\begin{equation} T_{\\text{ideal}}(x,y)=\\int_{-\\frac{w_x}{2}}^{\\frac{w_x}{2}}\\int_{-\\frac{w_x}{2}}^{\\frac{w_x}{2}}g(x\u0026rsquo;,y\u0026rsquo;)T_b(x-x\u0026rsquo;,y-y\u0026rsquo;)dx\u0026rsquo;dy' \\end{equation} $$\n这类理想采样实际上只对线性变化的量有效, 例如albedo对光照的贡献的变化, 而像roughness对BSDF的贡献就是非线性的, pbrt不考虑这点.\n在纹理滤波这一任务上, 盒形滤波也可以取得较好的效果, 且计算过程简单, 其定义如下, 其中\\(u_0=u-\\frac{1}{2}\\max(\\frac{du}{dx},\\frac{dv}{dx})\\), \\(u_1=u+\\frac{1}{2}\\max(\\frac{du}{dx},\\frac{dv}{dx})\\), \\(v_0\\), \\(v_1\\)同理.\n$$ \\begin{equation} T_{\\text{box}}(x,y)=\\frac{1}{(u_1-u_0)(v_1-v_0)}\\int_{v_0}^{v_1}\\int_{u_0}^{u_1}T(u\u0026rsquo;,v\u0026rsquo;)du\u0026rsquo;dv' \\end{equation} $$\n纹理坐标生成 # 对于参数化几何形状, 纹理坐标是与生俱来的属性. 对于三维纹理, 几何位置就是最佳纹理坐标. 对于其它情况, 纹理坐标需要手动生成, 或者像球的极点一样, 虽然有纹理坐标但是扭曲较为严重, 需要重新生成. pbrt使用\\((u,v)\\)表示参数化表面本来的纹理坐标, \\((s,t)\\)表示生成的纹理坐标.\nTextureMapping2D接口负责二维纹理坐标的生成.\nclass TextureMapping2D : public TaggedPointer\u0026lt;UVMapping, SphericalMapping, CylindricalMapping, PlanarMapping\u0026gt; { public: // TextureMapping2D Interface using TaggedPointer::TaggedPointer; PBRT_CPU_GPU TextureMapping2D( TaggedPointer\u0026lt;UVMapping, SphericalMapping, CylindricalMapping, PlanarMapping\u0026gt; tp) : TaggedPointer(tp) {} static TextureMapping2D Create(const ParameterDictionary \u0026amp;parameters, const Transform \u0026amp;renderFromTexture, const FileLoc *loc, Allocator alloc); PBRT_CPU_GPU inline TexCoord2D Map(TextureEvalContext ctx) const; }; Map负责执行映射, 返回的TexCoord2D的定义如下, 其中包含\\((s,t)\\)坐标及其导数.\nstruct TexCoord2D { Point2f st; Float dsdx, dsdy, dtdx, dtdy; std::string ToString() const; }; Map参数为TextureEvalContext而非SurfaceInteraction是因为考虑到了GPU的缓存结构, 其定义如下.\nstruct TextureEvalContext { // TextureEvalContext Public Methods TextureEvalContext() = default; PBRT_CPU_GPU TextureEvalContext(const Interaction \u0026amp;intr) : p(intr.p()), uv(intr.uv) {} PBRT_CPU_GPU TextureEvalContext(const SurfaceInteraction \u0026amp;si) : p(si.p()), dpdx(si.dpdx), dpdy(si.dpdy), n(si.n), uv(si.uv), dudx(si.dudx), dudy(si.dudy), dvdx(si.dvdx), dvdy(si.dvdy), faceIndex(si.faceIndex) {} PBRT_CPU_GPU TextureEvalContext(Point3f p, Vector3f dpdx, Vector3f dpdy, Normal3f n, Point2f uv, Float dudx, Float dudy, Float dvdx, Float dvdy, int faceIndex) : p(p), dpdx(dpdx), dpdy(dpdy), n(n), uv(uv), dudx(dudx), dudy(dudy), dvdx(dvdx), dvdy(dvdy), faceIndex(faceIndex) {} std::string ToString() const; Point3f p; Vector3f dpdx, dpdy; Normal3f n; Point2f uv; Float dudx = 0, dudy = 0, dvdx = 0, dvdy = 0; int faceIndex = 0; }; \\((u,v)\\)映射 # \\((u,v)\\)映射通过对\\((u,v)\\)坐标的缩放与偏移实现, 定义如下, \\(\\frac{ds}{dx}\\)通过链式法则得到.\nclass UVMapping { public: // UVMapping Public Methods UVMapping(Float su = 1, Float sv = 1, Float du = 0, Float dv = 0) : su(su), sv(sv), du(du), dv(dv) {} std::string ToString() const; PBRT_CPU_GPU TexCoord2D Map(TextureEvalContext ctx) const { // Compute texture differentials for 2D $(u,v)$ mapping Float dsdx = su * ctx.dudx, dsdy = su * ctx.dudy; Float dtdx = sv * ctx.dvdx, dtdy = sv * ctx.dvdy; Point2f st(su * ctx.uv[0] + du, sv * ctx.uv[1] + dv); return TexCoord2D{st, dsdx, dsdy, dtdx, dtdy}; } private: Float su, sv, du, dv; }; 球形映射 # 球形映射定义如下, \\(\\text{atan2}\\)代表\\(p_x,p_y\\)所形成的角度, 通过std::atan2获取, 可以正确的处理符号与象限. 这里认为得到的角度范围在\\([0,2\\pi]\\),而非实际返回的\\([-\\pi,\\pi]\\).\n$$ \\begin{equation} f(p)=(\\frac{1}{\\pi}\\text{arccos}\\frac{p_x}{\\Vert p_x^2+p_y^2+p_z^2 \\Vert}, \\frac{1}{2\\pi}\\text{atan2}(p_y,p_x)) \\end{equation} $$\n圆柱映射 # 圆柱映射定义如下, 注意到\\(t\\)坐标需要被缩放, 或者通过某种手段采样超出范围的纹理.\n$$ \\begin{equation} f(p)=(\\frac{1}{2\\pi}\\text{atan2}(p_y,p_x),p_z) \\end{equation} $$\n平面映射 # 平面映射通过两个不平行的向量和偏移定义.\n$$ \\begin{equation} f(p)=((p-(0,0,0)\\cdot\\bold{v}_s)+d_s,(p-(0,0,0)\\cdot\\bold{v}_t)+d_t) \\end{equation} $$\n三维映射 # 通过几何坐标采样纹理即可.\n纹理接口与基础纹理 # pbrt支持浮点类型的标量纹理与光谱量纹理, 本文只记录光谱量纹理的定义, 其定义如下. SpectrumTexture的Evaluate需要考虑波长.\nclass SpectrumTexture : public TaggedPointer\u0026lt; // SpectrumTextures SpectrumImageTexture, GPUSpectrumImageTexture, SpectrumMixTexture, SpectrumDirectionMixTexture, SpectrumScaledTexture, SpectrumConstantTexture, SpectrumBilerpTexture, SpectrumCheckerboardTexture, MarbleTexture, SpectrumDotsTexture, SpectrumPtexTexture, GPUSpectrumPtexTexture \u0026gt; { public: // SpectrumTexture Interface using TaggedPointer::TaggedPointer; static SpectrumTexture Create(const std::string \u0026amp;name, const Transform \u0026amp;renderFromTexture, const TextureParameterDictionary \u0026amp;parameters, SpectrumType spectrumType, const FileLoc *loc, Allocator alloc, bool gpu); std::string ToString() const; PBRT_CPU_GPU inline SampledSpectrum Evaluate(TextureEvalContext ctx, SampledWavelengths lambda) const; }; 常量纹理 # 常量纹理主要用于表示材质的某些参数, 使得材质只需要考虑纹理接口.\nPBRT_CPU_GPU SampledSpectrum Evaluate(TextureEvalContext ctx, SampledWavelengths lambda) const { return value.Sample(lambda); } 缩放纹理 # 缩放纹理通过将两张纹理相乘获取新的纹理.\nPBRT_CPU_GPU SampledSpectrum Evaluate(TextureEvalContext ctx, SampledWavelengths lambda) const { Float sc = scale.Evaluate(ctx); if (sc == 0) return SampledSpectrum(0.f); return tex.Evaluate(ctx, lambda) * sc; } 混合纹理 # 混合纹理通过混合系数来混合两张纹理.\nPBRT_CPU_GPU SampledSpectrum Evaluate(TextureEvalContext ctx, SampledWavelengths lambda) const { Float amt = amount.Evaluate(ctx); SampledSpectrum t1, t2; if (amt != 1) t1 = tex1.Evaluate(ctx, lambda); if (amt != 0) t2 = tex2.Evaluate(ctx, lambda); return (1 - amt) * t1 + amt * t2; } 图像纹理 # 图像纹理可以在任意位置被采样, 采样值被称为纹素(texel), 它是图形学中被使用最多的纹理类型. 图像纹理继承ImageTextureBase, 同样可以返回标量或光谱量.\nclass ImageTextureBase { public: // ImageTextureBase Public Methods ImageTextureBase(TextureMapping2D mapping, std::string filename, MIPMapFilterOptions filterOptions, WrapMode wrapMode, Float scale, bool invert, ColorEncoding encoding, Allocator alloc) : mapping(mapping), filename(filename), scale(scale), invert(invert) { // Get _MIPMap_ from texture cache if present TexInfo texInfo(filename, filterOptions, wrapMode, encoding); std::unique_lock\u0026lt;std::mutex\u0026gt; lock(textureCacheMutex); if (auto iter = textureCache.find(texInfo); iter != textureCache.end()) { mipmap = iter-\u0026gt;second; return; } lock.unlock(); // Create _MIPMap_ for _filename_ and add to texture cache mipmap = MIPMap::CreateFromFile(filename, filterOptions, wrapMode, encoding, alloc); lock.lock(); // This is actually ok, but if it hits, it means we\u0026#39;ve wastefully // loaded this texture. (Note that in that case, should just return // the one that\u0026#39;s already in there and not replace it.) CHECK(textureCache.find(texInfo) == textureCache.end()); textureCache[texInfo] = mipmap; } static void ClearCache() { textureCache.clear(); } void MultiplyScale(Float s) { scale *= s; } protected: // ImageTextureBase Protected Members TextureMapping2D mapping; std::string filename; Float scale; bool invert; MIPMap *mipmap; private: // ImageTextureBase Private Members static std::mutex textureCacheMutex; static std::map\u0026lt;TexInfo, MIPMap *\u0026gt; textureCache; }; class SpectrumImageTexture : public ImageTextureBase { public: // SpectrumImageTexture Public Methods SpectrumImageTexture(TextureMapping2D mapping, std::string filename, MIPMapFilterOptions filterOptions, WrapMode wrapMode, Float scale, bool invert, ColorEncoding encoding, SpectrumType spectrumType, Allocator alloc) : ImageTextureBase(mapping, filename, filterOptions, wrapMode, scale, invert, encoding, alloc), spectrumType(spectrumType) {} PBRT_CPU_GPU SampledSpectrum Evaluate(TextureEvalContext ctx, SampledWavelengths lambda) const; static SpectrumImageTexture *Create(const Transform \u0026amp;renderFromTexture, const TextureParameterDictionary \u0026amp;parameters, SpectrumType spectrumType, const FileLoc *loc, Allocator alloc); std::string ToString() const; private: // SpectrumImageTexture Private Members SpectrumType spectrumType; }; 纹理内存管理 # pbrt会生成mipmap来处理图像滤波, mipmap只生成一次, 之后通过textureCache读取.\nTexInfo texInfo(filename, filterOptions, wrapMode, encoding); std::unique_lock\u0026lt;std::mutex\u0026gt; lock(textureCacheMutex); if (auto iter = textureCache.find(texInfo); iter != textureCache.end()) { mipmap = iter-\u0026gt;second; return; } lock.unlock(); 图像纹理求解 # pbrt中图像以左下角为原点, 而纹理坐标位于左上角, 这需要手动处理.\n通过图像中的RGBColorSpace与SpectrumType可以从RGB中还原光谱, 对于没有色彩空间信息的图像, pbrt认为是灰度图.\nif (const RGBColorSpace *cs = mipmap-\u0026gt;GetRGBColorSpace(); cs) { if (spectrumType == SpectrumType::Unbounded) return RGBUnboundedSpectrum(*cs, rgb).Sample(lambda); else if (spectrumType == SpectrumType::Albedo) return RGBAlbedoSpectrum(*cs, Clamp(rgb, 0, 1)).Sample(lambda); else return RGBIlluminantSpectrum(*cs, rgb).Sample(lambda); } DCHECK(rgb[0] == rgb[1] \u0026amp;\u0026amp; rgb[1] == rgb[2]); return SampledSpectrum(rgb[0]); mipmap # mipmap通过将图像预处理为图像金字塔来减小滤波开销, 即每一层为上一层分辨率的一半, mipmap所需的内存只比原图多\\(\\frac{1}{3}\\).\n图像滤波 # pbrt支持以下四种滤波, 除EWA外都具有GPU硬件支持, 根据最大梯度执行各向同性滤波, pbrt会选择使得滤波窗口覆盖四个像素的mip层级. 点滤波只需要选取四个像素中最近的采样点, 双线性插值为三角形滤波, 三线形插值则根据计算出的非整数层级来混合相邻两个层级的双线性滤波结果.\nenum class FilterFunction { Point, Bilinear, Trilinear, EWA }; EWA为椭圆加权平均(elliptically weighted average), 它会在不同方向使用不同的梯度, 即各向异性滤波, 且不要求方向与\\(x\\)轴或\\(y\\)轴平行. EWA的带限和滤波过程都采用Gaussian滤波器, 而非上述方法所用的盒滤波器带限. pbrt使用短轴长度选择mip层级, 若长短轴比率过大会导致过多的采样点, pbrt会适当增长短轴以使用更高的mip层级, 虽然会有模糊但并不明显\nEWA根据梯度计算得到椭圆, 其形式如下, 然后根据椭圆的梯度得到包围盒, 此时可以选取包围盒内位于椭圆内部的点执行滤波.\n$$ \\begin{equation} \\begin{aligned} e(s,t)\u0026amp;=\\frac{A}{F}s^2+\\frac{B}{F}st+\\frac{C}{F}t^2\u0026lt;1\\\\ A\u0026amp;=(\\frac{\\partial s}{\\partial y})^2+(\\frac{\\partial t}{\\partial y})^2+1\\\\ B\u0026amp;=-2(\\frac{\\partial s}{\\partial x}\\frac{\\partial s}{\\partial y}+\\frac{\\partial t}{\\partial x}\\frac{\\partial t}{\\partial y})\\\\ C\u0026amp;=(\\frac{\\partial s}{\\partial x})^2+(\\frac{\\partial t}{\\partial x})^2+1\\\\ F\u0026amp;=AC-\\frac{B^2}{4} \\end{aligned} \\end{equation} $$\n已知\\(e(s,t)\\)为某个点到椭圆中心的距离与对应直线上的椭圆边界到中心的距离的比值的平方, 这与Gaussian滤波器的定义相符, 因此可以通过该值来查表获取滤波权重.\n材质接口与实现 # 材质用于求解纹理获取参数后初始化BSDF, 其定义如下.\nclass Material : public TaggedPointer\u0026lt; // Material Types CoatedDiffuseMaterial, CoatedConductorMaterial, ConductorMaterial, DielectricMaterial, DiffuseMaterial, DiffuseTransmissionMaterial, HairMaterial, MeasuredMaterial, SubsurfaceMaterial, ThinDielectricMaterial, MixMaterial \u0026gt; { public: // Material Interface using TaggedPointer::TaggedPointer; static Material Create(const std::string \u0026amp;name, const TextureParameterDictionary \u0026amp;parameters, Image *normalMap, /*const */ std::map\u0026lt;std::string, Material\u0026gt; \u0026amp;namedMaterials, const FileLoc *loc, Allocator alloc); std::string ToString() const; template \u0026lt;typename TextureEvaluator\u0026gt; inline BSDF GetBSDF(TextureEvaluator texEval, MaterialEvalContext ctx, SampledWavelengths \u0026amp;lambda, ScratchBuffer \u0026amp;buf) const; template \u0026lt;typename TextureEvaluator\u0026gt; inline BSSRDF GetBSSRDF(TextureEvaluator texEval, MaterialEvalContext ctx, SampledWavelengths \u0026amp;lambda, ScratchBuffer \u0026amp;buf) const; template \u0026lt;typename TextureEvaluator\u0026gt; PBRT_CPU_GPU inline bool CanEvaluateTextures(TextureEvaluator texEval) const; PBRT_CPU_GPU inline const Image *GetNormalMap() const; PBRT_CPU_GPU inline FloatTexture GetDisplacement() const; PBRT_CPU_GPU inline bool HasSubsurfaceScattering() const; }; Material最核心的方法为GetBxDF, 这里的返回值ConcreteBxDF对于每个派生类都是不同的. pbrt在这里不要求函数签名相同, 这使得BxDF被分配在栈上而非堆上, 有利于GPU渲染.\ntemplate \u0026lt;typename TextureEvaluator\u0026gt; PBRT_CPU_GPU ConcreteBxDF GetBxDF(TextureEvaluator texEval, MaterialEvalContext ctx, SampledWavelengths \u0026amp;lambda) const; GetBSDF会调用GetBxDF, 这里通过模板获取实际的返回类型.\ntemplate \u0026lt;typename TextureEvaluator\u0026gt; inline BSDF Material::GetBSDF(TextureEvaluator texEval, MaterialEvalContext ctx, SampledWavelengths \u0026amp;lambda, ScratchBuffer \u0026amp;scratchBuffer) const { // Define _getBSDF_ lambda function for _Material::GetBSDF()_ auto getBSDF = [\u0026amp;](auto mtl) -\u0026gt; BSDF { using ConcreteMtl = typename std::remove_reference_t\u0026lt;decltype(*mtl)\u0026gt;; using ConcreteBxDF = typename ConcreteMtl::BxDF; if constexpr (std::is_same_v\u0026lt;ConcreteBxDF, void\u0026gt;) return BSDF(); else { // Allocate memory for _ConcreteBxDF_ and return _BSDF_ for material ConcreteBxDF *bxdf = scratchBuffer.Alloc\u0026lt;ConcreteBxDF\u0026gt;(); *bxdf = mtl-\u0026gt;GetBxDF(texEval, ctx, lambda); return BSDF(ctx.ns, ctx.dpdus, bxdf); } }; return DispatchCPU(getBSDF); } 包含了次表面散射的材质需要实现GetBSSRDF, 实现上与GetBSDF类似.\ntemplate \u0026lt;typename TextureEvaluator\u0026gt; PBRT_CPU_GPU ConcreteBSSRDF GetBSSRDF(TextureEvaluator texEval, const MaterialEvalContext \u0026amp;ctx, SampledWavelengths \u0026amp;lambda) const; template \u0026lt;typename TextureEvaluator\u0026gt; inline BSSRDF Material::GetBSSRDF(TextureEvaluator texEval, MaterialEvalContext ctx, SampledWavelengths \u0026amp;lambda, ScratchBuffer \u0026amp;scratchBuffer) const { auto get = [\u0026amp;](auto mtl) -\u0026gt; BSSRDF { using Material = typename std::remove_reference_t\u0026lt;decltype(*mtl)\u0026gt;; using MaterialBSSRDF = typename Material::BSSRDF; if constexpr (std::is_same_v\u0026lt;MaterialBSSRDF, void\u0026gt;) return nullptr; else { MaterialBSSRDF *bssrdf = scratchBuffer.Alloc\u0026lt;MaterialBSSRDF\u0026gt;(); *bssrdf = mtl-\u0026gt;GetBSSRDF(texEval, ctx, lambda); return BSSRDF(bssrdf); } }; return DispatchCPU(get); } MaterialEvalContext与TextureEvalContext类似, 包含了求解材质的必要信息, 这些信息包含在TextureEvalContext中, 因此pbrt采用了继承.\nstruct MaterialEvalContext : public TextureEvalContext { // MaterialEvalContext Public Methods MaterialEvalContext() = default; PBRT_CPU_GPU MaterialEvalContext(const SurfaceInteraction \u0026amp;si) : TextureEvalContext(si), wo(si.wo), ns(si.shading.n), dpdus(si.shading.dpdu) {} std::string ToString() const; Vector3f wo; Normal3f ns; Vector3f dpdus; }; pbrt通过TextureEvaluator求解纹理, 而非直接调用Texture::Evaluate, 这使得pbrt可以在GPU上根据TextureEvaluator::CanEvaluate返回的信息预先判断材质是否具有重量级的纹理, 并将这两种纹理分离. 在CPU上pbrt只使用UniversalTextureEvaluator, 它内部直接调用Evaluate.\nSampledSpectrum UniversalTextureEvaluator::operator()(SpectrumTexture tex, TextureEvalContext ctx, SampledWavelengths lambda) { return tex.Evaluate(ctx, lambda); } 材质实现 # 漫反射材质 # 漫反射的GetBxDF会将反射值限制在\\([0,1]\\).\ntemplate \u0026lt;typename TextureEvaluator\u0026gt; DiffuseBxDF GetBxDF(TextureEvaluator texEval, MaterialEvalContext ctx, SampledWavelengths \u0026amp;lambda) const { SampledSpectrum r = Clamp(texEval(reflectance, ctx, lambda), 0, 1); return DiffuseBxDF(r); } 绝缘体材质 # DielectricMaterial的IOR通过光谱分布存储, 光谱渲染时会导致散射, pbrt在折射时通过TerminateSecondary来只保留一条光线, 除非IOR是常量.\ntemplate \u0026lt;typename TextureEvaluator\u0026gt; PBRT_CPU_GPU DielectricBxDF GetBxDF(TextureEvaluator texEval, MaterialEvalContext ctx, SampledWavelengths \u0026amp;lambda) const { // Compute index of refraction for dielectric material Float sampledEta = eta(lambda[0]); if (!eta.template Is\u0026lt;ConstantSpectrum\u0026gt;()) lambda.TerminateSecondary(); // Handle edge case in case lambda[0] is beyond the wavelengths stored by the // Spectrum. if (sampledEta == 0) sampledEta = 1; // Create microfacet distribution for dielectric material Float urough = texEval(uRoughness, ctx), vrough = texEval(vRoughness, ctx); if (remapRoughness) { urough = TrowbridgeReitzDistribution::RoughnessToAlpha(urough); vrough = TrowbridgeReitzDistribution::RoughnessToAlpha(vrough); } TrowbridgeReitzDistribution distrib(urough, vrough); // Return BSDF for dielectric material return DielectricBxDF(sampledEta, distrib); } 混合材质 # 混合材质无法返回BSDF, 因此这里的混合是概率上的混合, 每次随机选取一个材质来执行材质求解.\ntemplate \u0026lt;typename TextureEvaluator\u0026gt; Material ChooseMaterial(TextureEvaluator texEval, MaterialEvalContext ctx) const { Float amt = texEval(amount, ctx); if (amt \u0026lt;= 0) return materials[0]; if (amt \u0026gt;= 1) return materials[1]; Float u = HashFloat(ctx.p, ctx.wo, materials[0], materials[1]); return (amt \u0026lt; u) ? materials[0] : materials[1]; } 获取表面BSDF # pbrt的Integrator通过SurfaceInteraction获取表面信息, 因此需要SurfaceInteraction返回BSDF.\nBSDF SurfaceInteraction::GetBSDF(const RayDifferential \u0026amp;ray, SampledWavelengths \u0026amp;lambda, Camera camera, ScratchBuffer \u0026amp;scratchBuffer, Sampler sampler) { // Estimate $(u,v)$ and position differentials at intersection point ComputeDifferentials(ray, camera, sampler.SamplesPerPixel()); // Resolve _MixMaterial_ if necessary while (material.Is\u0026lt;MixMaterial\u0026gt;()) { MixMaterial *mix = material.Cast\u0026lt;MixMaterial\u0026gt;(); material = mix-\u0026gt;ChooseMaterial(UniversalTextureEvaluator(), *this); } // Return unset _BSDF_ if surface has a null material if (!material) return {}; // Evaluate normal or bump map, if present FloatTexture displacement = material.GetDisplacement(); const Image *normalMap = material.GetNormalMap(); if (displacement || normalMap) { // Get shading $\\dpdu$ and $\\dpdv$ using normal or bump map Vector3f dpdu, dpdv; if (normalMap) NormalMap(*normalMap, *this, \u0026amp;dpdu, \u0026amp;dpdv); else BumpMap(UniversalTextureEvaluator(), displacement, *this, \u0026amp;dpdu, \u0026amp;dpdv); Normal3f ns(Normalize(Cross(dpdu, dpdv))); SetShadingGeometry(ns, dpdu, dpdv, shading.dndu, shading.dndv, false); } // Return BSDF for surface interaction BSDF bsdf = material.GetBSDF(UniversalTextureEvaluator(), *this, lambda, scratchBuffer); if (bsdf \u0026amp;\u0026amp; GetOptions().forceDiffuse) { // Override _bsdf_ with diffuse equivalent SampledSpectrum r = bsdf.rho(wo, {sampler.Get1D()}, {sampler.Get2D()}); bsdf = BSDF(shading.n, shading.dpdu, scratchBuffer.Alloc\u0026lt;DiffuseBxDF\u0026gt;(r)); } return bsdf; } 法线映射 # 法线映射通过法线纹理实现, 纹理中存储的是切线空间下的法线, 在pbrt中即以法线为\\(z\\)轴, 切线为\\(x\\)轴. 在pbrt-v4中只有法线纹理是明确要用RGB存储的, 因此只存储在图片中, 通过NormalMap函数返回.\ninline PBRT_CPU_GPU void NormalMap(const Image \u0026amp;normalMap, const NormalBumpEvalContext \u0026amp;ctx, Vector3f *dpdu, Vector3f *dpdv) { // Get normalized normal vector from normal map WrapMode2D wrap(WrapMode::Repeat); Point2f uv(ctx.uv[0], 1 - ctx.uv[1]); Vector3f ns(2 * normalMap.BilerpChannel(uv, 0, wrap) - 1, 2 * normalMap.BilerpChannel(uv, 1, wrap) - 1, 2 * normalMap.BilerpChannel(uv, 2, wrap) - 1); ns = Normalize(ns); // Transform tangent-space normal to rendering space Frame frame = Frame::FromXZ(Normalize(ctx.shading.dpdu), Vector3f(ctx.shading.n)); ns = frame.FromLocal(ns); // Find $\\dpdu$ and $\\dpdv$ that give shading normal Float ulen = Length(ctx.shading.dpdu), vlen = Length(ctx.shading.dpdv); *dpdu = Normalize(GramSchmidt(ctx.shading.dpdu, ns)) * ulen; *dpdv = Normalize(Cross(ns, *dpdu)) * vlen; } NormalBumpEvalContext定义如下.\nstruct NormalBumpEvalContext { // NormalBumpEvalContext Public Methods NormalBumpEvalContext() = default; PBRT_CPU_GPU NormalBumpEvalContext(const SurfaceInteraction \u0026amp;si) : p(si.p()), uv(si.uv), n(si.n), dudx(si.dudx), dudy(si.dudy), dvdx(si.dvdx), dvdy(si.dvdy), dpdx(si.dpdx), dpdy(si.dpdy), faceIndex(si.faceIndex) { shading.n = si.shading.n; shading.dpdu = si.shading.dpdu; shading.dpdv = si.shading.dpdv; shading.dndu = si.shading.dndu; shading.dndv = si.shading.dndv; } std::string ToString() const; PBRT_CPU_GPU operator TextureEvalContext() const { return TextureEvalContext(p, dpdx, dpdy, n, uv, dudx, dudy, dvdx, dvdy, faceIndex); } // NormalBumpEvalContext Public Members Point3f p; Point2f uv; Normal3f n; struct { Normal3f n; Vector3f dpdu, dpdv; Normal3f dndu, dndv; } shading; Float dudx = 0, dudy = 0, dvdx = 0, dvdy = 0; Vector3f dpdx, dpdy; int faceIndex = 0; }; 视差映射 # 视差纹理记录表面高度, 以此生成新的几何位置和法线.\n$$ \\begin{equation} p\u0026rsquo;(u,v)=p(u,v)+d(u,v)\\bold{n}(u,v) \\end{equation} $$\n此时可以得到新的导数, 由于\\(d(u,v)\\)通常很小, 有些渲染器会省略最后一项.\n$$ \\begin{equation} \\frac{\\partial p\u0026rsquo;}{\\partial u}=\\frac{\\partial p(u,v)}{\\partial u}+\\bold{n}(u,v)\\frac{\\partial d(u,v)}{\\partial u}+d(u,v)\\frac{\\partial\\bold{n}(u,v)}{\\partial u} \\end{equation} $$\n\\(d(u,v)\\)的导数可以通过导数的定义来计算.\n$$ \\begin{equation} \\frac{\\partial d(u,v)}{\\partial u}=\\lim_{\\Delta_u \\to 0}\\frac{d(u+\\Delta_u,v)-d(u,v)}{\\Delta_u} \\end{equation} $$\n\\(\\Delta_u\\)的计算方式如下, 这里考虑到了浮点精度.\nFloat du = .5f * (std::abs(ctx.dudx) + std::abs(ctx.dudy)); if (du == 0) du = .0005f; shiftedCtx.p = ctx.p + du * ctx.shading.dpdu; shiftedCtx.uv = ctx.uv + Vector2f(du, 0.f); ","date":"2024 December 24","externalUrl":null,"permalink":"/render/1735024711799-pbrt-v4-episode-10/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. X: 材质纹理","type":"render"},{"content":" pbrt将反射分为以下四类: 漫反射, 光滑镜面反射, 完美镜面反射, 回溯反射. 反射分布方程可以被分为各向同性与各向异性的, 若将物体旋转时在各个角度上具有相同的反射结果即位各向同性, 反之则为各向异性.\nBSDF表示 # pbrt中BxDF接口代表特定种类表面散射的实现, BSDF则是围绕BxDF指针做一层封装并提供额外功能.\n几何设置与约定 # pbrt中法线计算发生在由表面的切线, 副切线与法线组成的坐标系中, 分别与\\(x,y,z\\)轴对齐. pbrt中光线入射方向与观察方向都会被归一化并方向朝外, 法线也始终朝外. 着色所用的坐标系很可能与相交所用的不同, 这便于实现法线映射等效果.\nBxDF接口 # 单独的BRDF与BTDF方法都定义在BxDF接口中.\nclass BxDF : public TaggedPointer\u0026lt;DiffuseTransmissionBxDF, DiffuseBxDF, CoatedDiffuseBxDF, CoatedConductorBxDF, DielectricBxDF, ThinDielectricBxDF, HairBxDF, MeasuredBxDF, ConductorBxDF, NormalizedFresnelBxDF\u0026gt; { public: // BxDF Interface PBRT_CPU_GPU inline BxDFFlags Flags() const; using TaggedPointer::TaggedPointer; std::string ToString() const; PBRT_CPU_GPU inline SampledSpectrum f(Vector3f wo, Vector3f wi, TransportMode mode) const; PBRT_CPU_GPU inline pstd::optional\u0026lt;BSDFSample\u0026gt; Sample_f( Vector3f wo, Float uc, Point2f u, TransportMode mode = TransportMode::Radiance, BxDFReflTransFlags sampleFlags = BxDFReflTransFlags::All) const; PBRT_CPU_GPU inline Float PDF( Vector3f wo, Vector3f wi, TransportMode mode, BxDFReflTransFlags sampleFlags = BxDFReflTransFlags::All) const; PBRT_CPU_GPU SampledSpectrum rho(Vector3f wo, pstd::span\u0026lt;const Float\u0026gt; uc, pstd::span\u0026lt;const Point2f\u0026gt; u2) const; SampledSpectrum rho(pstd::span\u0026lt;const Point2f\u0026gt; u1, pstd::span\u0026lt;const Float\u0026gt; uc2, pstd::span\u0026lt;const Point2f\u0026gt; u2) const; PBRT_CPU_GPU inline void Regularize(); }; Flags方法用于返回上文所述的材质类型以及区分反射与透射, 部分光线传播算法会通过该返回值决定行为.\nenum BxDFFlags { Unset = 0, Reflection = 1 \u0026lt;\u0026lt; 0, Transmission = 1 \u0026lt;\u0026lt; 1, Diffuse = 1 \u0026lt;\u0026lt; 2, Glossy = 1 \u0026lt;\u0026lt; 3, Specular = 1 \u0026lt;\u0026lt; 4, // Composite _BxDFFlags_ definitions DiffuseReflection = Diffuse | Reflection, DiffuseTransmission = Diffuse | Transmission, GlossyReflection = Glossy | Reflection, GlossyTransmission = Glossy | Transmission, SpecularReflection = Specular | Reflection, SpecularTransmission = Specular | Transmission, All = Diffuse | Glossy | Specular | Reflection | Transmission }; BxDF的关键方法是f, 它根据方向返回BxDF的值, 方向需要位于前文所述的材质的本地空间中. BxDF接口认为不同波长的光是被解耦的, 某个波长上的能量不会被反射到不同的波长上, 因此f的返回值通过SampledSpectrum来表达. 荧光材质会在不同的波长间重新分布能量, 需要返回\\(n \\times n\\)的矩阵来表示\\(n\\)个光谱样本之间的转移. BxDF的构造函数以及各种方法都没有SampledSpectrum中具体某个波长的信息, 这是不需要的. TransportMode用于表示出射方向是对着相机还是对着光源, 不对称散射会用到这一特性.\nPBRT_CPU_GPU inline SampledSpectrum BxDF::f(Vector3f wo, Vector3f wi, TransportMode mode) const { auto f = [\u0026amp;](auto ptr) -\u0026gt; SampledSpectrum { return ptr-\u0026gt;f(wo, wi, mode); }; return Dispatch(f); } BxDF还需要提供用于重要性抽样的方法, Sample_f用于实现这一任务. 由于光线路径是逆向构造的, 因此这里出射方向作为参数, 采样得到的入射方向. 参数中的uc与u用于实现一维与二维的采样, 通常uc用于选择反射或透射, u用于选择方向.\nPBRT_CPU_GPU inline pstd::optional\u0026lt;BSDFSample\u0026gt; BxDF::Sample_f(Vector3f wo, Float uc, Point2f u, TransportMode mode, BxDFReflTransFlags sampleFlags) const { auto sample_f = [\u0026amp;](auto ptr) -\u0026gt; pstd::optional\u0026lt;BSDFSample\u0026gt; { return ptr-\u0026gt;Sample_f(wo, uc, u, mode, sampleFlags); }; return Dispatch(sample_f); } 用户可以通过sampleFlags参数限制采样结果为透射或反射, 像在不透明表面采样透射样本的不合法采样会导致采样失效.\nenum class BxDFReflTransFlags { Unset = 0, Reflection = 1 \u0026lt;\u0026lt; 0, Transmission = 1 \u0026lt;\u0026lt; 1, All = Reflection | Transmission }; 若采样成功, BSDF的值, 入射方向, 分布密度以及对应的flags会被返回, 这里返回的wi位于本地空间中, 在BSDF中会转到渲染空间.\nstruct BSDFSample { // BSDFSample Public Methods BSDFSample() = default; PBRT_CPU_GPU BSDFSample(SampledSpectrum f, Vector3f wi, Float pdf, BxDFFlags flags, Float eta = 1, bool pdfIsProportional = false) : f(f), wi(wi), pdf(pdf), flags(flags), eta(eta), pdfIsProportional(pdfIsProportional) {} PBRT_CPU_GPU bool IsReflection() const { return pbrt::IsReflective(flags); } PBRT_CPU_GPU bool IsTransmission() const { return pbrt::IsTransmissive(flags); } PBRT_CPU_GPU bool IsDiffuse() const { return pbrt::IsDiffuse(flags); } PBRT_CPU_GPU bool IsGlossy() const { return pbrt::IsGlossy(flags); } PBRT_CPU_GPU bool IsSpecular() const { return pbrt::IsSpecular(flags); } std::string ToString() const; SampledSpectrum f; Vector3f wi; Float pdf = 0; BxDFFlags flags; Float eta = 1; bool pdfIsProportional = false; }; 半球反射 # rho方法的两种重载分别用于计算第四章所介绍的半球-方向反射量与半球-半球反射量, 样本数量由调用者决定.\nPBRT_CPU_GPU SampledSpectrum BxDF::rho(Vector3f wo, pstd::span\u0026lt;const Float\u0026gt; uc, pstd::span\u0026lt;const Point2f\u0026gt; u2) const { if (wo.z == 0) return {}; SampledSpectrum r(0.); DCHECK_EQ(uc.size(), u2.size()); for (size_t i = 0; i \u0026lt; uc.size(); ++i) { // Compute estimate of $\\rho_\\roman{hd}$ pstd::optional\u0026lt;BSDFSample\u0026gt; bs = Sample_f(wo, uc[i], u2[i]); if (bs \u0026amp;\u0026amp; bs-\u0026gt;pdf \u0026gt; 0) r += bs-\u0026gt;f * AbsCosTheta(bs-\u0026gt;wi) / bs-\u0026gt;pdf; } return r / uc.size(); } SampledSpectrum BxDF::rho(pstd::span\u0026lt;const Point2f\u0026gt; u1, pstd::span\u0026lt;const Float\u0026gt; uc, pstd::span\u0026lt;const Point2f\u0026gt; u2) const { DCHECK_EQ(uc.size(), u1.size()); DCHECK_EQ(u1.size(), u2.size()); SampledSpectrum r(0.f); for (size_t i = 0; i \u0026lt; uc.size(); ++i) { // Compute estimate of $\\rho_\\roman{hh}$ Vector3f wo = SampleUniformHemisphere(u1[i]); if (wo.z == 0) continue; Float pdfo = UniformHemispherePDF(); pstd::optional\u0026lt;BSDFSample\u0026gt; bs = Sample_f(wo, uc[i], u2[i]); if (bs \u0026amp;\u0026amp; bs-\u0026gt;pdf \u0026gt; 0) r += bs-\u0026gt;f * AbsCosTheta(bs-\u0026gt;wi) * AbsCosTheta(wo) / (pdfo * bs-\u0026gt;pdf); } return r / (Pi * uc.size()); } BSDF中的Delta分布 # Delta分布主要用于完美镜面反射, 但是对于Sample_f与PDF方法, 返回Delta函数对应的无穷大密度在c++中是无法得到正确的渲染结果的. 对于Sample_f方法, 将Delta函数从PDF与BSDF分离, 可以发现Delta函数会被抵消, 由于PDF与Delta函数一致, 因此PDF设置为1即可. 对于PDF方法, 它的返回值为0, 因为恰好位于Delta函数对应的反射方向的概率过小.\n$$ \\begin{equation} \\frac{f_r(p, \\omega_o, \\omega_i)}{p(\\omega_i)} = \\frac{\\delta(\\omega\u0026rsquo; - \\omega_i)f_r^{\\text{rem}}(p, \\omega_o, \\omega_i)}{\\delta(\\omega\u0026rsquo; - \\omega_i)p^{\\text{rem}(\\omega_i)}} = \\frac{f_r^{\\text{rem}}(p, \\omega_o, \\omega_i)}{p^{\\text{rem}(\\omega_i)}} \\end{equation} $$\nBSDF类 # BSDF主要用于处理从材质本地空间到渲染空间的转换. BSDF的构造函数会传入几何法线, 着色法线以及切线, shadingFrame用于存储着色所用的坐标系以及处理与渲染空间之间的转换.\nBSDF() = default; PBRT_CPU_GPU BSDF(Normal3f ns, Vector3f dpdus, BxDF bxdf) : bxdf(bxdf), shadingFrame(Frame::FromXZ(Normalize(dpdus), Vector3f(ns))) {} BSDF的f方法用于封装BxDF中的对应方法, 其中的模板版本用于在用户已知内部BxDF类型的情况下直接调用它的f方法, 这用于在GPU上避免pbrt中的动态方法分发.\nPBRT_CPU_GPU SampledSpectrum f(Vector3f woRender, Vector3f wiRender, TransportMode mode = TransportMode::Radiance) const { Vector3f wi = RenderToLocal(wiRender), wo = RenderToLocal(woRender); if (wo.z == 0) return {}; return bxdf.f(wo, wi, mode); } template \u0026lt;typename BxDF\u0026gt; PBRT_CPU_GPU SampledSpectrum f(Vector3f woRender, Vector3f wiRender, TransportMode mode = TransportMode::Radiance) const { Vector3f wi = RenderToLocal(wiRender), wo = RenderToLocal(woRender); if (wo.z == 0) return {}; const BxDF *specificBxDF = bxdf.CastOrNullptr\u0026lt;BxDF\u0026gt;(); return specificBxDF-\u0026gt;f(wo, wi, mode); } BSDF的Sample_f会通过std::optional处理采样失效的情况.\nPBRT_CPU_GPU pstd::optional\u0026lt;BSDFSample\u0026gt; Sample_f( Vector3f woRender, Float u, Point2f u2, TransportMode mode = TransportMode::Radiance, BxDFReflTransFlags sampleFlags = BxDFReflTransFlags::All) const { Vector3f wo = RenderToLocal(woRender); if (wo.z == 0 || !(bxdf.Flags() \u0026amp; sampleFlags)) return {}; // Sample _bxdf_ and return _BSDFSample_ pstd::optional\u0026lt;BSDFSample\u0026gt; bs = bxdf.Sample_f(wo, u, u2, mode, sampleFlags); if (bs) DCHECK_GE(bs-\u0026gt;pdf, 0); if (!bs || !bs-\u0026gt;f || bs-\u0026gt;pdf == 0 || bs-\u0026gt;wi.z == 0) return {}; PBRT_DBG(\u0026#34;For wo = (%f, %f, %f), ns %f %f %f sampled f = %f %f %f %f, pdf = %f, \u0026#34; \u0026#34;ratio[0] = %f wi = (%f, %f, %f)\\n\u0026#34;, wo.x, wo.y, wo.z, shadingFrame.z.x, shadingFrame.z.y, shadingFrame.z.z, bs-\u0026gt;f[0], bs-\u0026gt;f[1], bs-\u0026gt;f[2], bs-\u0026gt;f[3], bs-\u0026gt;pdf, (bs-\u0026gt;pdf \u0026gt; 0) ? (bs-\u0026gt;f[0] / bs-\u0026gt;pdf) : 0, bs-\u0026gt;wi.x, bs-\u0026gt;wi.y, bs-\u0026gt;wi.z); bs-\u0026gt;wi = LocalToRender(bs-\u0026gt;wi); return bs; } 漫反射 # Lambertian反射模型是最简单的BRDF之一, 它表达了将入射光线均匀的反射到各个方向的完美漫反射. 大部分角度下Lambertian模型都可以很好的表达漫反射, 但是在与法线接近垂直的掠射角下镜面反射会导致明显的偏差.\nLambertian反射的表达式如下, 其中的\\(\\pi\\)来自于积分得到的反射值. 在实时渲染中, 材质的反照率通常会预先乘上\\(\\pi\\), 这避免了耗时的除法操作.\n$$ \\begin{equation} \\int_\\omega f_r(p, \\omega_o, \\omega_i) \\cos\\theta d\\omega = \\int_0^{2\\pi}\\int_0^{\\frac{\\pi}{2}} \\frac{R}{\\pi} \\cos\\theta \\sin\\theta d\\theta d\\phi = R \\end{equation} $$\npbrt在采样Lambertian时会将\\(\\cos\\)项考虑进pdf中, 这使得分布不再均匀, 但能通过重要性抽样获得更好的渲染结果.\n// Sample cosine-weighted hemisphere to compute _wi_ and _pdf_ Vector3f wi = SampleCosineHemisphere(u); if (wo.z \u0026lt; 0) wi.z *= -1; Float pdf = CosineHemispherePDF(AbsCosTheta(wi)); 圆盘采样 # 对极坐标\\(r,\\theta\\)分别做重要性抽样会导致样本集中在圆盘中央, 因为虽然距离圆心距离的分布是均匀的, 由于不同半径下周长不同, 外侧点的分布会减少.\n为了保证样本点在面积上均匀分布, 需要满足\\(p(x,y)=\\frac{1}{\\pi}\\), 使用Jacobi转为极坐标后可得\\(p(r,\\theta)=\\frac{r}{\\pi}\\). 此时可以计算出如下PDF.\n$$ \\begin{equation} \\begin{aligned} p(r)\u0026amp;=\\int_0^{2\\pi}p(r,\\theta)d\\theta=2r\\\\ p(\\theta|r)\u0026amp;=\\frac{p(r,\\theta)}{p(r)}=\\frac{1}{2\\pi} \\end{aligned} \\end{equation} $$\n根据重要性抽样得到的结果如下, 此时根据Jacobian可得\\(drd\\theta=\\frac{\\pi}{\\sqrt{x}}dxdy\\), 均匀采样结果映射为圆盘采样结果时所占的面积并不均匀, 越靠近圆盘边缘所占面积越狭窄.\n$$ \\begin{equation} \\begin{aligned} r\u0026amp;=\\sqrt{\\epsilon_1}\\\\ \\theta\u0026amp;=2\\pi\\epsilon_2 \\end{aligned} \\end{equation} $$\nShirley-Chiu方法可以解决这一问题, 根据Cartesian轴及\\(y=x,y=-x\\)将\\([-1,1]\\)空间分为八个象限, 每个象限根据\\(\\max(x,y\\))选出的轴是一致的, 长轴选取\\(a\\)点, 短轴选取\\(b\\)点, 需保证该\\(\\frac{ab}{2}\\)面积的区域内的采样点在Cartesian及极坐标下所占面积成常数关系. 由于圆弧面积为\\(\\frac{\\theta r^2}{2}\\), 如下表达式可满足上述条件, 在极坐标中占的面积为\\(\\frac{\\pi ab}{8}\\), 看图片会更直观.\n$$ \\begin{equation} \\begin{aligned} r\u0026amp;= \\begin{cases} x \u0026amp; |x|\u0026gt;|y|\\\\ y \u0026amp; |x| \\le |y| \\end{cases}\\\\ \\theta\u0026amp;= \\begin{cases} \\frac{\\pi}{4}\\frac{y}{x} \u0026amp; |x| \u0026gt; |y|\\\\ \\frac{\\pi}{2} - \\frac{x}{y} \u0026amp; |x| \\le |y| \\end{cases} \\end{aligned} \\end{equation} $$\n此时Jacobian行列式满足如下关系, 因此\\(p(r,\\theta)=|J|^{-1}p(u,v)=|J|^{-1}\\frac{1}{4}=\\frac{r}{\\pi}\\).\n$$ \\begin{equation} \\begin{aligned} |J|\u0026amp;= \\begin{cases} \\frac{\\pi}{4x}=\\frac{\\pi}{4r} \u0026amp; |x|\u0026gt;|y|\\\\ \\frac{\\pi}{4y}=\\frac{\\pi}{4r} \u0026amp; |x|\\le|y| \\end{cases} \\end{aligned} \\end{equation} $$\n余弦加权半球采样 # 渲染方程中有余弦项, 将它与BSDF一起做重要性抽样可以有效的考虑余弦的影响, 例如减小与法线夹角较大的光线被采样到的概率. 令\\(p(\\omega)=c\\cos\\theta\\), 此时可以得到如下关系.\n$$ \\begin{equation} \\begin{aligned} \u0026amp;\\int_\\Theta p(\\omega)d\\omega=1\\\\ \u0026amp;\\int_0^{2\\pi}\\int_0^{\\frac{\\pi}{2}}c\\cos\\theta\\sin\\theta d\\theta d\\phi=1\\\\ \u0026amp;c=\\frac{1}{\\pi}\\\\ \u0026amp;p(\\theta,\\phi)=\\frac{1}{\\pi}\\cos\\theta\\sin\\theta \\end{aligned} \\end{equation} $$\nMalley方法通过将均匀圆盘采样的结果投影到半球上实现重要性抽样. 由于此时\\(r=\\sin\\theta\\),将\\(r,\\phi\\)转为\\(\\theta,\\phi\\)的Jacobian如下, 由此可得\\(p(\\theta,\\phi)=p(r,\\phi)\\cos\\theta=\\frac{\\sin\\theta\\cos\\theta}{\\pi}\\), 满足重要性抽样的要求.\n$$ \\begin{equation} \\begin{aligned} |J|=\\begin{vmatrix} \\frac{\\partial r}{\\partial \\theta} \u0026amp; \\frac{\\partial r}{\\partial \\phi}\\\\ \\frac{\\partial \\phi}{\\partial \\theta} \u0026amp; \\frac{\\partial \\phi}{\\partial \\phi} \\end{vmatrix} =\\begin{vmatrix} \\cos\\theta \u0026amp; 0\\\\ 0 \u0026amp; 1 \\end{vmatrix}=\\cos\\theta \\end{aligned} \\end{equation} $$\n镜面反射与透射 # 镜面反射只会将光线反射到某个方向集合中, 本节主要关注完美镜面反射, 微表面理论对反射结果的影响会在后面讨论.\n物理原理 # pbrt主要关注几何光学, 在波长远小于物体尺寸时这是可行的, 但对光的本质的探究也是必要的. 根据电磁学的定义光是电磁场的振荡, pbrt只关注其中电场的部分即电子的运动, 当光与表面接触时会刺激表面上的电子使其剧烈振荡, 移动的电子会导致电场中振荡的叠加.\n依据电磁学理论, 物质可以分为绝缘体, 导体与半导体. 绝缘体中电子不会脱离原子; 导体中电子可以自由移动, 但移动过程中会有能量衰减, 通常完全吸收会发生在距离表面小于0.1微米处; 半导体兼顾二者的特性, 例如硅在可见光内具有金属特性, 在红外光中则具有透明特性.\n折射率 # 由光所激发的电子产生的振荡通常会比原本的振荡的速度要小, 速度减小的程度被称为折射率(index of refraction, IOR), 它通过真空光速与当前材质中的光速的比值来定义, 通常在1.0~2.5之间, 同时光的波长也会影响IOR. IOR的突变会导致反射率的增加, IOR的变化是我们能观察到物体的原因.\n镜面反射法则 # 令入射光线方向为\\(\\omega_i\\)(如上文所述, 方向是朝外的, 并非光线的传播方向), 完美反射的方向如下.\n$$ \\begin{equation} \\omega_r = -\\omega_i + 2(\\bold{n} \\cdot \\omega_i)\\bold{n} \\end{equation} $$\nSnell定律 # Snell定律描述了入射光线与折射光线在方向上的关系, 这可以通过Fermat原理推导得到, 即光的传播路径是耗时最小的路径, 通过求极值即可证明. 从Snell定律可以看出折射方向取决于IOR的比值即相对IOR, 后文中通过\\(\\eta\\)表示该值.\n$$ \\begin{equation} \\begin{aligned} \\eta_i \\sin\\theta_i \u0026amp;= \\eta_t \\sin\\theta_t\\\\ \\phi_t \u0026amp;= \\phi_i + \\pi \\end{aligned} \\end{equation} $$\n经过不同介质后, 由于光的不同波长的部分具有不同的IOR, 这导致传播方向不同, 这被称为散射, 通常会表现为经过介质后产生彩虹状的光锥.\n利用Snell定律可以按如下方式表示折射光线. 当光线从物体内部发出时, 由于法线朝外, \\(\\omega_i \\cdot \\bold{n}\\)小于0, 需要对代码做适当调整.\n$$ \\begin{equation} \\omega_t = -\\frac{\\omega_i}{\\eta} + \\left[ \\frac{\\omega_i \\cdot \\bold{n}}{\\eta} - \\cos\\theta_t \\right] \\bold{n} \\end{equation} $$\n当光线穿过光学密度更小(折射后的介质的IOR较小)时, 当入射天顶角超过\\(\\theta_c = \\sin^{-1}(\\eta^{-1})\\)时折射天顶角会超过\\(90^{\\circ}\\), 此时光线会完全反射.\nFresnel方程 # Fresnel方程描述了光线折射与反射的量, 它是Maxwell方程在光滑平面上的解.\n将光线分解为相对于表面的垂直与水平偏振, 它们因反射而产生的振幅的变化是不同的. 若\\(\\theta_t\u0026gt;\\frac{\\pi}{2}\\)可以认为是完全反射, Fresnel返回\\(1\\).\n$$ \\begin{equation} \\begin{aligned} r_{||} \u0026amp;= \\frac{E_r^{||}}{E_i^{||}} \u0026amp;= \\frac{\\eta_t \\cos\\theta_i - \\eta_i \\cos\\theta_t}{\\eta_t \\cos\\theta_i + \\eta_i \\cos\\theta_t} \u0026amp;= \\frac{\\eta \\cos\\theta_i - \\cos\\theta_t}{\\eta \\cos\\theta_i + \\cos\\theta_t}\\\\ r_{\\perp} \u0026amp;= \\frac{E_r^{\\perp}}{E_i^{\\perp}} \u0026amp;= \\frac{\\eta_i \\cos\\theta_i - \\eta_t \\cos\\theta_t}{\\eta_i \\cos\\theta_i + \\eta_t \\cos\\theta_t} \u0026amp;= \\frac{\\cos\\theta_i - \\eta \\cos\\theta_t}{\\cos\\theta_i + \\eta \\cos\\theta_t} \\end{aligned} \\end{equation} $$\n电磁学关注的是反射波的振幅与相位, 而pbrt的几何光学中更关注光线所携带的功率, 这可以通过振幅的平方来表示. 若入射光是无偏振的即含有等量的水平与垂直偏振, 此时反射功率为水平与垂直反射功率的平均值, 即位Fresnel反射率.\n$$ \\begin{equation} F_r = \\frac{1}{2}(r_{||}^2 + r_{\\perp}^2) \\end{equation} $$\n实时渲染中通常使用Schlick近似.\n$$ \\begin{equation} \\begin{aligned} F_r \u0026amp;= F_{r_0}+(1-F_{r_0})(1-\\cos\\theta_i)^5\\\\ F_{r_0} \u0026amp;= \\left(\\frac{\\eta_i - \\eta_t}{\\eta_i + \\eta_t}\\right)^2 \\end{aligned} \\end{equation} $$\n导体Fresnel方程 # 导体的IOR需要用复数表示, 实部描述光线速度的减小, 虚部描述光线在材质内传播时的衰减.\n虚部为\\(0\\)时电磁波振幅如下, 只关心Euler公式分解后的实部, 此时为与距离\\(z\\)相关的三角函数, \\(\\alpha\\)代表空间频率.\n$$ \\begin{equation} \\begin{aligned} E(z)\u0026amp;=e^{i\\alpha\\eta z}\\\\ \\mathcal{R}(E(z))\u0026amp;=\\cos(\\alpha\\eta z) \\end{aligned} \\end{equation} $$\n当使用复数\\(\\eta_c=\\eta+ik\\)表示IOR后, 电磁波振幅会随着传播距离衰减, 形式如下.\n$$ \\begin{equation} \\begin{aligned} \\mathcal{R}(E(z))=e^{-\\alpha zk}\\cos(\\alpha\\eta z) \\end{aligned} \\end{equation} $$\n复数的2范数为实部与虚部和的平方, 此时可泛化上述Fresnel反射率的计算.\n$$ \\begin{equation} \\begin{aligned} ||a+bi||_2=\\sqrt{a^2+b^2} \\end{aligned} \\end{equation} $$\n导体BRDF # 本节描述的是从光从绝缘体介质中接触导体表面时的BRDF, 只考虑光滑的情况. 光滑导体只将光线返回到一个反向, 反射光线的辐亮度由Fresnel反射率决定, 因此BRDF如下.\n$$ \\begin{equation} f_r(p, \\omega_o, \\omega_i) = F_r(\\omega_r) \\frac{\\delta(\\omega_i - \\omega_r)}{|\\cos\\theta_r|} \\end{equation} $$\n绝缘体BSDF # pbrt在选择采样反射或透射时, 根据Fresnel反射率以及用户设置的Flags来决定. 由于只考虑光滑表面, BRDF和BTDF与上一节的导体BRDF都是相同的.\n薄绝缘体BSDF # pbrt通过ThinDielectricBxDF模拟光线穿过薄绝缘体平行的内外表面的现象, 由Fresnel反射率的定义可知, 若交换表面两侧的介质结果是不变的, 因此在薄导体内部多次反射后的总反射率如下.\n$$ \\begin{equation} R\u0026rsquo; = R + TRT + TRRRT + \\cdots = R + \\frac{T^2R}{1-R^2} \\end{equation} $$\n非对称散射与折射 # BRDF都是对称的, 即入射与反射方向可以交换, 但BTDF不是, 因为IOR的变化会导致折射后光线范围的变化, 为保持能量守恒光线的辐亮度不再保持一致. 根据能量守恒我们可以认为\\(d^2\\phi_o = d^2\\phi_i\\), 结合辐亮度的定义与Snell定律可以推导出如下的关系. 由于路径追踪实际上为光线传播的逆过程, 在折射时需要考虑非对称折射的现象.\n$$ \\begin{equation} \\eta_o^2 f_t(p, \\omega_o, \\omega_i) = \\eta_i^2 f_t(p, \\omega_i, \\omega_o) \\end{equation} $$\n微表面理论 # 大部分物体表面在微观上是粗糙的, 这可以通过微表面理论模拟, 这避免了对建模精度的要求, 且更适用于Monte Carlo.\n法线分布函数 # 微表面分布主要定义了法线的分布, 由于光源与观察者都与表面相距较远, 这种概率表示是可行的. 宏表面与微表面所占的面积关系如下, 即微表面沿宏观法线投影的面积与宏表面面积相等.\n$$ \\begin{equation} \\int_{dA_\\mu}(\\omega_m(p) \\cdot \\bold{n}) dp = \\int_{dA} dp \\end{equation} $$\n将所有具有某个方向的法线的微表面在宏表面上的相对投影面积定义为法线分布函数, 此时可以得到法线分布函数的归一化性质.\n$$ \\begin{equation} \\int_\\Omega D(\\omega_m)(\\omega_m \\cdot \\bold{n}) d\\omega_m = \\int_\\Omega D(\\omega_m) \\cos\\theta_m d\\omega_m = 1 \\end{equation} $$\n若转为斜率分布, 可以得到如下关系.\n$$ \\begin{equation} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} P^{22}(x_{\\tilde{m}},y_{\\tilde{m}}) dx_{\\tilde{m}} dy_{\\tilde{m}}=1 \\end{equation} $$\n根据平面的定义\\(x_mx+y_my+z_mz+c=0\\), 法线与斜率具有如下的关系.\n$$ \\begin{equation} \\begin{aligned} (x_{\\tilde{m}},y_{\\tilde{m}})\u0026amp;=(-\\frac{x_m}{z_m},-\\frac{y_m}{z_m})=-\\tan\\theta_m(\\cos\\phi_m,\\sin\\phi_m)\\\\ (x_m, y_m, z_m)\u0026amp;=\\frac{(-x_{\\tilde{m}},-y_{\\tilde{m}},1)}{\\sqrt{x_{\\tilde{m}}^2+y_{\\tilde{m}}^2+1}}=(-x_{\\tilde{m}},-y_{\\tilde{m}},1)\\cos\\theta_m \\end{aligned} \\end{equation} $$\nJacobi行列式的计算结果如下.\n$$ \\begin{equation} dx_{\\tilde{m}}dy_{\\tilde{m}}=\\frac{\\sin\\theta}{\\cos^3\\theta}d\\theta d\\phi \\end{equation} $$\n此时可以得到法线分布函数与斜率分布函数的转换关系.\n$$ \\begin{equation} D(\\omega_m) = \\frac{P^{22}(x_{\\tilde{m}},y_{\\tilde{m}}) dx_{\\tilde{m}} dy_{\\tilde{m}}}{\\cos\\theta \\sin\\theta d\\theta d\\phi} = \\frac{P^{22}(x_{\\tilde{m}},y_{\\tilde{m}})}{\\cos^4\\theta} \\end{equation} $$\n若法线分布函数为形状无关的, 即修改粗糙度等价于对法线分布函数进行拉伸, 则其斜率分布需要满足如下形式.\n$$ \\begin{equation} \\begin{aligned} P^{22}(x_{\\tilde{m}},y_{\\tilde{m}}) \u0026amp;=\\frac{1}{\\alpha_x\\alpha_y}f(\\sqrt{\\frac{x_{\\tilde{m}^2}}{\\alpha_x^2} + \\frac{y_{\\tilde{m}^2}}{\\alpha_y^2}})\\\\ \u0026amp;=\\frac{1}{\\alpha_x\\alpha_y}f(\\tan\\theta_m\\sqrt{\\frac{\\cos^2\\phi_m}{\\alpha_x^2} + \\frac{\\sin^2\\phi_m}{\\alpha_y^2}}) \\end{aligned} \\end{equation} $$\n对于渲染任务最常用的Trowbridge-Reitz法线分布函数定义如下.\n$$ \\begin{equation} \\begin{aligned} P^{22}(x_{\\tilde{m}},y_{\\tilde{m}}) \u0026amp;= \\frac{1}{\\pi\\alpha_x\\alpha_y(1+\\frac{x_{\\tilde{m}^2}}{\\alpha_x^2} + \\frac{y_{\\tilde{m}^2}}{\\alpha_y^2})^2}\\\\ D(\\omega_m) \u0026amp;= \\frac{1}{\\pi\\alpha_x\\alpha_y\\cos^4\\theta_m(1+\\tan^2\\theta_m(\\frac{\\cos^2\\phi_m}{\\alpha_x^2} + \\frac{\\sin^2\\phi_m}{\\alpha_y^2}))^2} \\end{aligned} \\end{equation} $$\n遮蔽函数 # 微表面可能会被遮挡, 需要通过遮蔽函数来表示某个方向上被遮蔽的比率.\n$$ \\begin{equation} \\int_\\Omega D(\\omega_m)G_1(\\omega,\\omega_m)(\\omega\\cdot\\omega_m)d\\omega_m=\\omega\\cdot\\bold{n}=\\cos\\theta \\end{equation} $$\nSmith遮蔽函数认为法线与高度是独立的, 即微表面类似于一个一个浮动的小片段, 此时可以将遮蔽函数分解为局部遮蔽与全部遮蔽, 局部遮蔽只需要法线可见, 即\\(\\omega\\cdot\\omega_m\u0026gt;0\\), 此时遮蔽函数不再依赖于微表面法线. 不失一般性, 令表面为各向同性的, 法线为局部空间中的\\((0,0,1)\\), 视线沿\\(x\\)轴为\\((\\sin\\theta, 0, \\cos\\theta)\\), 已知由于对称性\\(\\int_{-\\infty}^{\\infty}x_{\\tilde{m}}P^{2-}(x_{\\tilde{m}})dx_{\\tilde{m}}=0\\),\\(\\int_{-\\infty}^{\\infty}P^{2-}(x_{\\tilde{m}})dx_{\\tilde{m}}=1\\),此时可以得到如下结果.\n$$ \\begin{equation} \\begin{aligned} G_1(\\omega) \u0026amp;=\\frac{\\cos\\theta}{\\int_\\Omega D(\\omega_m)\\max(0,\\omega\\cdot\\omega_m)d\\omega_m}\\\\ \u0026amp;=\\frac{\\cos\\theta}{\\int_\\Omega D(\\omega_m)\\cos\\theta_m\\frac{\\max(0,\\omega\\cdot\\omega_m)}{\\cos\\theta_m}d\\omega_m}\\\\ \u0026amp;=\\frac{\\cos\\theta}{\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}P^{22}(x_{\\tilde{m}},y_{\\tilde{m}}) \\frac{\\max(0, (-x_{\\tilde{m}}\\sin\\theta + \\cos\\theta)\\cos\\theta_m)}{\\cos\\theta_m} dx_{\\tilde{m}} dy_{\\tilde{m}}}\\\\ \u0026amp;=\\frac{\\cos\\theta}{\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\cot\\theta}P^{22}(x_{\\tilde{m}},y_{\\tilde{m}}) (-x_{\\tilde{m}}\\sin\\theta + \\cos\\theta) dx_{\\tilde{m}} dy_{\\tilde{m}}}\\\\ \u0026amp;=\\frac{\\cot\\theta}{\\int_{-\\infty}^{\\cot\\theta}P^{2-}(x_{\\tilde{m}}) (-x_{\\tilde{m}} + \\cot\\theta) dx_{\\tilde{m}}}\\\\ \u0026amp;=\\frac{\\cot\\theta}{\\int_{-\\infty}^{\\infty}P^{2-}(x_{\\tilde{m}}) x_{\\tilde{m}} dx_{\\tilde{m}}-\\cot\\theta\\int_{-\\infty}^{\\infty}P^{2-}(x_{\\tilde{m}}) dx_{\\tilde{m}}+\\cot\\theta+\\int_{-\\infty}^{\\cot\\theta}P^{2-}(x_{\\tilde{m}}) (-x_{\\tilde{m}} + \\cot\\theta) dx_{\\tilde{m}}}\\\\ \u0026amp;=\\frac{1}{1+\\frac{1}{\\cot\\theta}\\int_{\\cot\\theta}^{\\infty}P^{2-}(x_{\\tilde{m}}) (x_{\\tilde{m}} - \\cot\\theta) dx_{\\tilde{m}}}\\\\ \u0026amp;=\\frac{1}{1+\\Lambda(\\omega)} \\end{aligned} \\end{equation} $$\n各向同性的Trowbridge-Reitz的\\(\\Lambda(\\omega)\\)具有解析形式, 各向异性的粗糙度可以通过\\(\\alpha=\\sqrt{\\alpha_x^2\\cos^2\\phi+\\alpha_y^2\\sin^2\\phi}\\)得到.\n$$ \\begin{equation} \\begin{aligned} \\Lambda(\\omega) \u0026amp;=\\frac{1}{\\cot\\theta}\\int_{-\\infty}^{\\infty}\\int_{\\cot\\theta}^{\\infty}\\frac{1}{\\pi\\alpha^2(1+\\frac{x_{\\tilde{m}^2}}{\\alpha^2} + \\frac{y_{\\tilde{m}^2}}{\\alpha^2})^2} (x_{\\tilde{m}} - \\cot\\theta)dx_{\\tilde{m}}dy_{\\tilde{m}}\\\\ \u0026amp;=\\frac{1}{\\cot\\theta}\\int_{-\\infty}^{\\infty}\\int_{\\frac{\\cot\\theta}{\\alpha}}^{\\infty}\\frac{\\alpha}{\\pi(1+(\\frac{x_{\\tilde{m}}}{\\alpha})^2 + (\\frac{y_{\\tilde{m}}}{\\alpha})^2)^2} (\\frac{x_{\\tilde{m}}}{\\alpha} - \\frac{\\cot\\theta}{\\alpha})d\\frac{x_{\\tilde{m}}}{\\alpha}d\\frac{y_{\\tilde{m}}}{\\alpha}\\\\ \u0026amp;=\\frac{1}{\\pi x_0}\\int_{-\\infty}^{\\infty}\\int_{x_0}^{\\infty}\\frac{1}{(1+x^2+y^2)^2}(x-x_0)dxdy\\\\ \u0026amp;=\\frac{1}{\\pi x_0}\\int_{x_0}^{\\infty}(x-x_0)(1+x^2)^{-\\frac{3}{2}}dx\\int_{-\\infty}^{\\infty}\\frac{1}{(1+(\\frac{y}{\\sqrt{1+x^2}})^2)^2}d\\frac{y}{\\sqrt{1+x^2}}\\\\ \u0026amp;=\\frac{1}{\\pi x_0}\\int_{x_0}^{\\infty}(x-x_0)(1+x^2)^{-\\frac{3}{2}}dx\\int_{-\\infty}^{\\infty}\\frac{1}{(1+y^2)^2}dy\\\\ \u0026amp;=\\frac{1}{\\pi x_0}\\int_{x_0}^{\\infty}(x-x_0)(1+x^2)^{-\\frac{3}{2}}dx\\int_{-\\infty}^{\\infty}\\frac{1}{(1+\\tan^2\\theta)^2}d\\tan\\theta\\\\ \u0026amp;=\\frac{1}{\\pi x_0}\\int_{x_0}^{\\infty}(x-x_0)(1+x^2)^{-\\frac{3}{2}}dx\\int_{-\\frac{\\pi}{2}}^{\\frac{\\pi}{2}}\\frac{\\cos2\\theta+1}{2}d\\theta\\\\ \u0026amp;=\\frac{1}{2x_0}\\int_{x_0}^{\\infty}(x-x_0)(1+x^2)^{-\\frac{3}{2}}dx\\\\ \u0026amp;=\\frac{1}{2 x_0}\\int_{x_0}^{\\infty}(x-x_0)(-\\frac{1}{x})d(1+x^2)^{-\\frac{1}{2}}\\\\ \u0026amp;=\\frac{1}{2 x_0}\\int_{(1+x_0^2)^{-\\frac{1}{2}}}^{0}\\frac{x_0}{\\sqrt{\\frac{1}{x^2}-1}}-1dx\\\\ \u0026amp;=\\frac{1}{2}\\int_{0}^{(1+x_0^2)^{-\\frac{1}{2}}}\\frac{1}{x_0}-\\frac{x}{\\sqrt{1-x^2}}dx\\\\ \u0026amp;=\\frac{1}{2}(\\frac{(1+x_0^2)^{-\\frac{1}{2}}}{x_0}+\\int_{0}^{(1+x_0^2)^{-\\frac{1}{2}}}d\\sqrt{1-x^2})\\\\ \u0026amp;=\\frac{1}{2}(\\frac{(1+x_0)^{-\\frac{1}{2}}}{x_0}+x_0(1+x_0)^{-\\frac{1}{2}}-1)\\\\ \u0026amp;=\\frac{\\sqrt{1+\\frac{1}{x_0^2}}-1}{2}\\\\ \u0026amp;=\\frac{\\sqrt{1+\\alpha^2 \\tan^2\\theta}-1}{2} \\end{aligned} \\end{equation} $$\n遮蔽阴影函数 # 除遮挡视线外, 光源也可能被微表面遮挡. 若采用\\(G(\\omega_o, \\omega_i)=G_1(\\omega_o)G_1(\\omega_i)\\)来估计是不准确的, 例如\\(\\omega_o=\\omega_i\\)的情况下是不应该被遮挡的. 通过高度相关性可以推导出更优的遮蔽阴影函数.\n不失一般性, 令视线沿x轴, \\(S(x)\\)为视线方向从\\(x=0\\)上某个点出发行进\\(x\\)后未被遮挡的概率, \\(g(x)dx\\)为光线在\\([x,x+dx]\\)内被遮挡的概率, 此时\\(S(x + dx)\\)可以按如下方式表示.\n$$ \\begin{equation} S(x+dx)=S(x)(1-g(x)dx) \\end{equation} $$\n将该式视为一阶Taylor展开, 此时可以得到微分方程, \\(S(x)\\)可以求解.\n$$ \\begin{equation} \\begin{aligned} \\frac{dS(x)}{dx}\u0026amp;=-S(x)g(x)\\\\ S(x)\u0026amp;=S(0)e^{-\\int_0^x g(x)dx} \\end{aligned} \\end{equation} $$\n令视线在\\(x\\)轴上的斜率为\\(\\mu_v\\), 表面在x轴的斜率为\\(\\mu(x)\\), 则\\(S(0)\\)定义如下, 用\\(s(\\mu_v-\\mu(0))\\)表示.\n$$ \\begin{equation} \\begin{aligned} S(0)=s(\\mu_v-\\mu(0))= \\begin{cases} 1 \u0026amp;\\mu_v\\ge\\mu(0)\\\\ 0 \u0026amp;\\mu_v\u0026lt;\\mu(0) \\end{cases} \\end{aligned} \\end{equation} $$\n令表面高度为\\(h(x)\\), 条件\\(\\alpha\\)为\\(h(x)\u0026lt;h(0)+\\mu_v x\\), 条件\\(\\beta\\)为\\(h(x+dx)\u0026gt;h(0)+\\mu_v\\cdot(x+dx)\\), \\(P_3(h,\\mu|x)\\)为\\(x\\)处斜率与高度的联合分布, 若在\\([x,x+dx]\\)处被遮挡需要满足\\(\\mu(x)\u0026gt;\\mu_v\\), 同时在Smith遮蔽函数下高度与斜率是不相关的, 此时可以定义\\(g(x)\\). \\(P(\\alpha,\\beta)\\)中对微分高度变化的积分使用微分面积计算.\n$$ \\begin{equation} \\begin{aligned} g(x) \u0026amp;=\\frac{1}{dx}P(\\beta|\\alpha)\\\\ \u0026amp;=\\frac{1}{dx}\\frac{P(\\alpha,\\beta)}{P(\\alpha)}\\\\ \u0026amp;=\\frac{1}{dx}\\frac{\\int_{\\mu_v}^\\infty\\int_{h(0)+\\mu_v(x+dx)-\\mu dx}^{h(0)+\\mu_vx}P_3(h,\\mu|x)dh d\\mu}{\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{h(0)+\\mu_vx}P_3(h,\\mu|x)dhd\\mu}\\\\ \u0026amp;=\\frac{1}{dx}\\frac{\\int_{\\mu_v}^\\infty(\\mu-\\mu_v)dxP_3(h(0)+\\mu_vx,\\mu|x)d\\mu}{\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{h(0)+\\mu_vx}P_3(h,\\mu|x)dhd\\mu}\\\\ \u0026amp;=\\frac{\\int_{\\mu_v}^\\infty(\\mu-\\mu_v)P_h(h(0)+\\mu_vx)P^{2-}(\\mu)d\\mu}{\\int_{-\\infty}^{h(0)+\\mu_vx}P_h(h)dh}\\\\ \u0026amp;=\\Lambda(\\mu_v)\\frac{\\mu_vP_h(h(0)+\\mu_vx)}{f(h(0)+\\mu_vx)} \\end{aligned} \\end{equation} $$\n在Smith遮蔽函数下\\(s(\\mu_v-\\mu(0))\\)恒成立, 省去该项后可以得到不会被遮蔽的概率\\(S(h)\\).\n$$ \\begin{equation} \\begin{aligned} S(h, \\omega) \u0026amp;= e^{-\\Lambda(\\omega)\\int_0^{\\infty}\\frac{\\mu_vP_h(h+\\mu_vx)}{f(h+\\mu_vx)}dx}\\\\ \u0026amp;= e^{-\\Lambda(\\omega)\\left[\\ln f(h+\\mu_v x)\\right]_0^{\\infty}}\\\\ \u0026amp;= e^{-\\Lambda(\\omega)(\\ln 1 - \\ln f(h))}\\\\ \u0026amp;= e^{\\Lambda(\\omega)\\ln f(h)}\\\\ \u0026amp;= f(h)^{\\Lambda(\\omega)} \\end{aligned} \\end{equation} $$\n此时可以得到Smith遮蔽函数的全局项, 可以看到与上一节的证明结果是相同的.\n$$ \\begin{equation} \\begin{aligned} G_1(\\omega) \u0026amp;= \\int_{-\\infty}^{\\infty} f(h)^{\\Lambda(\\omega)} P_h(h) dh\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} f(h)^{\\Lambda(\\omega)} df(h)\\\\ \u0026amp;= \\left[\\frac{f(h)^{1+\\Lambda(\\omega)}}{1+\\Lambda(\\omega)}\\right]_{-\\infty}^{\\infty}\\\\ \u0026amp;= \\frac{1}{1+\\Lambda(\\omega)} \\end{aligned} \\end{equation} $$\n此时可以推导出遮蔽阴影函数.\n$$ \\begin{equation} \\begin{aligned} G(\\omega_o,\\omega_i) \u0026amp;= \\int_{-\\infty}^{\\infty}f(h)^{\\Lambda(\\omega_o)}P_h(h)dh + \\int_{-\\infty}^{\\infty}f(h)^{\\Lambda(\\omega_i)}P_h(h)dh\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty}f(h)^{\\Lambda(\\omega_o)+\\Lambda(\\omega_i)}P_h(h)dh\\\\ \u0026amp;= \\frac{1}{1+\\Lambda(\\omega_o)+\\Lambda(\\omega_i)} \\end{aligned} \\end{equation} $$\n采样可见法线分布 # 根据法线分布函数与遮蔽阴影函数我们可以得到视线为\\(\\omega\\)时法线的分布.\n$$ \\begin{equation} D_\\omega(\\omega_m)=\\frac{G_1(\\omega)}{\\cos\\theta}D(\\omega_m)\\max(0,\\omega\\cdot\\omega_m) \\end{equation} $$\n由于逆变换法没有解析形式, pbrt将Trowbridge-Reitz分布看作一个被缩放的半球, 投影到半球上为椭圆. 因此将法线变换到\\(z\\)轴, 对视线方向乘上由各向异性粗糙度定义的椭圆轴长, 执行逆椭圆变换, 在半球中采样更为简单.\n// Transform _w_ to hemispherical configuration Vector3f wh = Normalize(Vector3f(alpha_x * w.x, alpha_y * w.y, w.z)); if (wh.z \u0026lt; 0) wh = -wh; 构造以视线为\\(z\\)轴的正交坐标系, T2轴保证采样到缩放半圆的法线在该轴为负.\n// Find orthonormal basis for visible normal sampling Vector3f T1 = (wh.z \u0026lt; 0.99999f) ? Normalize(Cross(Vector3f(0, 0, 1), wh)) : Vector3f(1, 0, 0); Vector3f T2 = Cross(wh, T1); 将半球投影到\\(xy\\)平面时, 只有一侧是完整半圆, 另一侧是缩放了\\(\\cos\\theta=\\bold{n}\\cdot\\omega\\)即wh.z的半圆. 令\\(h=\\sqrt{1-x^2}\\), 原本采样得到的\\(x\\)对应的\\(y\\)范围为\\((-h, h)\\), 缩放后为\\((-h\\cos\\theta, h)\\), 相当于\\(y\u0026rsquo;=\\frac{1+\\cos\\theta}{2}y+\\frac{h(1-\\cos\\theta)}{2}\\), pbrt这里的Lerp与之等价.\n// Generate uniformly distributed points on the unit disk Point2f p = SampleUniformDiskPolar(u); // Warp hemispherical projection for visible normal sampling Float h = std::sqrt(1 - Sqr(p.x)); p.y = Lerp((1 + wh.z) / 2, h, p.y); 最后将采样得到的法线变换回原本的空间, 由于法线的变换为逆变换的转置, 这里仍然乘上粗糙度.\n// Reproject to hemisphere and transform normal to ellipsoid configuration Float pz = std::sqrt(std::max\u0026lt;Float\u0026gt;(0, 1 - LengthSquared(Vector2f(p)))); Vector3f nh = p.x * T1 + p.y * T2 + pz * wh; CHECK_RARE(1e-5f, nh.z == 0); return Normalize( Vector3f(alpha_x * nh.x, alpha_y * nh.y, std::max\u0026lt;Float\u0026gt;(1e-6f, nh.z))); 实时渲染IBL的重要性抽样中, 法线与视线方向是一致的, 因此可以对下式进行球面坐标上的重要性抽样.\n$$ \\begin{equation} \\int_{-\\pi}^{\\pi}\\int_0^{\\frac{\\pi}{2}}D(\\theta,\\phi)\\cos\\theta\\sin\\theta d\\theta d\\phi = 1 \\end{equation} $$\n各向同性的Trowbridge-Reitz在\\(\\theta,\\phi\\)上的PDF如下.\n$$ \\begin{equation} \\begin{aligned} p(\\theta) \u0026amp;=\\int_{0}^{2\\pi}D(\\theta,\\phi)\\cos\\theta\\sin\\theta d\\phi\\\\ \u0026amp;=\\int_{0}^{2\\pi}\\frac{1}{\\pi\\alpha^2\\cos^4\\theta(1+\\frac{\\tan^2\\theta}{\\alpha^2})^2}\\cos\\theta\\sin\\theta d\\phi\\\\ \u0026amp;=\\frac{2\\alpha^2\\cos\\theta\\sin\\theta}{\\cos^4\\theta(\\alpha^2+\\tan^2\\theta)^2}\\\\ \u0026amp;=\\frac{2\\alpha^2\\cos\\theta\\sin\\theta}{(\\alpha^2\\cos^2\\theta+\\sin^2\\theta)^2}\\\\ \u0026amp;=\\frac{2\\alpha^2\\cos\\theta\\sin\\theta}{((\\alpha^2-1)\\cos^2\\theta+1)^2}\\\\ p(\\phi)\u0026amp;=\\frac{p(\\theta,\\phi)}{p(\\theta)}=\\frac{1}{2\\pi} \\end{aligned} \\end{equation} $$\n由于逆变换法的需要, 计算二者的CDF.\n$$ \\begin{equation} \\begin{aligned} P(\\theta) \u0026amp;=\\int_0^{\\theta}p(\\theta_0)d\\theta_0\\\\ \u0026amp;=\\int_0^{\\theta}\\frac{-2\\alpha^2\\cos\\theta_0}{((\\alpha^2-1)\\cos^2\\theta_0+1)^2}d\\cos\\theta_0\\\\ \u0026amp;=\\int_1^{\\cos\\theta}\\frac{-2\\alpha^2x}{((\\alpha^2-1)x^2+1)^2}dx\\\\ \u0026amp;=\\int_1^{\\cos\\theta}\\frac{\\alpha^2}{(\\alpha^2-1)}d\\frac{1}{(\\alpha^2-1)x^2+1}\\\\ \u0026amp;=\\frac{\\alpha^2}{(\\alpha^2-1)}(\\frac{1}{(\\alpha^2-1)\\cos^2\\theta+1}-\\frac{1}{\\alpha^2})\\\\ \u0026amp;=\\frac{1-\\cos^2\\theta}{((\\alpha^2-1)\\cos^2\\theta+1)}\\\\ P(\\phi) \u0026amp;=\\int_0^{\\phi}p(\\phi_0)d\\phi_0=\\frac{\\phi}{2\\pi} \\end{aligned} \\end{equation} $$\n通过逆变换法得到最终变换.\n$$ \\begin{equation} \\begin{aligned} \\theta \u0026amp;=P^{-1}(u_0) =\\cos^{-1}\\sqrt{\\frac{1-u_0}{(\\alpha^2-1)u_0+1}}\\\\ \\phi \u0026amp;=P^{-1}(u_1) =2\\pi u_1 \\end{aligned} \\end{equation} $$\nTorrance-Sparrow模型 # 综合以上结论我们可以推导出微表面上的Torrance-Sparrow BRDF并应用于材质中.\n半向量变换 # 对于镜面反射表面法线\\(\\omega_m\\)是位于\\(\\omega_o\\)和\\(\\omega_o\\)之间的, 因此也可以被称为半向量. 以\\(\\omega_o\\)为中心即\\(\\theta_o=0\\), 此时可以获取Jacobi行列式的变换结果.\n$$ \\begin{equation} \\begin{aligned} \\frac{d\\omega_m}{d\\omega_i} \u0026amp;= \\frac{\\sin\\theta_m d\\theta_m d\\phi_m}{\\sin\\theta_i d\\theta_i d\\phi_i}\\\\ \u0026amp;= \\frac{\\sin\\theta_m d\\theta_m d\\phi_m}{\\sin2\\theta_m 2d\\theta_m d\\phi_m}\\\\ \u0026amp;= \\frac{\\sin\\theta_m}{4\\cos\\theta_m\\sin\\theta_m}\\\\ \u0026amp;= \\frac{1}{4(\\omega_i\\cdot\\omega_m)}\\\\ \u0026amp;= \\frac{1}{4(\\omega_o\\cdot\\omega_m)} \\end{aligned} \\end{equation} $$\nTorrance-Sparrow PDF # \\(\\omega_i\\)的分布如下.\n$$ \\begin{equation} p(\\omega_i)=D_{\\omega_o}(\\omega_m)\\frac{d\\omega_m}{d\\omega_i}=\\frac{D_{\\omega_o}(\\omega_m)}{4(\\omega_o\\cdot\\omega_m)} \\end{equation} $$\nTorrance-Sparrow BRDF # 在Monte Carlo下反射方程可以做如下近似.\n$$ \\begin{equation} \\begin{aligned} L_o(p,\\omega_o) \u0026amp;=\\int_\\Omega f_r(p,\\omega_o,\\omega_i)L_i(p,\\omega_i)\\cos\\theta_id\\omega_i\\\\ \u0026amp;\\approx \\frac{f_r(p,\\omega_o,\\omega_i)L_i(p,\\omega_i)\\cos\\theta_i}{p(\\omega_i)}\\\\ \u0026amp;=F(\\omega_o\\cdot\\omega_m)G(\\omega_i,\\omega_o)L_i(p,\\omega_i) \\end{aligned} \\end{equation} $$\n由此可得Torrance-Sparrow BRDF.\n$$ \\begin{equation} \\begin{aligned} f_r(p,\\omega_o,\\omega_i) \u0026amp;=\\frac{D_{\\omega_o}(\\omega_m)F(\\omega_o,\\omega_m)G(\\omega_i)}{4(\\omega_o\\cdot\\omega_m)\\cos\\theta_i}\\\\ \u0026amp;=\\frac{D(\\omega_m)F(\\omega_o,\\omega_m)G(\\omega_i)G(\\omega_o)}{4\\cos\\theta_i\\cos\\theta_o}\\\\ \u0026amp;\\approx\\frac{D(\\omega_m)F(\\omega_o,\\omega_m)G(\\omega_i, \\omega_o)}{4\\cos\\theta_i\\cos\\theta_o} \\end{aligned} \\end{equation} $$\nTorrance-Sparrow采样 # 若Sample_wm得到的\\(\\omega_i\\)朝向表面下方, 这意味着反射后仍然位于微表面, 需要执行多次散射. pbrt不考虑这种情况, 显然在极为粗糙的表面这会导致能量损失.\nVector3f wm = mfDistrib.Sample_wm(wo, u); Vector3f wi = Reflect(wo, wm); if (!SameHemisphere(wo, wi)) return {}; 粗糙绝缘体BSDF # 粗糙绝缘体PDF # 根据Snell定律我们可以把投影到与半向量垂直的平面上的部分抵消, 由此可得以下关系. 此时得到的半向量总是指向光学密度较大的一侧, 需要后续修正. 对于反射由于\\(\\eta_i=\\eta_o\\)这与半向量是等价的.\n$$ \\begin{equation} \\omega_m=\\frac{\\eta_i\\omega_i+\\eta_o\\omega_o}{\\Vert\\eta_i\\omega_i+\\eta_o\\omega_o\\Vert}=\\frac{\\eta\\omega_i+\\omega_o}{\\Vert\\eta\\omega_i+\\omega_o\\Vert} \\end{equation} $$\n此时Jacobi行列式结果如下, 这可以由几何关系推导得到, 具体见Water et al. 2007.\n$$ \\begin{equation} \\begin{aligned} \\frac{d\\omega_m}{d\\omega_i} \u0026amp;=\\frac{|\\omega_i\\cdot\\omega_m|\\eta_i^2}{((\\eta_i\\omega_i+\\eta_o\\omega_o)\\cdot\\omega_m)^2}\\\\ \u0026amp;=\\frac{|\\omega_i\\cdot\\omega_m|}{((\\omega_i\\cdot\\omega_m)+\\frac{(\\omega_o\\cdot\\omega_m)}{\\eta})^2} \\end{aligned} \\end{equation} $$\n粗糙绝缘体BSDF # 根据PDF可以将Torrance-Sparrow BRDF拓展到BTDF, 得到完整的BSDF.\n$$ \\begin{equation} \\begin{aligned} f_t(p,\\omega_o,\\omega_i) \u0026amp;=\\frac{D_{\\omega_o}(\\omega_m)(1-F(\\omega_o\\cdot\\omega_m))G(\\omega_i)|\\omega_i\\cdot\\omega_m|}{((\\omega_i\\cdot\\omega_m)+\\frac{(\\omega_o\\cdot\\omega_m)}{\\eta})^2|\\cos\\theta_i|}\\\\ \u0026amp;=\\frac{D(\\omega_m)(1-F(\\omega_o\\cdot\\omega_m))G(\\omega_i,\\omega_o)}{((\\omega_i\\cdot\\omega_m)+\\frac{(\\omega_o\\cdot\\omega_m)}{\\eta})^2}\\frac{|\\omega_i\\cdot\\omega_m||\\omega_o\\cdot\\omega_m|}{|\\cos\\theta_i||\\cos\\theta_o|} \\end{aligned} \\end{equation} $$\n粗糙绝缘体采样 # 与之前章节描述的一样, 对法线进行重要性抽样并随机选取反射或折射.\nBSDF测量值 # 现实世界中的很多材质无法通过微表面模型表达, pbrt采用测量值来实现数据驱动的反射模型, 通过采样估计的粗糙度对应的法线分布来提高测量效率.\n测量过程 # 参数化测量 # 由于测量出的BRDF在量级上可能差距较大, 不适合线性插值, pbrt将采样值变换为Monte Carlo权重的形式再插值.\n$$ \\begin{equation} M^{(k)} = \\frac{f_r(\\omega_o, \\omega_i^{(k)})\\cos\\theta_i^{(k)}}{p(\\omega_i^{(k)})} \\end{equation} $$\nBRDF求解 # 令\\(M\\)为样本插值, \\(R(\\omega_o, u)=\\omega_i\\)为重要性抽样, 数据驱动的BRDF可以按如下方式表示.\n$$ \\begin{equation} f_r(\\omega_o,\\omega_i)=\\frac{M(R^{-1}(\\omega_o,\\omega_i))p(\\omega_i)}{\\cos\\theta_i} \\end{equation} $$\n泛化微表面模型 # 对于测量值BRDF, 可以使用最基本的Smith遮蔽函数的定义来得到PDF, 因为可以通过数值积分计算这里不采用Smith遮蔽函数的解析形式.\n$$ \\begin{equation} \\begin{aligned} p(\\omega_i) \u0026amp;= \\frac{D_{\\omega_o}(\\omega_m)}{4(\\omega_o\\cdot\\omega_m)}\\\\ \u0026amp;= \\frac{D(\\omega_m)\\max(0,\\omega_o\\cdot\\omega_m)}{4(\\omega_o\\cdot\\omega_m)\\int_\\Omega D(\\omega)\\max(0,\\omega_o,\\omega)d\\omega}\\\\ \u0026amp;= \\frac{D(\\omega_m)}{4\\sigma(\\omega_o)} \\end{aligned} \\end{equation} $$\n此时可以求解BRDF.\n$$ \\begin{equation} f_r(\\omega_o,\\omega_i)=\\frac{M(R^{-1}(\\omega_o,\\omega_i))D(\\omega_m)}{4\\sigma(\\omega_o)\\cos\\theta_i} \\end{equation} $$\n初始微表面模型 # 法线分布函数只有两个维度, 不会有维度组合数量的问题, 因此可以通过估计\\(D(\\omega)\\)来获取初始微表面模型. 对于右侧的积分, 可以先测量\\(f_r(p, \\omega_j, \\omega_j)\\)作为\\(D(\\omega_j)\\)的估计, 即不考虑遮蔽函数.\n$$ \\begin{equation} \\begin{aligned} f_r(p,\\omega,\\omega)\u0026amp;=\\frac{D(\\omega)F(\\omega\\cdot\\omega)G(\\omega,\\omega)}{4\\cos^2\\theta}\\propto\\frac{D(\\omega)G_1(\\omega)}{\\cos^2\\theta}\\\\ D(\\omega)\u0026amp;\\propto f_r(p,\\omega,\\omega)\\cos\\theta\\int_\\Omega D(\\omega_m)\\max(0,\\omega\\cdot\\omega_m)d\\omega_m \\end{aligned} \\end{equation} $$\n基础数据结构 # 通过PiecewiseLinear2D实现插值与采样.\nstruct MeasuredBxDFData { // MeasuredBxDFData Public Members pstd::vector\u0026lt;float\u0026gt; wavelengths; PiecewiseLinear2D\u0026lt;3\u0026gt; spectra; PiecewiseLinear2D\u0026lt;0\u0026gt; ndf; PiecewiseLinear2D\u0026lt;2\u0026gt; vndf; PiecewiseLinear2D\u0026lt;0\u0026gt; sigma; bool isotropic; PiecewiseLinear2D\u0026lt;2\u0026gt; luminance; MeasuredBxDFData(Allocator alloc) : ndf(alloc), sigma(alloc), vndf(alloc), luminance(alloc), spectra(alloc), wavelengths(alloc) {} static MeasuredBxDFData *Create(const std::string \u0026amp;filename, Allocator alloc); std::string ToString() const { return StringPrintf(\u0026#34;[ MeasuredBxDFData filename: %s ]\u0026#34;, filename); } std::string filename; }; 求解 # MeasuredBxDF中存储MeasuredBxDFData指针并实现相应的功能.\n毛发散射 # 各个波长在毛发上的反射率是类似的, 因此毛发的颜色主要由吸收的折射光的量决定. 这可以通过DielectricBxDF与体渲染结合实现, 但这种方式计算量较大且无法实现重要性抽样. 特化的毛发BSDF可以解决该问题.\n几何 # 毛发通过Curve实现, pbrt假设毛发为朝向入射光的带状曲面, 毛发BSDF基于圆柱形曲面, 在毛发不相互交织且不比像素宽很多的情况下, 这种转换是可行的.\n对于光线与圆柱曲面的交点\\(u,v\\), \\(u\\)上的法线都位于同一平面, 此时令\\(\\frac{\\partial p}{\\partial u}\\)为\\(x\\)轴, \\(\\frac{\\partial p}{\\partial v}\\)为\\(y\\)轴, 入射光线可以转为纵向角与方位角, 即与\\(x\\)的夹角为\\(\\theta\\), \\(yz\\)平面中与\\(y\\)的夹角为\\(\\phi\\), 由于圆柱曲面的性质光线是位于\\(yz\\)平面的.\n$$ \\begin{equation} \\begin{aligned} \\theta \u0026amp;= \\frac{\\pi}{2}-\\cos^{-1}(\\omega\\cdot x)\\\\ \\phi \u0026amp;= \\pi-\\text{sign}(\\omega\\cdot z)(\\pi - \\cos^{-1}(\\omega\\cdot y)) \\end{aligned} \\end{equation} $$\n根据\\(v\\)的定义, 交点距离圆心的距离为\\(-1+2v\\), 此时可以得到光线与法线的夹角\\(\\gamma\\).\n$$ \\begin{equation} \\gamma = \\sin^{-1}(-1+2v) \\end{equation} $$\n毛发散射 # 毛发包含发鳞, 发皮质, 发髓三个部分, 发髓由一些列表面的凸起构成, 发皮质与发髓包含吸收光的色素, 以发髓的颜色为主. pbrt假设毛发表面是与圆柱夹角为\\(\\alpha\\)的圆锥状凸起, 毛发内部为同一介质即不产生内部散射. 同时pbrt假设光线在毛发上的相同位置入射与出射, 此时可以使用BSDF.\n光线会在毛发内部多次反射与折射, 令\\(p\\)为光线进入空气前反射或折射的次数, 例如\\(p=0\\)为第一次反射\\(R\\), \\(p=1\\)为第二次折射\\(TT\\), \\(p=3\\)为\\(TRT\\). 此时BSDF可以写为如下形式, 其中\\(M_p\\)为纵向散射方程, \\(N_p\\)为方位散射方程, \\(A_p\\)为衰减方程, 分母用于抵消Kajiya中的余弦项. pbrt只计算\\(p\\le 3\\)的BSDF, 余项合并为一项.\n$$ \\begin{equation} \\begin{aligned} f(\\omega_o,\\omega_i) \u0026amp;=\\sum_{p=0}^{\\infty} f_p(\\omega_o,\\omega_i)\\\\ \u0026amp;=\\sum_{p=0}^{\\infty} \\frac{M_p(\\theta_o,\\theta_i)A_p(\\omega_o)N_p(\\phi)}{\\cos\\theta_i}\\\\ \\end{aligned} \\end{equation} $$\nHairBxDF构造函数如下, 其中\\(h\\)为与曲线中心的偏移, \\(\\eta\\)为相对IOR, \\(\\sigma_a\\)为毛发内部的吸收率系数(吸收率与光线传播距离有关, 后续体渲染章节会介绍), \\(\\beta_m\\)为纵向粗糙度, \\(\\beta_n\\)为方位粗糙度, \\(\\alpha\\)为毛发表面凸起的夹角.\nPBRT_CPU_GPU HairBxDF(Float h, Float eta, const SampledSpectrum \u0026amp;sigma_a, Float beta_m, Float beta_n, Float alpha); 纵向散射 # 纵向散射方程如下, 其中\\(I_0\\)为第一类Bessel方程的修改, \\(v\\)为粗糙度. $$ \\begin{equation} M_p(\\theta_o,\\theta_i)=\\frac{e^{-\\frac{\\sin\\theta_i\\sin\\theta_o}{v}}}{2v\\text{sinh}(\\frac{1}{v})}I_0(\\frac{\\cos\\theta_o\\cos\\theta_i}{v}) \\end{equation} $$\npbrt根据\\(\\beta_m\\)计算不同\\(p\\)下的粗糙度.\n$$ \\begin{equation} \\begin{aligned} v_0 \u0026amp;= (0.726\\beta_m+0.812\\beta_m^2+3.7\\beta_m^20)^2\\\\ v_1 \u0026amp;= 0.25v_0\\\\ v_2 \u0026amp;= v_3 = \\cdots = v_{\\max} = 4v_0 \\end{aligned} \\end{equation} $$\n纤维吸收 # 吸收率受光线传播距离影响, 这需要计算折射光线的纵向角与方位角. 纵向角可以通过Snell定律获取, 方位角可以通过将\\(\\omega_t\\)投影到\\(yz\\)平面计算, 也可以使用修改后的IOR通过Snell定律计算.\n$$ \\begin{equation} \\eta\u0026rsquo;=\\frac{\\sqrt{\\eta^2-\\sin^2\\theta_o}}{\\cos\\theta_o} \\end{equation} $$\n根据直线与圆相交的性质可以得到在\\(yz\\)传播的距离, 除以纵向角的余弦即可获取传播距离.\n$$ \\begin{equation} l=\\frac{2\\cos\\gamma_t}{\\cos\\theta_t} \\end{equation} $$\n利用后面体渲染章节介绍的Beer定律可以得到经过吸收后的透射率.\n$$ \\begin{equation} T_r=e^{-\\sigma_a l} \\end{equation} $$\n此时可以得到\\(A_p\\)的定义, 余项可以通过通项公式得到.\n$$ \\begin{equation} \\begin{aligned} A_p\u0026amp;= \\begin{cases} A_{p-1}Tf=(1-f)^2 T^p f^{p-1} \u0026amp; p\u0026gt;0\\\\ f \u0026amp; p=0 \\end{cases} \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} \\sum_{p=p_{\\max}}^{\\infty}(1-f)^2 T^p f^{p-1}=\\frac{(1-f)^2 T^{p_{\\max}} f^{p_{\\max}-1}}{1-Tf} \\end{equation} $$\n方位散射 # 方位散射只需要考虑\\(\\phi\\), 即只需要考虑投影到\\(yz\\)平面上的圆, 以顺时针为正, 此时可以得到每次出射时的角度变化.\n$$ \\begin{equation} \\phi(p,h)=2p\\gamma_t-2\\gamma_o+p\\pi \\end{equation} $$\n对于粗糙度, pbrt选用截尾Logistic分布, 与Gaussian分布相比Logistic具有相似的形状且具有积分解析式.\n$$ \\begin{equation} l_t(x,s,[a,b])=\\frac{l(x,s)}{\\int_a^b l(x\u0026rsquo;,s)dx\u0026rsquo;} \\end{equation} $$\npbrt根据\\(\\beta_n\\)计算\\(s\\).\n$$ \\begin{equation} s=\\sqrt{\\frac{\\pi}{8}}(0.265\\beta_n+1.194\\beta_n^2+5.372\\beta_n^{22}) \\end{equation} $$\n散射模型求解 # 头发表面的凸起角度\\(\\alpha\\)会影响\\(\\theta\\), pbrt估计\\(R\\)偏移\\(2\\alpha\\), \\(TT\\)偏移\\(-\\alpha\\), \\(TRT\\)会偏移\\(-4\\alpha\\). 角度的偏移会导致高光瓣的偏移, 在头发上呈现出来的就是不同颜色的分层高光, 因为反射不影响颜色而折射会吸收光线.\n可逆性 # 毛发BSDF是不可逆的, 这是由凸起方向以及\\(A_p\\), \\(N_p\\)与折射方向相关导致的.\n采样 # 首先以\\(A_p\\)作为概率分布采样\\(p\\), 然后分别采样\\(M_p\\)与\\(N_p\\), 这两项都可以实现精确采样.\n毛发吸收系数 # 毛发的颜色由发皮质中的色素对光的吸收能力决定, 但毛发吸收系数与毛发颜色并不直接相关. 人类毛发中黑色素的浓度决定由金色到黑色的变化, 黄黑色素决定由橙色到红色的变化, pbrt中可以通过指定二者的浓度获取期望的发色.\nPBRT_CPU_GPU RGBUnboundedSpectrum HairBxDF::SigmaAFromConcentration(Float ce, Float cp) { RGB eumelaninSigma_a(0.419f, 0.697f, 1.37f); RGB pheomelaninSigma_a(0.187f, 0.4f, 1.05f); RGB sigma_a = ce * eumelaninSigma_a + cp * pheomelaninSigma_a; #ifdef PBRT_IS_GPU_CODE return RGBUnboundedSpectrum(*RGBColorSpace_sRGB, sigma_a); #else return RGBUnboundedSpectrum(*RGBColorSpace::sRGB, sigma_a); #endif } ","date":"2024 December 10","externalUrl":null,"permalink":"/render/1733816209202-pbrt-v4-episode-9/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. IX: 反射模型","type":"render"},{"content":"","date":"2024 December 2","externalUrl":null,"permalink":"/tags/kitty/","section":"Tags","summary":"","title":"Kitty","type":"tags"},{"content":"","date":"2024 December 2","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"","date":"2024 December 2","externalUrl":null,"permalink":"/tags/nvim/","section":"Tags","summary":"","title":"Nvim","type":"tags"},{"content":"","date":"2024 December 2","externalUrl":null,"permalink":"/tags/unix/","section":"Tags","summary":"","title":"Unix","type":"tags"},{"content":"最近nixos-24.11正式发版, 自己的配置已经维持了两个月的稳定状态, 是时候做个milestone了, 毕竟一直用unstable总有种不够declarative的感觉. 成品截图放在这里.\n窗口管理器 # 原本并没有用窗口管理器的打算, 最开始装Arch Linux的时候用的是KDE, 之前一直听说KDE更customizable, 工作上开发环境一直是ArchLinux配Gnome, 自己的电脑换换口味也无妨. 然而安装完之后, 第一印象就是朴素, 带有比较强的Windows风格, Gnome虽然也是在模仿MacOS的风格, 但相对来说更有自己的设计风格. 而且装了桌面环境就必须要接受大量默认的用不到的程序了, 我折腾的初衷还是希望有一个完全定制化的可控环境, 这点是不太能接受的.\n接触Hyprland的契机是ArchWiki desktop environment 中的custom environments章节, 可以比较直观的看到有桌面环境由哪些环境组成. Arch中可安装的WM的主页都浏览一遍的话, Hyprland显然是最华丽的一个, Wayland下流畅的动画与Tiling带来的纯键盘环境都是很attractive的feature, 窗口相关的透明度, 圆角, 阴影, 动画曲线等都是高度可自定义的(带透明和模糊的确实帅). Hyprland的配置文件格式也不算很复杂, 可以说是key可重复且不需要引号的json. 这里放一张我认为做的比较好看的配置, 来自unixporn.\n实际上手过程中这类Tiling WM实际上对小屏很不友好, 特别是在我的mba上用yabai的体验, 比较糟糕. 工作区的存在可以缓解这个问题, 但是同一个工作区窗口过少仍然是个问题. Gnome的插件PaperWM很好的解决了这个问题, 各个窗口像屏幕一样水平或垂直铺开, 不再局限于屏幕大小. 基于这种思想衍生出了niri这个WM, 由于NixOS声明式的特点我想切换到niri是很简单的, 但是niri对我最看重的透明模糊处理的并不好, 好在有hyprscroller这个插件. 同样从unixporn搬张图演示一下niri的效果.\n不过题外话, Hyprland的作者Varxy似乎比较神人, Freedesktop以他纵容Discord Hyprland频道中的恶劣氛围将他从中除名, 很多人也因为这点而拒绝使用Hyprland. Discord里各种俚语我不太看得懂, 但从他blog最近持续批判别的WM也可见一斑. 作为回应Varxy也另起炉灶, 不再依赖wlroots这一大部分wayland WM的核心组件, 确实是个技术强人.\n状态栏 # 一个桌面环境只有窗口和壁纸的话表达的信息量还是太少了, 不管是Windows还是MacOS都有任务栏, 状态栏这样的设计, 瞥一眼就能知道系统的大概信息是很重要的.\n我最初的选择是eww, 主要受这篇unixporn贴子的影响. 对我来说状态栏上的音乐播放状态与系统资源占用是比较重要的, 最后eww写出来的结果和开头展示的差不多. 但是eww最致命的一点就是他的配置语言一门作者自定义的叫做yuck的lisp方言, 简直就是括号地狱. 这里放一张之前说的eww贴子里的配置结果.\n最后我还是决定迁移到ags上, 与eww相同都是基于gtk提供的css配置能力, 与其他五花八门的状态栏相比, 基于css的话自定义能力约等于无限. 同时, eww的yuck需要严重依赖bash脚本来实现很多功能, 很多状态的更新都通过轮询来实现, 而ags的配置语言是JavaScript/TypeScript这门Web上的绝对标准语言, 无论是本身的表达能力还是社区能提供的第三方库都远强于eww, 同时状态也可以实现阻塞式更新. 这里放一张ags作者本人的配置.\n我的状态栏中icon, 工作区, 活动窗口哦都来自与ags本身提供的能力. ags的mpris协议不允许在没有音乐播放时使用默认的音乐信息, 所以音乐播放状态我这里通过playerctl获取, 支持阻塞式的获取音乐状态. cpu资源占用需要使用python的psutil库, cpu使用率需要持续监测50ms, 而功耗占用需要通过采样/sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj来计算(这个文件基于系统安全的考虑, 每次重启都会设置为包括root在内的所有用户不可读, 我这里通过启动脚本来在打开桌面时修改权限), 因此这两个数值的计算是异步的. nvidia显卡的占用情况通过nvidia-smi获取, amd核显则是rocm-smi.\n这里吐槽一下, ags作者最近推出了astal, 是进化版的ags, 支持通过任意语言利用html配置组件. 本来是好事, 但是ags作者发癫把ags v2改成了astal的typescript bundler, 和ags v1完全是不同的东西, tremendous breaking change! AUR那边似乎ags只有v2了, 所幸nixpkgs 24.11这边还是v1.\n终端模拟器 # 终端反倒是最开始就定下来几乎没有变化, 用的是kitty, 基于glfw实现opengl下的gpu加速. 对于终端其实美化的核心就是shell需要用到的几种颜色, 我这里的颜色衍生自cyberpunck主题. 颜色的选取确实是rice过程中投入最大收益最高的过程, 每天用随机颜色生成器搞出无数个颜色, 最后确定下来之后之后所有rice组件的颜色都可以从这些基础色号里派生. 除此之外, kitty的tab功能我是很喜欢的, 两侧渐变的感觉很有设计感. 至于透明模糊这块, 似乎只有MacOS上的kitty可以在终端这边配置, Linux上需要依赖WM提供的功能(要是有的话可能我就换niri了). 这里放一张我写这篇文章时的kitty状态.\n期间倒也尝试过别的终端. MacOS默认Terminal就不说了, 只支持16色, 否则还算好用. Alacritty是用rust写的, 但是第一次打开时那种糊成一片的感觉有点劝退, 似乎听说bug也略多. Rio是比较新的终端, 后端是WebGPU, 但是在我的mba上色彩空间转换竟然是错的, 线性颜色直接赋给拍P3色域上的值了. Warp比较特殊, 集成了ai功能, 是一个相对笨重的软件了, 也不支持tiling.\n壳 # 或许shell叫命令行会更好? MacOS上比较常规, 是zsh; Linux上我用的是elvish, 用go编写, 不支持bash, 语法比较干净, 默认提供的功能用到的倒是不多, 主要用到支持基于已有输入上下键浏览历史, 但是虚拟文本不全命令是不支持的, 只是相比于前者不太重要. 和三大主流bash/zsh/fish比起来倒也没什么优势, 主要挺喜欢他的语法的(有种函数式的优雅), 标准库功能充足, bash历史的余韵太浓了. 这里放一下我的rc代码.\nfn ls {|@args| e:ls --color $@args } fn ssh-agent { var set_ssh_env = {|env_cmd| use str var env_var env_prec = (str:split \u0026#39;=\u0026#39; $env_cmd) var env_val env_expt env_tail = (str:split \u0026#39;;\u0026#39; $env_prec) set-env $env_var $env_val } var auth_sock_cmd agent_pid_cmd echo_cmd = (e:ssh-agent) $set_ssh_env $auth_sock_cmd $set_ssh_env $agent_pid_cmd } var set-base-name = {|@args| e:kitty @ set-tab-title (basename (pwd)) } var set-tab-title = {|@args| if (\u0026gt; (count $@args) 0) { e:kitty @ set-tab-title $@args } } set-env EDITOR nvim set-env http_proxy \u0026#39;http://127.0.0.1:7890\u0026#39; set-env https_proxy \u0026#39;http://127.0.0.1:7890\u0026#39; if (==s $E:TERM \u0026#39;xterm-kitty\u0026#39;) { set edit:before-readline = [ $set-base-name ] set edit:after-readline = [ $set-tab-title ] } eval (starship init elvish) 至于prompt, Linux用的是starship, 配置基于toml, MacOS则是oh my posh, 配置基于json. 我其实更喜欢json, 配置结构一眼就能看出来, omp比较不能忍受的一点是unicode字符需要手动输入编码. 二者的表现力倒是差不多的, 我最开始是被starship的一种默认配置吸引, 自己的prompt也是基于这个配置, 图放在下面.\n编辑器 # 对于代码工作这其实是核心, 别的都只是为了心情愉悦, 编辑器的好坏是直接影响生产力的.\n与喜欢折腾的米娜桑一样, 我用的是neovim. 接触vim的契机是本科期间的linux编程课, 虽然只有短短4周, 但是linux中的shell, vim, gcc, 网络编程等方面都有涉猎, 也获得不少初级的实践经验, 算是linux启蒙了. 最开始我是在VS和VSCode中使用vim插件, 后面保研结束闲得没事干开始折腾nvim. 不得不说nvim以及各种插件的迭代确实是飞速, 一两年前的配置教程直接复制已经是不可用的了.\nneovim的状态栏用的是lualine.nvim, 同时自己实现了活动lsp以及通过lsp捕获当前所在scope的部分. 这里用rust演示状态栏的工作情况, 可以看到有当前模式, 光标位置, lsp, scope以及git branch. 关于scope这部分, vim.lsp.buf_request_all中的callback接口似乎文档有误, 文档中是function(err, result, ctx), 实际则是function(result).\n为了不让底边栏过于臃肿, 文件名, lsp诊断与git状态我都挪到了右上角, 通过incline.nvim实现. incline几乎没有提供任何封装, 渲染结果几乎只根据用户提供的字符串与高亮组来生成, 自由又原始.\n对于编辑器中很常见的tab功能, 我使用的是bufferline.nvim. 当然, buffer不是tab, 对于每个文件buffer是唯一的, neovim中的tab我不是很喜欢用, 我反而是用kitty的tab来做. 配置中buffer的顺序根据序号来排列, 而非打开顺序, 实际使用中倒也还好.\n文件管理我原本是用nvim-tree.lua, 但是他的快捷键过于违反vim常识了, 我也不太需要file tree在侧边保持开启, 因此更换到了oil.nvim. oil.nvim支持直接通过buffer操作来管理文件系统, 无缝连接编辑与文件管理, 加速了我的工作区文件管理流程. 这个名字来自于vim-vinegar文档中的这么一段话: \u0026ldquo;项目文件树与分屏窗口就像油和醋一样不搭配.\u0026rdquo; vim-vinegar以此为宗旨使得文件树直接出现在vim window中, 无需分离窗口, 同时可以像buffer一样编辑. 作为它的nvim版本, 自然是选用了oil这个名字. 这里放一张通过:w保存oil buffer后的界面, 这里的三个操作都是通过操作buffer完成的.\n其余杂七杂八的插件按下不表, 实际上我这里并没有使用原生的lua来编写插件, 而是通过nixvim这个发行版来通过nix编写. 说是发行版, 但其实只是对各个插件的配置进行nix化, 使得nvim配置能和nix配置相互交融. nixvim中也可以写lua配置, 并且通过nixvim安装的nvim会检测nix文件中的lua配置并使用treesitter实现高亮, 不会像字符串那样只有一种颜色. 以下是treesitter示例, .__raw之后的都是lua代码, 第一段实现活动lsp检测, 第二段实现lsp scope检测.\n可能会有人觉得在gui功能丰富且完善的今天使用vim是某种显得蛋疼的行为, 但vim带给我的最重要的资产其实是一种高效的编辑模式而非编辑器本身, 各个主流gui编辑器/IDE都可以通过vim模式来编辑, 不需要再单独学习各类快捷键操作, 这是受益终身的.\n发行版 # 发行版我放到最后来讲, 虽然以上种种都需要依赖某种Linux发行版来作为运行的基础, 但各大发行版实际上大同小异, 更多的是包格式与软件源上的差别.\n我最开始是用ArchLinux的, 与在公司的工作流一致. 都说Arch难, 实际上比较弱智的包管理机制, 内容详实的ArchWiki和拥有几乎一切软件的AUR对想要对系统做出一些改动的用户来说是非常友好的, 我的这些rice也基本都在Arch上就完成了整体框架.\n后来更换发行版的契机其实就是配置文件的管理, 原本我是通过git orphan branch来分别存储各个软件的配置文件, 维护多个分支是相对麻烦的一件事, 如果要在别人的系统上复现也不太友好. 同时Arch的滚动更新的特性导致某个软件一旦出现bug就需要自己想办法去修复, 尽管可以安装旧版本但在pacman下是比较危险的.\n以此为目的我开始使用NixOS并把配置迁移为Nix语言, 中途也经历了一次重装系统, Nix非常完美的复现了重装之前的配置, 软件出现bug时也可以轻松回滚. Nix是利用纯函数式语言来实现精确的包构建的包管理器, 实际上不依赖NixOS, 但是在NixOS上可以实现系统配置的可复现. 其实对于我一开始管理配置文件的需求, 只需要home-manager即可, 但为了最完美的匹配Nix最终还是成为了一名NixOS的忠实用户.\nNix的包都通过nixpkgs这个仓库来管理, 有滚动的unstable分支, 每半年会branch出一个稳定版, 比如最新的24.11. nixpkgs每次发版的代号都是某种动物, 24.11的代号就是Vicuña, 即羊驼. 在直到写这篇博客的一天之前我都是unstable的用户, 但是最近ags的breaking change让我坚定了成为稳定版钉子户的决心, 保卫我维护了一年的配置.\n在容器化大行其道的今天, Nix这套复现整个系统的方法显得过于笨重了, 学习曲线也较为陡峭. 但作为一个工作流已经稳定的个人用户, 稳定压倒一切, NixOS就是最适合我的发行版.\n结语 # 折腾配置的这一年还是很开心的, 有一种从0开始掌控计算机的快感, 不过折腾之外的代码倒是没写多少. 这和工作有关, 已经不是学校里随时随地写自己喜欢的代码的人了, 当然目前工作的内容我还是很喜欢的. 现在pbrt已经读到采样重建的章节了, 希望再过几个星期读完之后可以在2025年内写一个新的Vulkan渲染引擎, 用现在的这套工作流实现一些我觉得很cool的feature.\n","date":"2024 December 2","externalUrl":null,"permalink":"/unix/1733125104852-workflow/","section":"Unix","summary":"","title":"稳定版工作流记录","type":"unix"},{"content":" 本章主要介绍采样理论与图像滤波, 利用图像处理技术可以有效降低渲染所需的样本量.\n采样理论 # 频域与Fourier变换 # 样本空间通常位于空间中, 利用Fourier变换可以转换到频域中.\nFourier级数 # 对于一个函数集合中任意不同的函数\\(f(x),g(x)\\)若满足\\(\\int_{-\\infty}^{\\infty} f(x)g(x) dx = 0\\), 则该集合被称为正交函数系. 根据Hilbert空间理论, 可以证明三角函数系\\(\\lbrace\\cos 0, \\sin 0, \\cos(\\omega x), \\sin(\\omega x), \\cos(2 \\omega x), \\sin(2 \\omega x), \u0026hellip;\\rbrace\\)为完备的正交函数系, 可以用于表示任意函数.\n由此可得周期函数Fourier分解的一般形式, 频率采用\\(\\omega = \\frac{1}{T}\\)表示.\n$$ \\begin{equation} f(x) = \\sum_{n = 0}^{\\infty} \\left(a_n \\cos n 2\\pi \\omega x + b_n \\sin n 2\\pi \\omega x \\right) \\end{equation} $$\n各项系数可以基于正交理论得到.\n$$ \\begin{equation} \\begin{aligned} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x)dx \u0026amp;= Ta_0\\\\ \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) \\cos n 2\\pi \\omega x dx \u0026amp;= \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} a_n \\cos^2 n 2\\pi \\omega x dx = \\frac{T}{2}a_n\\\\ \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) \\sin n 2\\pi \\omega x dx \u0026amp;= \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} b_n \\sin^2 n 2\\pi \\omega x dx = \\frac{T}{2}b_n \\end{aligned} \\end{equation} $$\n系数转为极坐标可获取相位.\n$$ \\begin{equation} \\begin{aligned} f(x) \u0026amp;= \\sum_{n = 0}^{\\infty} \\left(c_n \\cos\\phi_n \\cos n 2\\pi \\omega x + c_n\\sin\\phi_n \\sin n 2\\pi \\omega x \\right)\\\\ \u0026amp;= \\sum_{n = 0}^{\\infty} c_n \\cos(n 2\\pi \\omega x + \\phi_n) \\end{aligned} \\end{equation} $$\n基于Euler公式\\(e^{ix} = \\cos x + i\\sin x \\)可以进一步转换Fourier展开.\n$$ \\begin{equation} \\begin{aligned} f(x) \u0026amp;= \\sum_{n=0}^{\\infty} \\left(a_n \\frac{e^{i n 2\\pi \\omega x} + e^{-i n 2\\pi \\omega x}}{2} + b_n \\frac{-i(e^{i n 2\\pi \\omega x} - e^{-i n 2\\pi \\omega x})}{2}\\right)\\\\ \u0026amp;= \\sum_{n=0}^{\\infty} \\frac{e^{i n 2\\pi \\omega x}(a_n - i b_n) + e^{-i n 2\\pi \\omega x}(a_n + i b_n)}{2}\\\\ \u0026amp;= a_0 + \\sum_{n=1}^{\\infty} \\frac{e^{i n 2\\pi \\omega x}(a_n - i b_n)}{2} + \\sum_{n=-\\infty}^{-1} \\frac{e^{i n 2\\pi \\omega x}(a_{-n} - i b_{-n})}{2}\\\\ \u0026amp;= \\sum_{n=-\\infty}^{\\infty} d_n e^{i n 2\\pi \\omega x} \\end{aligned} \\end{equation} $$\n对于分段系数\\(d_n\\)分别证明可以得到如下的结论.\n$$ \\begin{equation} \\begin{aligned} d_{n=0} \u0026amp;= \\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x)dx\\\\ \u0026amp;= \\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) e^{-i n 2\\pi \\omega x} dx\\\\ d_{n \u0026gt; 0} \u0026amp;= \\frac{a_n - i b_n}{2}\\\\ \u0026amp;= \\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) (\\cos n 2\\pi \\omega x - i\\sin n 2\\pi \\omega x) dx\\\\ \u0026amp;= \\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) e^{-i n 2\\pi \\omega x} dx\\\\ d_{n \u0026lt; 0} \u0026amp;= \\frac{a_{-n} + i b_{-n}}{2}\\\\ \u0026amp;= \\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) (\\cos (-n 2\\pi \\omega x) + i\\sin (-n 2\\pi \\omega x)) dx\\\\ \u0026amp;= \\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) e^{-i n 2\\pi \\omega x} dx\\\\ d_n \u0026amp;= \\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) e^{-i n 2\\pi \\omega x} dx \\end{aligned} \\end{equation} $$\n经整理得到较为常用的Fourier级数的形式.\n$$ \\begin{equation} F_i(x) = \\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(x) e^{-i n 2\\pi \\omega x} dx \\end{equation} $$\nFourier变换 # Fourier级数针对周期函数, 对于非周期函数可以看作\\(T \\to +\\infty\\)的周期函数, 此时各项频率\\(\\frac{n}{T}\\)转化为连续变化的频率\\(\\omega\\), \\(\\frac{1}{T}\\)转化为无穷小\\(d\\omega\\), 由此可得下式.\n$$ \\begin{equation} f(x) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(y) e^{-i 2 \\pi \\omega y}dy\\ e^{i 2\\pi \\omega x} d\\omega \\end{equation} $$\n从中可以提取出Fourier变换, 对于实数域其结果为偶函数.\n$$ \\begin{equation} F(\\omega) = \\int_{-\\infty}^{\\infty} f(x) e^{-i 2 \\pi \\omega x} dx \\end{equation} $$\n理想采样与重建 # 冲激函数列 # 利用Dirac方程构建周期为T的冲激函数列, 用于表示采样点分布.\n$$ \\begin{equation} III_T(x) = T \\sum_{n = -\\infty}^{\\infty} \\delta(x - n T) \\end{equation} $$\n冲激函数列的Fourier展开与Fourier变换如下, Fourier变换后周期变为倒数, 在空间上较远的样本在频域上较近.\n$$ \\begin{equation} \\begin{aligned} III_T(x) \u0026amp;= \\sum_{n=-\\infty}^{\\infty} e^{i n 2\\pi \\omega x} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} \\sum_{j = -\\infty}^{\\infty} \\delta(x - jT) e^{-i n 2\\pi \\omega x} dx\\\\ \u0026amp;= \\sum_{n=-\\infty}^{\\infty} e^{i n 2\\pi \\omega x} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} \\delta(x) e^{-i n 2\\pi \\omega x} dx\\\\ \u0026amp;= \\sum_{n=-\\infty}^{\\infty} e^{i n 2\\pi \\omega x}\\\\ F_{III}(\\omega) \u0026amp;= \\sum_{j=-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} T \\delta(x - jT) e^{-i 2\\pi \\omega x} dx\\\\ \u0026amp;= \\sum_{n=-\\infty}^{\\infty} T e^{-i n 2\\pi \\omega T}\\\\ \u0026amp;= \\frac{1}{\\frac{1}{T}} \\sum_{n=-\\infty}^{\\infty} e^{i \\frac{2\\pi}{\\frac{1}{T}} n (-\\omega)}\\\\ \u0026amp;= III_{\\frac{1}{T}}(-\\omega)\\\\ \u0026amp;= III_{\\frac{1}{T}}(\\omega) \\end{aligned} \\end{equation} $$\n卷积 # 卷积定义如下.\n$$ \\begin{equation} f(x) \\otimes g(x) = \\int_{-\\infty}^{\\infty} f(y)g(x-y) dy \\end{equation} $$\n通过调整积分顺序, 傅里叶变换具有如下的卷积定理.\n$$ \\begin{equation} \\begin{aligned} \\mathcal{F} \\lbrace f(x) \\otimes g(x) \\rbrace \u0026amp;= \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x)g(y-x)dx\\ e^{-i 2\\pi \\omega y} dy\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} f(x) \\int_{-\\infty}^{\\infty} g(y - x) e^{-i 2\\pi \\omega (y - x + x)} dy dx\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} f(x) \\int_{-\\infty}^{\\infty} g(z) e^{-i 2\\pi \\omega (z + x)} dz dx\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} f(x) e^{-i 2\\pi \\omega x} dx \\int_{-\\infty}^{\\infty} g(z) e^{-i 2\\pi \\omega z } dz\\\\ \u0026amp;= \\mathcal{F} \\lbrace f(x) \\rbrace \\mathcal{F} \\lbrace g(x) \\rbrace \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} \u0026amp;\\mathcal{F}^{-1} \\lbrace \\mathcal{F} \\lbrace f(x) \\rbrace \\otimes \\mathcal{F} \\lbrace g(x) \\rbrace \\rbrace\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(\\omega) G(\\phi - \\omega) d\\omega \\ e^{i 2\\pi \\phi x} d\\phi\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} F(\\omega) \\int_{-\\infty}^{\\infty} G(\\phi - \\omega) e^{i 2\\pi (\\phi - \\omega + \\omega) x} d\\phi d\\omega\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} F(\\omega) e^{i 2\\pi \\omega x} d\\omega \\int_{-\\infty}^{\\infty} G(\\theta) e^{i 2\\pi \\theta x} d\\theta\\\\ \u0026amp;= f(x)g(x) \\end{aligned} \\end{equation} $$\n滤波 # 对某个函数的采样结果添加滤波形式如下.\n$$ \\begin{equation} \\begin{aligned} \\tilde{f}(x) \u0026amp;= (III_T(x)f(x))\\otimes r(x)\\\\ \u0026amp;= T \\sum_{i=-\\infty}^{\\infty} f(iT)r(x - iT) \\end{aligned} \\end{equation} $$\nFourier变换形式如下, 可见\\(\\omega_{III} = \\frac{1}{T} \\rightarrow +\\infty\\), \\(\\mathcal{F} \\lbrace f(x) \\rbrace \\otimes III_{\\frac{1}{T}}(\\omega) \\rightarrow \\mathcal{F} \\lbrace f(x) \\rbrace\\), \\(\\omega_{III} \\rightarrow 0\\)导致\\(\\mathcal{F} \\lbrace \\omega \\rbrace\\)被复制到\\(\\mathcal{F} \\lbrace \\omega + n\\omega_{III} \\rbrace\\). 令\\(\\omega_f\\)为\\(f(x)\\)的最高频率, \\(\\omega_{III} \u0026lt; 2 \\omega_f\\)会导致混叠, 即渲染中常见的走样现象, 系数2来自于实函数Fourier变换后为偶函数的对称性质. 由此可得Nyquist采样定理: 采样频率高于原函数频率的两倍, 即高于Nyquist频率, 可消除混叠.\n$$ \\begin{equation} \\begin{aligned} \\mathcal{F} \\lbrace \\tilde{f}(x) \\rbrace \u0026amp;= \\mathcal{F} \\lbrace III_T(x)f(x) \\otimes r(x) \\rbrace\\\\ \u0026amp;= \\mathcal{F} \\lbrace III_T(x)f(x) \\rbrace \\mathcal{F} \\lbrace r(x) \\rbrace\\\\ \u0026amp;= (\\mathcal{F} \\lbrace f(x) \\rbrace \\otimes III_{\\frac{1}{T}}(\\omega)) \\mathcal{F} \\lbrace r(x) \\rbrace \\end{aligned} \\end{equation} $$\n当\\(\\omega_{III}\\)大于Nyquist频率, 若有如下\\(\\mathcal{F} \\lbrace r(x) \\rbrace\\), 可使\\(\\mathcal{F} \\lbrace \\tilde{f}(x) \\rbrace = \\mathcal{F} \\lbrace {f}(x) \\rbrace\\). \\(\\text{sinc}_T(x)\\)与\\(\\Pi_\\frac{1}{T}(x)\\)可在空域与频率相互转化, 基于\\(\\text{sinc}_T(x)\\)设计滤波器可接近理想情况. 同样的若在空域使用\\(\\Pi_T\\)会导致高频无法消除, 但优势在于计算量小.\n$$ \\begin{equation} \\begin{aligned} \\mathcal{F} \\lbrace r(x) \\rbrace= \\Pi_{\\frac{1}{T}} = \\begin{cases} T \u0026amp;|\\omega| \u0026lt; \\frac{1}{2T}\\\\ 0 \u0026amp;\\text{otherwise} \\end{cases} \\end{aligned} \\end{equation} $$\n离散Fourier变换 # 实际信号多为离散采样, 按\\(T\\)的间隔采样\\(N\\)次信号. 我们认为信号的周期为\\(NT\\), 此时信号的Fourier变换如下.\n$$ \\begin{equation} \\begin{aligned} F(\\omega) \u0026amp;= \\int_{-\\infty}^{\\infty} \\sum_{n = -\\infty}^{\\infty} f(x) \\sigma(x - nT) e^{-i 2 \\pi \\omega x}dx\\\\ \u0026amp;= \\sum_{n = -\\infty}^{\\infty} f(nT) e^{-i 2 \\pi \\omega n T} \\end{aligned} \\end{equation} $$\n根据Nyquist采样定律, 需要假设\\(f(x)\\)的频率\\(|\\omega| \u0026lt; \\frac{1}{2T}\\). 根据对冲激函数的分析, \\(F(\\omega)\\)是周期为\\(\\frac{1}{T}\\)的函数, 因此可以将\\((-\\frac{1}{2T}, \\frac{1}{2T})\\)映射到\\((0, \\frac{1}{T})\\). 作为周期函数\\(f(x)\\)最低频率为\\(\\frac{1}{NT}\\), 频谱只包含\\(\\frac{n}{NT},n \\in [0, N-1]\\). 从Euler公式的三角函数部分可以得出\\(e^{-i\\frac{2\\pi}{N}kn}=e^{-i\\frac{2\\pi}{N}k(n + jN)}, j \\in (-\\infty, \\infty)\\). 此时Fourier变换可以改写为如下形式.\n$$ \\begin{equation} F(\\frac{k}{NT}) = \\sum_{i = -\\infty}^{\\infty} \\sum_{n = 0}^{N - 1} f(nT) e^{-i \\frac{2\\pi}{N} k n} \\end{equation} $$\n抽取出其中有效的部分即为离散Fourier变换(DFT). 从线性代数的视角看, DFT变换为\\(N \\times N\\)方阵\\(M_{ij}=e^{-i\\frac{2\\pi}{N}ij}\\), 因此可逆且有唯一解.\n$$ \\begin{equation} F[k] = \\sum_{n=0}^{N-1} f[n] e^{-i \\frac{2\\pi}{N}nk} \\end{equation} $$\n抽取DFT每项系数为\\(W_N^{kn} = e^{-i \\frac{2\\pi}{N}kn}\\), 根据Euler公式展开后的三角函数可推导出如下性质.\n$$ \\begin{equation} \\begin{aligned} W_N^{k+N}\u0026amp;=W_N^k\u0026amp;\\\\ W_N^{k+\\frac{N}{2}}\u0026amp;=-W_N^k\u0026amp;\\\\ W_N^{mkn}\u0026amp;=W_{\\frac{N}{m}}^{kn},\u0026amp;m|N \\end{aligned} \\end{equation} $$\n假设\\(N=2^r\\), 按如下方式组织DFT, 此时只需要计算\\(\\sum_{n=0}^{\\frac{N}{2} - 1} W_{\\frac{N}{2}}^{kn}\\). 由于\\(W_{\\frac{N}{2}}^{(k+\\frac{N}{2})n}=W_{\\frac{N}{2}}^{kn}, W_N^{k + \\frac{2}{N}} = -W_N^k\\), 可得\\(F[k + \\frac{N}{2}] = F_{\\text{even}}[k] - W_N^k F_{\\text{odd}}[k]\\), 即蝶形公式.\n$$ \\begin{equation} \\begin{aligned} F[k] \u0026amp;= \\sum_{n=0}^{\\frac{N}{2} - 1} f[2n] e^{-i \\frac{2\\pi}{N}2kn} + \\sum_{n=0}^{\\frac{N}{2} - 1} f[2n + 1] e^{-i \\frac{2\\pi}{N}(2n + 1)k}\\\\ \u0026amp;= \\sum_{n=0}^{\\frac{N}{2} - 1} f[2n] e^{-i \\frac{2\\pi}{\\frac{N}{2}}kn} + e^{-i \\frac{2\\pi}{N}k} \\sum_{n=0}^{\\frac{N}{2} - 1} f[2n + 1] e^{-i \\frac{2\\pi}{\\frac{N}{2}}kn}\\\\ \u0026amp;= \\sum_{n=0}^{\\frac{N}{2} - 1} f[2n] W_{\\frac{N}{2}}^{kn} + W_N^k \\sum_{n=0}^{\\frac{N}{2} - 1} f[2n + 1] W_{\\frac{N}{2}}^{kn}\\\\ \u0026amp;= F_{\\text{even}}[k] + W_N^k F_{\\text{odd}}[k] \\end{aligned} \\end{equation} $$\n采样模式的频谱分析 # 采样率固定时需分析采样点的分布对质量的影响, 对于难以分析频域特征的随机性采样模式, 需要针对每次生成的样本分析频谱特征.\n数学上信号功率为由信号函数的平方, 功率谱密度(PSD)可用于频谱分析. 根据Wiener-Khinchin定理它可通过自相关函数的Fourier变换计算, 整理后为Fourier变换结果与其共轭函数的乘积. 由卷积定理可得不同函数乘积的PSD为二者PSD的卷积.\n$$ \\begin{equation} \\begin{aligned} \\mathcal{F}[\\mathcal{R}(\\chi)] \u0026amp;= \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x) f(x + \\chi) e^{-i 2\\pi \\omega \\chi} d\\chi dx\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} f(x) \\int_{-\\infty}^{\\infty} f(x + \\chi) e^{-i 2\\pi \\omega \\chi} d\\chi dx\\\\ \u0026amp;= \\int_{-\\infty}^{\\infty} f(x) e^{i 2\\pi \\omega x} \\int_{-\\infty}^{\\infty} f(x + \\chi) e^{-i 2\\pi \\omega (x + \\chi)} d(x + \\chi) dx\\\\ \u0026amp;= F(\\omega) \\overline{F(\\omega)} \\end{aligned} \\end{equation} $$\n对于采样密度为无穷的理想采样, 其PSD为位于原点的Dirac delta函数. 对于随机采样可以通过数值方法计算PSD, 将每个采样点视为一个Dirac delta函数, 从而将积分转为求和. 通过对均匀采样添加均匀分布的抖动\\(\\epsilon\\)获得的PSD的期望如下, 此时在原点为Dirac delta, 低频下功率接近0, 高频下接近1. 基于图片的能量都集中在低频的假设, 此时通过图片PSD与抖动采样PSD之间的卷积高频能量被分散到低频中, 形成高频噪声, 与低频走样相比人类视觉对噪声的接受程度更高.\n$$ \\begin{equation} \\begin{aligned} s_T(x) \u0026amp;= \\sum_{n = -\\infty}^{\\infty} \\delta(x - (i + \\frac{1}{2} - \\epsilon)T)\\\\ P_s(\\omega) \u0026amp;= 1 - \\text{sinc}^2(\\frac{T\\omega}{2}) + \\delta(\\omega) \\end{aligned} \\end{equation} $$\nPSD有时通过颜色描述, 例如白噪声是功率均匀分布的, 蓝噪声则集中在高频, 这与对应颜色的光的性质是相似的. 渲染中通常会使用预计算的噪声贴图, 可以观察到蓝噪声像素之前差异性更大, 白噪声则有相似像素聚集的现象.\n采样与积分 # 方差的Fourier分析 # 图形学中的Monte Carlo采样通常位于\\([0,1]^d\\)中, 因此后续Fourier分析都在此基础上简化.\n与Fourier变换后的PSD类似, 函数的PSD可以分解为Fourier级数每项的PSD, 对于实偶函数这相当于Fourier系数的平方.\n$$ \\begin{equation} \\begin{aligned} P_f(n) \u0026amp;= f_n e^{-i n 2\\pi x} \\overline{f_n} e^{i n 2\\pi x}\\\\ \u0026amp;= f_n \\overline{f_n} \\end{aligned} \\end{equation} $$\n对于Monte Carlo, 可将其看作多次采样的平均, 可以将这个过程用Dirac delta函数表示.\n$$ \\begin{equation} \\begin{aligned} s(x) \u0026amp;= \\frac{1}{n} \\sum_{i=1}^{n} \\delta(x - x_i)\\\\ \\int_0^1 f(x) dx \u0026amp;\\approx \\frac{1}{n} \\sum_{i=1}^n f(x_i)\\\\ \u0026amp;= \\int_0^1 f(x) s(x) dx\\\\ \u0026amp;= \\int_0^1 \\sum_{n = -\\infty}^{\\infty} s_n e^{i n 2\\pi x} f(x) dx\\\\ \u0026amp;= \\sum_{n = -\\infty}^{\\infty} \\int_0^1 f(x) e^{i n 2\\pi x} dx \\int_0^1 s(y) e^{-i n 2\\pi y} dy\\\\ \u0026amp;= \\sum_{n = -\\infty}^{\\infty} \\overline{f_n} s_n \\end{aligned} \\end{equation} $$\n由于\\(f_0 = \\int_0^1 f(x) dx\\), Monte Carlo的误差分析可以转为如下形式.\n$$ \\begin{equation} \\left|\\int_0^1 f(x) dx - \\int_0^1 f(x) s(x) dx\\right| = \\left|f_0 - \\sum_{n = -\\infty}^{\\infty} \\overline{f_n} s_n\\right| = \\sum_{n = -\\infty, n \\ne 0}^{\\infty} \\overline{f_n} s_n \\end{equation} $$\n由于Fourier系数的正交性, 在实函数下方差即为二者PSD的乘积. 可以看出当二者的功率谱分布为负相关时可以取得最小的方差. 对于均匀分布采样或者白噪声采样, 此时Fourier系数为\\(\\frac{1}{n}\\), 由此可得方差为\\(O(\\frac{1}{n})\\). 同样的, 对于Possion圆盘采样进行Fourier分析后可以看出它的方差是劣于抖动采样的.\n$$ \\begin{equation} \\begin{aligned} Var[\\frac{1}{n} \\sum_{i=1}^n f(x_i)] \u0026amp;= (\\sum_{n = -\\infty, n \\ne 0}^{\\infty} \\overline{f_n} s_n)^2\\\\ \u0026amp;= \\sum_{n = -\\infty, n \\ne 0}^{\\infty} \\overline{f_n}^2 s_n^2\\\\ \u0026amp;= \\sum_{n = -\\infty, n \\ne 0}^{\\infty} P_f(n) P_s(n) \\end{aligned} \\end{equation} $$\n低差异性与准Monte Carlo # 采样点的质量可以通过差异性来度量. 我们将固定数量的一些采样点称为采样点集, 由某种算法去生成的任意数量采样点被称为采样点序列. 通过比较每个采样点实际所占的体积与平均分配给每个点的体积可以评估这个采样序列的差异性.\n令P为采样点集, \\(B\\)为\\([0,1]^d\\)的子集区域即\\([0, v_0] \\times [0, v_1] \\times \\dots \\times [0, v_d]\\), \\(b\\)为\\(B\\)这一集合中的某个元素, \\(V(b)\\)为\\(b\\)所占的体积, \\(\\sharp{x_i \\in b}\\)为落在\\(b\\)中的采样点的数量, \\(\\sup\\)为上确界, 此时差异性可以按如下方式定义.\n$$ \\begin{equation} D_n(B, P) = \\sup_{b \\in B} \\left| \\frac{\\sharp{x_i \\in b}}{n} - V(b) \\right| \\end{equation} $$\n在一维上\\(x_i = \\frac{i - \\frac{1}{2}}{n}\\)可以获得最小的差异性. 对于大部分低差异性序列在高维下是具有更弱的均匀性的, 因此可以缓解出现前文所说的均匀采样带来的走样问题, 当然其固有的均匀性还是会使得它比伪随机序列更易产生走样. 低差异性序列所具有的差异性小于\\(O(\\frac{(log\\ n)^d}{n})\\)即可认为是低差异性序列.\n低差异性序列通常通过确定的算法生成, 采用低差异性序列执行Monte Carlo即为准Monte Carlo(quasi-Monte Carlo, QMC). 根据Koksma-Hlawka不等式可以得到低差异性序列采样的误差上界, 其中\\(V_f\\)代表总变差. 随着维数增加, 差异性会趋向于\\(n^{-1}\\), 这使得QMC的误差小于MC的\\(n^{-\\frac{1}{2}}\\), 尤其是样本较少的情况. 由于低差异性序列是确定的, 以方差作为度量手段是不适用的, 可以通过在不影响差异性的情况下对序列进行随机化来执行随机准Monte Carlo(randomized quasi-Monte Carlo, RQMC), 这会加速积分的收敛, 后面的部分会介绍.\n$$ \\begin{equation} \\begin{aligned} \\left| \\int_0^1 f(x) dx - \\frac{1}{n} \\sum_{i = 1}^n f(x_i) \\right| \\le D_n(B, P) V_f\\\\ V_f = \\sup_{0 = y_1 \u0026lt; y_2 \u0026lt; \\dots \u0026lt; y_n = 1} \\sum_{i=1}^{m} |f(y_i) - f(y_{i + 1})| \\end{aligned} \\end{equation} $$\n采样接口 # Sampler的实现需要支持生成在任意维数上的任意数量的样本. 由于低差异性序列确定性的特征, 采样失败时可以快速定位到样本序号并调试, 当然分支代码可能导致运行时的样本编号是不同的, 需要尽量避免分支. 渲染任务只需要使用最高二维的样本, 因此没有提供相关接口, 更高维的样本可以通过组合低维样本实现.\nclass Sampler : public TaggedPointer\u0026lt; // Sampler Types PMJ02BNSampler, IndependentSampler, StratifiedSampler, HaltonSampler, PaddedSobolSampler, SobolSampler, ZSobolSampler, MLTSampler, DebugMLTSampler \u0026gt; { public: // Sampler Interface using TaggedPointer::TaggedPointer; static Sampler Create(const std::string \u0026amp;name, const ParameterDictionary \u0026amp;parameters, Point2i fullResolution, const FileLoc *loc, Allocator alloc); PBRT_CPU_GPU inline int SamplesPerPixel() const; PBRT_CPU_GPU inline void StartPixelSample(Point2i p, int sampleIndex, int dimension = 0); PBRT_CPU_GPU inline Float Get1D(); PBRT_CPU_GPU inline Point2f Get2D(); PBRT_CPU_GPU inline Point2f GetPixel2D(); Sampler Clone(Allocator alloc = {}); std::string ToString() const; }; 独立采样器 # IndependentSampler用于生成伪随机样本, 可以在构造函数中设置随机数种子, 通常用于baseline来与其它采样器比较.\nIndependentSampler(int samplesPerPixel, int seed = 0) : samplesPerPixel(samplesPerPixel), seed(seed) {} 在设置初始采样位置时IndependentSampler会根据像素位置, 样本序号与当前维度决定初始偏移. rng是RNG类型的成员变量, 即随机数生成器(random number generator).\nvoid StartPixelSample(Point2i p, int sampleIndex, int dimension) { rng.SetSequence(Hash(p, seed)); rng.Advance(sampleIndex * 65536ull + dimension); } 分层采样器 # StratifiedSampler负责分层抽样, 会在每层的中心点添加均匀分布的抖动, 如前文所述这会将走样转为噪声.\n在高维下分层抽样会产生过多的样本, 例如包括镜头位置和时间时共有五个维度, 若分为四层则有\\(4^5 = 1024\\)个样本. 可以通过减少某些维度的层数来缓解这一问题, 同样这也会降低渲染质量. pbrt通过填充(padding)方法来解决这一问题, 即低维完整分层, 高层随机选择, 例如在像素位置与镜头位置上使用分层后的所有样本, 而时间则随机选择某一层的样本, 这可以较好的覆盖样本空间.\n每个维度上的样本都需要进行混排(shuffle), 以避免不同维度相同序号的样本的相关性. 在pbrt中这通过随机化当前层的序号来实现, 通过向PermutationElement输入当前序号, 样本数以及随机种子来实现. 这里维度是递增的, 因此需要为每个样本序号都执行StartPixelSample来生成下一组采样点.\nPBRT_CPU_GPU Float Get1D() { // Compute _stratum_ index for current pixel and dimension uint64_t hash = Hash(pixel, dimension, seed); int stratum = PermutationElement(sampleIndex, SamplesPerPixel(), hash); ++dimension; Float delta = jitter ? rng.Uniform\u0026lt;Float\u0026gt;() : 0.5f; return (stratum + delta) / SamplesPerPixel(); } 分层采样器的差异性为\\(O(\\frac{\\sqrt{d log\\ n}}{n^{\\frac{1}{2} + \\frac{1}{2d}}})\\), 不符合低差异性序列的要求.\nHalton采样器 # HaltonSampler通过Halton低差异性序列来在各个维度上生成分布良好的采样点.\nHammersley与Halton序列 # Hammersley与Halton序列都通过基反演生成, 即将整数数转化为\\(b\\)进制后映射到小数位上. van der Corput序列即为一维上递增序号的基2反演, 差异性为\\(O(\\frac{log\\ n}{n})\\).\n$$ \\begin{equation} \\begin{aligned} a \u0026amp;= \\sum_{i=1}^{n} d_i(a) b^{i - 1}\\\\ \\phi_b(a) \u0026amp;= \\sum_{i=1}^{n} d_i(a) b^{-i} \\end{aligned} \\end{equation} $$\n在每个维度上使用互质的基数即可得到Halton序列, 通常选用递增的质数, 差异性为\\(O(\\frac{(log\\ n)^d}{n})\\).\n$$ \\begin{equation} x_a = (\\phi_2(a), \\phi_3(a), \\phi_5(a),\\dots, \\phi_{p_d}(a)) \\end{equation} $$\n若样本数是确定的, 可以使用Hammersley序列, 同样需要基数互质, Hammersley的差异性比Halton略小.\n$$ \\begin{equation} x_a = (\\frac{a}{n}, \\phi_{b_1}(a), \\phi_{b_2}(a), \\dots, \\phi_{b_{d-1}}(a)) \\end{equation} $$\npbrt通过RadicalInverse计算基反演, 同样也支持其逆过程.\n// Low Discrepancy Inline Functions PBRT_CPU_GPU inline Float RadicalInverse(int baseIndex, uint64_t a) { unsigned int base = Primes[baseIndex]; // We have to stop once reversedDigits is \u0026gt;= limit since otherwise the // next digit of |a| may cause reversedDigits to overflow. uint64_t limit = ~0ull / base - base; Float invBase = (Float)1 / (Float)base, invBaseM = 1; uint64_t reversedDigits = 0; while (a \u0026amp;\u0026amp; reversedDigits \u0026lt; limit) { // Extract least significant digit from _a_ and update _reversedDigits_ uint64_t next = a / base; uint64_t digit = a - next * base; reversedDigits = reversedDigits * base + digit; invBaseM *= invBase; a = next; } return std::min(reversedDigits * invBaseM, OneMinusEpsilon); } PBRT_CPU_GPU inline uint64_t InverseRadicalInverse(uint64_t inverse, int base, int nDigits) { uint64_t index = 0; for (int i = 0; i \u0026lt; nDigits; ++i) { uint64_t digit = inverse % base; inverse /= base; index = index * base + digit; } return index; } 扰动随机化 # 确定性序列使得方差无法被估计, 且Halton序列在高维下会呈现一定的规则, 不利于收敛. 通过对采样点的每一位进行扰动可以解决这一问题, 这种情况下基反演之前的每一位都需要被考虑, 原本对于较小的数高位上的0是可以省略的, 且每一位都需要采用不同的扰动, 否则扰动前后的数仍然具有相似的特征.\npbrt通过DigitPermutation实现数位的扰动, 在构造函数中计算出需要的位数以及所有扰动结果, 为了节省空间采用uint16_t存储扰动结果. 若1减去当前位的最大值仍为1, 则后续位的计算已经小于最高精度, 不需要再计算. pbrt的PermutationElement采用伪随机.\nDigitPermutation(int base, uint32_t seed, Allocator alloc) : base(base) { CHECK_LT(base, 65536); // uint16_t // Compute number of digits needed for _base_ nDigits = 0; Float invBase = (Float)1 / (Float)base, invBaseM = 1; while (1 - (base - 1) * invBaseM \u0026lt; 1) { ++nDigits; invBaseM *= invBase; } permutations = alloc.allocate_object\u0026lt;uint16_t\u0026gt;(nDigits * base); // Compute random permutations for all digits for (int digitIndex = 0; digitIndex \u0026lt; nDigits; ++digitIndex) { uint64_t dseed = Hash(base, digitIndex, seed); for (int digitValue = 0; digitValue \u0026lt; base; ++digitValue) { int index = digitIndex * base + digitValue; permutations[index] = PermutationElement(digitValue, base, dseed); } } } Owen扰动通过考虑当前处理的位之前的所有位上的数字来实现更优的扰动, 这通过将之前位的扰动结果加入到Hash中来实现.\nPBRT_CPU_GPU inline Float OwenScrambledRadicalInverse(int baseIndex, uint64_t a, uint32_t hash) { unsigned int base = Primes[baseIndex]; // We have to stop once reversedDigits is \u0026gt;= limit since otherwise the // next digit of |a| may cause reversedDigits to overflow. uint64_t limit = ~0ull / base - base; Float invBase = (Float)1 / (Float)base, invBaseM = 1; uint64_t reversedDigits = 0; int digitIndex = 0; while (1 - invBaseM \u0026lt; 1 \u0026amp;\u0026amp; reversedDigits \u0026lt; limit) { // Compute Owen-scrambled digit for _digitIndex_ uint64_t next = a / base; int digitValue = a - next * base; uint32_t digitHash = MixBits(hash ^ reversedDigits); digitValue = PermutationElement(digitValue, base, digitHash); reversedDigits = reversedDigits * base + digitValue; invBaseM *= invBase; ++digitIndex; a = next; } return std::min(invBaseM * reversedDigits, OneMinusEpsilon); } Halton采样器实现 # Halton采样器会根据当前采样点编号的基反演结果的缩放取整确定其所位于的像素, 然后在对基反演结果进行扰动, 这使得相邻像素之间的样本不会相距过近. pbrt中缩放的最大值是128, 所以只保证图像某个区域内点不会过于集中, 同时也防止过大的缩放导致的浮点精度问题. 缩放值是基数的幂, 这使得缩放与位的左移保持一致.\nHaltonSampler::HaltonSampler(int samplesPerPixel, Point2i fullRes, RandomizeStrategy randomize, int seed, Allocator alloc) : samplesPerPixel(samplesPerPixel), randomize(randomize) { if (randomize == RandomizeStrategy::PermuteDigits) digitPermutations = ComputeRadicalInversePermutations(seed, alloc); // Find radical inverse base scales and exponents that cover sampling area for (int i = 0; i \u0026lt; 2; ++i) { int base = (i == 0) ? 2 : 3; int scale = 1, exp = 0; while (scale \u0026lt; std::min(fullRes[i], MaxHaltonResolution)) { scale *= base; ++exp; } baseScales[i] = scale; baseExponents[i] = exp; } // Compute multiplicative inverses for _baseScales_ multInverse[0] = multiplicativeInverse(baseScales[1], baseScales[0]); multInverse[1] = multiplicativeInverse(baseScales[0], baseScales[1]); } 可以通过计算像素的InverseRadicalInverse获取当前像素对应的采样点序号, 令计算结果为\\((x_r, y_r)\\), 二维Halton下\\((x, y)\\)上的缩放分别为\\((2^j, 3^k)\\), 只要序号i满足\\(x_r \\equiv i \\pmod {2^j}\\)和\\(y_r \\equiv i \\pmod {3^k}\\)即可, 这里构成了一个一元线性同余方程, 可以通过中国剩余定理求解. 此时可以实现StartPixelSample.\nPBRT_CPU_GPU void StartPixelSample(Point2i p, int sampleIndex, int dim) { haltonIndex = 0; int sampleStride = baseScales[0] * baseScales[1]; // Compute Halton sample index for first sample in pixel _p_ if (sampleStride \u0026gt; 1) { Point2i pm(Mod(p[0], MaxHaltonResolution), Mod(p[1], MaxHaltonResolution)); for (int i = 0; i \u0026lt; 2; ++i) { uint64_t dimOffset = (i == 0) ? InverseRadicalInverse(pm[i], 2, baseExponents[i]) : InverseRadicalInverse(pm[i], 3, baseExponents[i]); haltonIndex += dimOffset * (sampleStride / baseScales[i]) * multInverse[i]; } haltonIndex %= sampleStride; } haltonIndex += sampleIndex * sampleStride; dimension = std::max(2, dim); } 效果求解 # Owen扰动后的Halton采样器的PSD与一维抖动采样的PSD类似, 低频接近0, 高频接近1. 未随机化的Halton采样器则在高频上具有较大的方差, 某些高频点的功率较大, 这会造成走样. 随机扰动的PSD则介于二者之间.\nSobol\u0026rsquo;采样器 # HaltonSampler需要用到除法来生成采样点, 在大部分处理器上这是最慢的操作. Sobol\u0026rsquo;序列完全通过基2反演生成, 在计算机上具有更高的效率. Sobol\u0026rsquo;将基反演的过程矩阵化, 若为单位矩阵则与基反演的结果是相同的. $$ \\begin{equation} \\begin{aligned} x_a = \\begin{bmatrix} b^{-1} \u0026amp; b^{-2} \u0026amp; \\cdots \u0026amp; b^{-n} \\end{bmatrix} \\begin{bmatrix} c_{1,1} \u0026amp; c_{1,2} \u0026amp; \\cdots \u0026amp; c_{1,n}\\\\ c_{2,1} \u0026amp; \\ddots \u0026amp; \u0026amp; c_{2,n}\\\\ \\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; \\vdots\\\\ c_{n,1} \u0026amp; \\cdots \u0026amp; \\cdots \u0026amp; c_{n,n} \\end{bmatrix} \\begin{bmatrix} d_1(a)\\\\ d_2(a)\\\\ \\vdots\\\\ d_n(a) \\end{bmatrix} \\end{aligned} \\end{equation} $$\n本节中的Sobol‘序列\\(b=2\\),\\(n=32\\), 此时矩阵中每一项都为0或1, 每列可以用uint32_t来表示, 最终转换结果相当于把\\(a\\)为1的位对应的列相加, 这可以通过异或实现. 由于基反演的特性, 列在存储时会按照逆序存储. pbrt不讨论Sobol‘矩阵的生成.\nPBRT_CPU_GPU inline uint32_t MultiplyGenerator(pstd::span\u0026lt;const uint32_t\u0026gt; C, uint32_t a) { uint32_t v = 0; for (int i = 0; a != 0; ++i, a \u0026gt;\u0026gt;= 1) if (a \u0026amp; 1) v ^= C[i]; return v; } 元素区间的分层 # 对于pbrt采用的前两个维度的Sobol\u0026rsquo;序列, 任意\\(2^{l_1 + l_2}\\)个采样点都分层分布在如下的区间中, 其中\\(a_i = 0,1,2,3,\\dots,2^{l_i - 1}\\).\n$$ \\begin{equation} E = \\left\\lbrace \\left[ \\frac{a_1}{2^{l_1}}, \\frac{a_1 + 1}{2^{l_1}} \\right), \\left[ \\frac{a_2}{2^{l_2}}, \\frac{a_2 + 1}{2^{l_2}} \\right) \\right\\rbrace \\end{equation} $$\n随机化与扰动 # 扰动过程同样可以采用二进制计算来加速, pbrt通过functor使用随机化类的对象.\n最简单的NoRandomizer不做任何扰动.\nstruct NoRandomizer { uint32_t operator()(uint32_t v) const { return v; } }; BinaryPermuteScrambler通过与某个整数异或实现扰动.\nstruct BinaryPermuteScrambler { BinaryPermuteScrambler(uint32_t perm) : permutation(perm) {} uint32_t operator()(uint32_t v) const { return permutation ^ v; } uint32_t permutation; }; Sobol\u0026rsquo;同样可以采用二进制话的Owen扰动, pbrt中定义在OwenScrambler中, 翻转后的第\\(n - i\\)位是否反转由高\\(i - 1\\)位生成的随机数决定. 由于\\(n-1\\)位之前没有其它高位, pbrt通过种子的第一位来判断是否反转\nstruct OwenScrambler { PBRT_CPU_GPU OwenScrambler(uint32_t seed) : seed(seed) {} // OwenScrambler Public Methods PBRT_CPU_GPU uint32_t operator()(uint32_t v) const { if (seed \u0026amp; 1) v ^= 1u \u0026lt;\u0026lt; 31; for (int b = 1; b \u0026lt; 32; ++b) { // Apply Owen scrambling to binary digit _b_ in _v_ uint32_t mask = (~0u) \u0026lt;\u0026lt; (32 - b); if ((uint32_t)MixBits((v \u0026amp; mask) ^ seed) \u0026amp; (1u \u0026lt;\u0026lt; b)) v ^= 1u \u0026lt;\u0026lt; (31 - b); } return v; } uint32_t seed; }; 这一过程可以进一步二进制化, pbrt实现在FastOwenSampler中.\nstruct FastOwenScrambler { PBRT_CPU_GPU FastOwenScrambler(uint32_t seed) : seed(seed) {} // FastOwenScrambler Public Methods PBRT_CPU_GPU uint32_t operator()(uint32_t v) const { v = ReverseBits32(v); v ^= v * 0x3d20adea; v += seed; v *= (seed \u0026gt;\u0026gt; 16) | 1; v ^= v * 0x05526c56; v ^= v * 0x53a22864; return ReverseBits32(v); } uint32_t seed; }; 样本生成 # 由于随机类都实现了functor, 这里采用泛型.\ntemplate \u0026lt;typename R\u0026gt; PBRT_CPU_GPU inline Float SobolSample(int64_t a, int dimension, R randomizer) { DCHECK_LT(dimension, NSobolDimensions); DCHECK(a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; (1ull \u0026lt;\u0026lt; SobolMatrixSize)); // Compute initial Sobol\\+$\u0026#39;$ sample _v_ using generator matrices uint32_t v = 0; for (int i = dimension * SobolMatrixSize; a != 0; a \u0026gt;\u0026gt;= 1, i++) if (a \u0026amp; 1) v ^= SobolMatrices32[i]; // Randomize Sobol\\+$\u0026#39;$ sample and return floating-point value v = randomizer(v); return std::min(v * 0x1p-32f, FloatOneMinusEpsilon); } 全局Sobol\u0026rsquo;采样器 # SobolSampler的缩放通过可以覆盖屏幕的最小的2的幂来确定, 即长边的2底对数. 对高位与像素坐标相同的Sobol\u0026rsquo;变换结果执行逆变换即可得到样本序号, 这可以通过矩阵的逆变换实现, pbrt实现在SobolIntervalToIndex中(这里没有解释代码的原理, 没太看懂).\nPBRT_CPU_GPU inline uint64_t SobolIntervalToIndex(uint32_t m, uint64_t frame, Point2i p) { if (m == 0) return frame; const uint32_t m2 = m \u0026lt;\u0026lt; 1; uint64_t index = uint64_t(frame) \u0026lt;\u0026lt; m2; uint64_t delta = 0; for (int c = 0; frame; frame \u0026gt;\u0026gt;= 1, ++c) if (frame \u0026amp; 1) // Add flipped column m + c + 1. delta ^= VdCSobolMatrices[m - 1][c]; // flipped b uint64_t b = (((uint64_t)((uint32_t)p.x) \u0026lt;\u0026lt; m) | ((uint32_t)p.y)) ^ delta; for (int c = 0; b; b \u0026gt;\u0026gt;= 1, ++c) if (b \u0026amp; 1) // Add column 2 * m - c. index ^= VdCSobolMatricesInv[m - 1][c]; return index; } 填充Sobol\u0026rsquo;采样器 # SobolSampler生成的多维样本在二维上的投影可能不具有良好的分布, PaddedSobolSampler通过混排Sobol\u0026rsquo;序列实现, 不会进行缩放等操作.\nPBRT_CPU_GPU Float Get1D() { // Get permuted index for current pixel sample uint64_t hash = Hash(pixel, dimension, seed); int index = PermutationElement(sampleIndex, samplesPerPixel, hash); int dim = dimension++; // Return randomized 1D van der Corput sample for dimension _dim_ return SampleDimension(0, index, hash \u0026gt;\u0026gt; 32); } 蓝噪声Sobol\u0026rsquo;采样器 # ZSobolSampler是pbrt的默认采样器, 它会在PaddedSobolSampler的混排过程中遵循蓝噪声分布, 使得更多的误差分布在高频中. 这不会改变MSE, 但是对于人类视觉可以取得更优的效果.\n相邻的二次幂个Sobol采样点具有良好的分层, 如果通过当前像素的Morton码决定使用的采样点序号, 那么在相邻像素上可以取得较优的分布. 直接采用Morton码会导致渲染误差呈现结构化特征, 可以通过对每4个相邻的Morton码进行混排来实现扰动. 对于像素内部的采样点, pbrt会左移像素对应的Morton码, 然后将低位设置为像素内部采样点的序号, 这使得内部序号也参与随机扰动的过程.\nPBRT_CPU_GPU void StartPixelSample(Point2i p, int index, int dim) { dimension = dim; mortonIndex = (EncodeMorton2(p.x, p.y) \u0026lt;\u0026lt; log2SamplesPerPixel) | index; } pbrt对样本序号的扰动是每4个为一组的, 类似于Owen扰动这里会将已经生成的高位扰动结果添加到扰动过程中. 对于像素内部样本数量为2的幂而非4的幂的情况, 最后一位会单组作为一组来执行扰动, 此时只需要执行异或.\nPBRT_CPU_GPU uint64_t GetSampleIndex() const { // Define the full set of 4-way permutations in _permutations_ static const uint8_t permutations[24][4] = { {0, 1, 2, 3}, {0, 1, 3, 2}, {0, 2, 1, 3}, {0, 2, 3, 1}, // Define remaining 20 4-way permutations {0, 3, 2, 1}, {0, 3, 1, 2}, {1, 0, 2, 3}, {1, 0, 3, 2}, {1, 2, 0, 3}, {1, 2, 3, 0}, {1, 3, 2, 0}, {1, 3, 0, 2}, {2, 1, 0, 3}, {2, 1, 3, 0}, {2, 0, 1, 3}, {2, 0, 3, 1}, {2, 3, 0, 1}, {2, 3, 1, 0}, {3, 1, 2, 0}, {3, 1, 0, 2}, {3, 2, 1, 0}, {3, 2, 0, 1}, {3, 0, 2, 1}, {3, 0, 1, 2} }; uint64_t sampleIndex = 0; // Apply random permutations to full base-4 digits bool pow2Samples = log2SamplesPerPixel \u0026amp; 1; int lastDigit = pow2Samples ? 1 : 0; for (int i = nBase4Digits - 1; i \u0026gt;= lastDigit; --i) { // Randomly permute $i$th base-4 digit in _mortonIndex_ int digitShift = 2 * i - (pow2Samples ? 1 : 0); int digit = (mortonIndex \u0026gt;\u0026gt; digitShift) \u0026amp; 3; // Choose permutation _p_ to use for _digit_ uint64_t higherDigits = mortonIndex \u0026gt;\u0026gt; (digitShift + 2); int p = (MixBits(higherDigits ^ (0x55555555u * dimension)) \u0026gt;\u0026gt; 24) % 24; digit = permutations[p][digit]; sampleIndex |= uint64_t(digit) \u0026lt;\u0026lt; digitShift; } // Handle power-of-2 (but not 4) sample count if (pow2Samples) { int digit = mortonIndex \u0026amp; 1; sampleIndex |= digit ^ (MixBits((mortonIndex \u0026gt;\u0026gt; 1) ^ (0x55555555u * dimension)) \u0026amp; 1); } return sampleIndex; } 效果求解 # Owen采样后的Sobol\u0026rsquo;采样器可以取得较好的PSD, 同时适合计算机执行的二进制操作也大大提高了采样效率.\n图像重建 # 理想采样在实践中几乎是不可能的, 而在渲染任务中理想的\\(\\text{sinc}\\)滤波器也会导致滤波结果的震荡, pbrt所实现的滤波器都致力于尽量减小误差.\n滤波器接口 # 滤波器需要实现Filter接口. Radius返回滤波器的半径, 超过半径时权重为0, 滤波器在\\(x\\), \\(y\\)轴上的半径可能是不同的, 但都是关于原点对称的. Evaluate返回坐标点对应的权重. Integral返回当前半径下的积分值, 由于渲染具有归一化的过程, 这里不保证积分值为1. Sample用于实现重要性抽样, 返回均匀分布值对应的坐标以及权重与pdf的比值, 由于部分滤波器是可以作为概率分布直接采样的, 此时返回的比值为1.\nclass Filter : public TaggedPointer\u0026lt;BoxFilter, GaussianFilter, MitchellFilter, LanczosSincFilter, TriangleFilter\u0026gt; { public: // Filter Interface using TaggedPointer::TaggedPointer; static Filter Create(const std::string \u0026amp;name, const ParameterDictionary \u0026amp;parameters, const FileLoc *loc, Allocator alloc); PBRT_CPU_GPU inline Vector2f Radius() const; PBRT_CPU_GPU inline Float Evaluate(Point2f p) const; PBRT_CPU_GPU inline Float Integral() const; PBRT_CPU_GPU inline FilterSample Sample(Point2f u) const; std::string ToString() const; }; 滤波器采样器 # FilterSampler主要负责重要性抽样的细节, 不具有解析形式逆变换的滤波器会通过分段函数查表的形式采样, pbrt使用的采样率为每单位长度32个样本. 由于对称的特性, 只需要对第一象限进行采样即可.\nFilterSampler::FilterSampler(Filter filter, Allocator alloc) : domain(Point2f(-filter.Radius()), Point2f(filter.Radius())), f(int(32 * filter.Radius().x), int(32 * filter.Radius().y), alloc), distrib(alloc) { // Tabularize unnormalized filter function in _f_ for (int y = 0; y \u0026lt; f.YSize(); ++y) for (int x = 0; x \u0026lt; f.XSize(); ++x) { Point2f p = domain.Lerp(Point2f((x + 0.5f) / f.XSize(), (y + 0.5f) / f.YSize())); f(x, y) = filter.Evaluate(p); } // Compute sampling distribution for filter distrib = PiecewiseConstant2D(f, domain, alloc); } 为了避免权重产生过大的方差, FilterSampler返回的权重是分段函数而非滤波函数本身的值与pdf的比值, 这使得比值为常数.\nPBRT_CPU_GPU FilterSample Sample(Point2f u) const { Float pdf; Point2i pi; Point2f p = distrib.Sample(u, \u0026amp;pdf, \u0026amp;pi); return FilterSample{p, f[pi] / pdf}; } 一维分段函数 # pbrt支持在\\((0-1)\\)上均匀划分区间的分段函数重要性抽样, 可以通过自定义参数缩放采样结果, 其归一化因子, PDF以及CDF如下, PDF需要保证为正, 因此使用绝对值. 对于重要性抽样, 只需要找到\\(P(x_i) \\le U \\le P(x_{i+1})\\)并线性插值即可.\n$$ \\begin{equation} \\begin{aligned} c\u0026amp;=\\sum_{i=0}^{n-1}\\frac{|v_i|}{n}\\\\ p(x_i)\u0026amp;=\\frac{|v_i|}{c}\\\\ P(x_i)\u0026amp;= \\begin{cases} 0 \u0026amp; i=0\\\\ P(x_{i-1})+\\frac{|v_i|}{nc} \u0026amp; \\text{otherwise} \\end{cases} \\end{aligned} \\end{equation} $$\nPiecewiseConstant1D的构造函数如下. 对于积分和为\\(0\\)的情况, pbrt将其转为均匀分布, 在二维采样中这种情况很常见, 由于最终获取的权重为\\(0\\)转为均匀分布在统计上正确.\nPiecewiseConstant1D(pstd::span\u0026lt;const Float\u0026gt; f, Float min, Float max, Allocator alloc = {}) : func(f.begin(), f.end(), alloc), cdf(f.size() + 1, alloc), min(min), max(max) { CHECK_GT(max, min); // Take absolute value of _func_ for (Float \u0026amp;f : func) f = std::abs(f); // Compute integral of step function at $x_i$ cdf[0] = 0; size_t n = f.size(); for (size_t i = 1; i \u0026lt; n + 1; ++i) { CHECK_GE(func[i - 1], 0); cdf[i] = cdf[i - 1] + func[i - 1] * (max - min) / n; } // Transform step function integral into CDF funcInt = cdf[n]; if (funcInt == 0) for (size_t i = 1; i \u0026lt; n + 1; ++i) cdf[i] = Float(i) / Float(n); else for (size_t i = 1; i \u0026lt; n + 1; ++i) cdf[i] /= funcInt; } PiecewiseConstant1D的采样实现如下, FindInterval实现二分搜索, min和max是用户设置的缩放系数.\nPBRT_CPU_GPU Float Sample(Float u, Float *pdf = nullptr, int *offset = nullptr) const { // Find surrounding CDF segments and _offset_ int o = FindInterval((int)cdf.size(), [\u0026amp;](int index) { return cdf[index] \u0026lt;= u; }); if (offset) *offset = o; // Compute offset along CDF segment Float du = u - cdf[o]; if (cdf[o + 1] - cdf[o] \u0026gt; 0) du /= cdf[o + 1] - cdf[o]; DCHECK(!IsNaN(du)); // Compute PDF for sampled offset if (pdf) *pdf = (funcInt \u0026gt; 0) ? func[o] / funcInt : 0; // Return $x$ corresponding to sample return Lerp((o + du) / size(), min, max); } 二维分段函数 # 基于一维分段函数, pbrt支持\\(n_u \\times n_v\\)上的二维分段函数重要性抽样.\nPiecewiseConstant2D的构造函数如下, 计算并存储每行的积分和.\nPiecewiseConstant2D(pstd::span\u0026lt;const Float\u0026gt; func, int nu, int nv, Bounds2f domain, Allocator alloc = {}) : domain(domain), pConditionalV(alloc), pMarginal(alloc) { CHECK_EQ(func.size(), (size_t)nu * (size_t)nv); pConditionalV.reserve(nv); for (int v = 0; v \u0026lt; nv; ++v) // Compute conditional sampling distribution for $\\tilde{v}$ pConditionalV.emplace_back(func.subspan(v * nu, nu), domain.pMin[0], domain.pMax[0], alloc); // Compute marginal sampling distribution $p[\\tilde{v}]$ pstd::vector\u0026lt;Float\u0026gt; marginalFunc; marginalFunc.reserve(nv); for (int v = 0; v \u0026lt; nv; ++v) marginalFunc.push_back(pConditionalV[v].Integral()); pMarginal = PiecewiseConstant1D(marginalFunc, domain.pMin[1], domain.pMax[1], alloc); } PiecewiseConstant2D的采样函数如下, 现在列上做一维重要性抽样, 然后再采样对应行.\nPoint2f Sample(Point2f u, Float *pdf = nullptr, Point2i *offset = nullptr) const { Float pdfs[2]; Point2i uv; Float d1 = pMarginal.Sample(u[1], \u0026amp;pdfs[1], \u0026amp;uv[1]); Float d0 = pConditionalV[uv[1]].Sample(u[0], \u0026amp;pdfs[0], \u0026amp;uv[0]); if (pdf) *pdf = pdfs[0] * pdfs[1]; if (offset) *offset = uv; return Point2f(d0, d1); } 窗口二维分段函数 # WindowedPiecewiseConstant2D支持采样二维函数的部分矩形区域, 主要用于实现门户光源. pbrt实现了SummedAreaTable来存储二维分段函数某个位置到左下角的积分和, 这加速来计算任意矩形区域的积分和.\n对于浮点数的SummedAreaTable, pbrt通过对相邻整数对应的积分和做双线性插值实现.\nPBRT_CPU_GPU Float Lookup(Float x, Float y) const { // Rescale $(x,y)$ to table resolution and compute integer coordinates x *= sum.XSize(); y *= sum.YSize(); int x0 = (int)x, y0 = (int)y; // Bilinearly interpolate between surrounding table values Float v00 = LookupInt(x0, y0), v10 = LookupInt(x0 + 1, y0); Float v01 = LookupInt(x0, y0 + 1), v11 = LookupInt(x0 + 1, y0 + 1); Float dx = x - int(x), dy = y - int(y); return (1 - dx) * (1 - dy) * v00 + (1 - dx) * dy * v01 + dx * (1 - dy) * v10 + dx * dy * v11; } WindowedPiecewiseConstant2D的采样函数如下, Px用于返回窗口区域归一化后到某行的CDF. SampleBisection实现二分查找, 最后一个参数为底层PiecewiseConstant2D的行数量, 当搜索区间小于一行时进行插值并返回结果. 由于矩形长或宽为\\(0\\)时无法采样, pbrt将窗口宽度缩小到当前行, 在列上再次二分查找, 实际上缩小后的行可能略微超出原本的矩形区域了.\nPBRT_CPU_GPU pstd::optional\u0026lt;Point2f\u0026gt; Sample(Point2f u, Bounds2f b, Float *pdf) const { // Handle zero-valued function for windowed sampling if (sat.Integral(b) == 0) return {}; // Define lambda function _Px_ for marginal cumulative distribution Float bInt = sat.Integral(b); auto Px = [\u0026amp;, this](Float x) -\u0026gt; Float { Bounds2f bx = b; bx.pMax.x = x; return sat.Integral(bx) / bInt; }; // Sample marginal windowed function in $x$ Point2f p; p.x = SampleBisection(Px, u[0], b.pMin.x, b.pMax.x, func.XSize()); // Sample conditional windowed function in $y$ // Compute 2D bounds _bCond_ for conditional sampling int nx = func.XSize(); Bounds2f bCond(Point2f(pstd::floor(p.x * nx) / nx, b.pMin.y), Point2f(pstd::ceil(p.x * nx) / nx, b.pMax.y)); if (bCond.pMin.x == bCond.pMax.x) bCond.pMax.x += 1.f / nx; if (sat.Integral(bCond) == 0) return {}; // Define lambda function for conditional distribution and sample $y$ Float condIntegral = sat.Integral(bCond); auto Py = [\u0026amp;, this](Float y) -\u0026gt; Float { Bounds2f by = bCond; by.pMax.y = y; return sat.Integral(by) / condIntegral; }; p.y = SampleBisection(Py, u[1], b.pMin.y, b.pMax.y, func.YSize()); // Compute PDF and return point sampled from windowed function *pdf = Eval(p) / bInt; return p; } 盒形滤波器 # 盒形滤波器对半径内的采样点都具有相同的权重, 在频域下会导致高频信息泄漏至低频, 导致走样. 盒形滤波器本身就是均匀分布, 因此Sample方法只需要对传入的均匀分布样本进行缩放.\nPBRT_CPU_GPU FilterSample Sample(Point2f u) const { Point2f p(Lerp(u[0], -radius.x, radius.x), Lerp(u[1], -radius.y, radius.y)); return {p, Float(1)}; } 三角形滤波器 # 三角形滤波器的权重在坐标轴上是线性减小的, pbrt中将滤波器的斜率设置为1, 半径为r时归一化形式如下.\n$$ \\begin{equation} \\begin{aligned} f(x) \u0026amp;= \\max(0, \\frac{1}{r} - \\frac{|x|}{r^2}) \\end{aligned} \\end{equation} $$\n二维上三角形滤波器是可分离的, 投影到\\(x=c\\)或\\(y=c\\)后仍为三角形.\nPBRT_CPU_GPU Float Evaluate(Point2f p) const { return std::max\u0026lt;Float\u0026gt;(0, radius.x - std::abs(p.x)) * std::max\u0026lt;Float\u0026gt;(0, radius.y - std::abs(p.y)); } 三角形函数在正负两侧分别为线性函数, 且已知采样到两侧概率相同, 因此分别执行之前章节介绍的线性函数重要性抽样即可. 由于三角形滤波器本身即为三角形分布, 返回权重为1.\nPBRT_CPU_GPU inline Float SampleTent(Float u, Float r) { if (SampleDiscrete({0.5f, 0.5f}, u, nullptr, \u0026amp;u) == 0) return -r + r * SampleLinear(u, 0, 1); else return r * SampleLinear(u, 1, 0); } 由于可分离的特性在重要性抽样时可以在不同的轴上分别采样.\nPBRT_CPU_GPU FilterSample Sample(Point2f u) const { return {Point2f(SampleTent(u[0], radius.x), SampleTent(u[1], radius.y)), Float(1)}; } Gaussian滤波器 # 由于滤波器只在半径内不为0, pbrt会减去半径处对应的Gaussian函数的值, 这也使得一般的Gaussian分布重要性抽样无法被采样, 需要使用FilterSampler. Gaussian滤波器通常会导致边缘的模糊.\n$$ \\begin{equation} \\begin{aligned} g(x,\\mu,\\sigma) \u0026amp;= \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\\\ f(x) \u0026amp;= \\begin{cases} g(x,0,\\sigma)-g(r,0,\\sigma) \u0026amp;|x|\u0026lt;r\\\\ 0 \u0026amp;\\text{otherwise} \\end{cases} \\end{aligned} \\end{equation} $$\nGaussian函数的CDF如下, 可以看出它不是可逆的.\n$$ \\begin{equation} \\begin{aligned} P(x,\\mu,\\sigma) \u0026amp;=\\int_{-\\infty}^x \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} dx\\\\ \u0026amp;=\\int_{-\\infty}^z \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{z^2}{2}} dz\\\\ \u0026amp;=\\int_{-\\infty}^0 \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{z^2}{2}} dz + \\int_0^z \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{z^2}{2}} dz\\\\ \u0026amp;=\\frac{1}{2} + \\int_0^z \\frac{1}{\\sqrt{\\pi}}e^{-\\frac{z^2}{2}} d\\frac{z}{\\sqrt{2}}\\\\ \u0026amp;=\\frac{1}{2}(1+\\text{erf}(\\frac{z}{\\sqrt{2}})) \\end{aligned} \\end{equation} $$\npbrt通过某种多项式来你和误差函数的逆函数, 以实现重要性抽样.\nPBRT_CPU_GPU Float SampleNormal(Float u, Float mu = 0, Float sigma = 1) { return mu + Sqrt2 * sigma * ErfInv(2 * u - 1); } Mitchell滤波器 # Mitchell滤波器致力于在振荡与模糊之间达成平衡, 这通过在滤波器中引入负值来实现, 负值部分较少会偏向模糊, 反之偏向振荡以及不合法的图像值. Mitchell滤波器的定义如下, 其中的参数\\(b\\)和\\(c\\)在原文中推荐保持\\(b+2c=1\\)的关系.\n$$ \\begin{equation} \\begin{aligned} f(x) = \\frac{1}{6} \\begin{cases} (12-9b-6c)|x|^3\\\\ +(-18+12b+6c)|x|^2+(6-2b) \u0026amp;|x|\u0026lt;1\\\\ (-b-6c)|x|^3+(6b+30c)|x|^2\\\\ +(-12b-48c)|x|+(8b+24c) \u0026amp;1\\le|x|\u0026lt;2\\\\ 0 \u0026amp;\\text{otherwise} \\end{cases} \\end{aligned} \\end{equation} $$\npbrt中会依据设定的半径来缩放坐标值, 通过半径缩放后的Mitchell滤波器的积分具有良好的解析形式.\nPBRT_CPU_GPU Float Evaluate(Point2f p) const { return Mitchell1D(2 * p.x / radius.x) * Mitchell1D(2 * p.y / radius.y); } PBRT_CPU_GPU Float Integral() const { return radius.x * radius.y / 4; } Lanczos滤波器 # Lanczos滤波器基于\\(\\text{sinc}\\)函数, 通过将\\(\\text{sinc}\\)函数与一个周期缩放后的\\(\\text{sinc}\\)函数相乘并截断实现. 缩放后的\\(\\text{sinc}\\)函数被称为窗口函数, 因此该滤波也叫窗口化\\(\\text{sinc}\\)滤波器. 与直接使用\\(\\text{sinc}\\)相比Lanczos滤波器具有更少的振荡. Lanczos滤波器的积分较难求解, pbrt通过Riemann和来估计.\n$$ \\begin{equation} \\begin{aligned} \\text{sinc}(x) \u0026amp;= \\frac{\\sin(\\pi x)}{\\pi x}\\\\ w(x) \u0026amp;= \\text{sinc}(\\frac{x}{\\tau})\\\\ f(x) \u0026amp;= \\begin{cases} \\text{sinc}(x)w(x) \u0026amp;|x|\\le \\tau\\\\ 0 \u0026amp;\\text{otherwise} \\end{cases} \\end{aligned} \\end{equation} $$\n","date":"2024 November 30","externalUrl":null,"permalink":"/render/1732940841429-pbrt-v4-episode-8/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. VIII: 图像重建","type":"render"},{"content":" 上一节的Shape类主要提供相交, 包围结构, 采样等功能, 这些与几何物体本身相关, pbrt通过Primitive接口来提供材质等特征. 通过Primitive的集合可以实现加速结构, pbrt实现了BVHAggregate与KdTreeAggregate. 本节只介绍在CPU上的实现, GPU上由于光追图形接口需要另一套实现.\n图元接口与几何图元 # Bounds用于构建加速结构, Intersect用于求交.\nclass Primitive : public TaggedPointer\u0026lt;SimplePrimitive, GeometricPrimitive, TransformedPrimitive, AnimatedPrimitive, BVHAggregate, KdTreeAggregate\u0026gt; { public: // Primitive Interface using TaggedPointer::TaggedPointer; Bounds3f Bounds() const; pstd::optional\u0026lt;ShapeIntersection\u0026gt; Intersect(const Ray \u0026amp;r, Float tMax = Infinity) const; bool IntersectP(const Ray \u0026amp;r, Float tMax = Infinity) const; }; 几何图元 # 几何图元内部保存对应的Shape以及材质与自发光属性, Bounds与Intersect直接通过调用Shape的接口实现.\nShape shape; Material material; Light areaLight; MediumInterface mediumInterface; FloatTexture alpha; 树叶等物体需要通过alpha test来决定相交是否有效, pbrt通过随机alpha test来实现, 将alpha作为概率值随机返回0或1, 若为0则重新求交. 为保证结果的确定性, pbrt通过HashFloat使得相同的光线产生相同的随机值.\n大部分物体不需要考虑alpha以及表面两侧的介质差异, pbrt提供了SimplePrimitive接口, 只存储Shape与Material.\n物体多实例与运动图元 # 对于大量重复物体多实例可以只存储一份几何数据, 有效节省存储资源. pbrt通过TransformedPrimitive实现, 内部存储一个Primitive以及额外的到渲染空间的变换. 对于运动物体, pbrt使用AnimatedPrimitive, 变换采用AnimatedTransform存储, 包围盒取物体运动范围的包围盒.\n聚合 # 线性的与所有图元求交带来的时间复杂度是显著的, 需要通过将多个图元聚合来减小求交的规模. 目前主要有两类主流方案, 物体细分由BVHAggregate实现, 空间细分由KdTreeAggregate实现. 聚合图元通过TransformedPrimitive或AnimatedPrimitive存储, 不考虑材质与光照.\n包围结构层级 # 包围结构层级(bounding volume hierarchies)即为BVH, pbrt使用以下几种分割方法, SAH具有最高的分割质量, HLBVH相对效率较高, 后两类效果较差, 主要用于比较.\nenum class SplitMethod { SAH, HLBVH, Middle, EqualCounts }; 包围结构层级构建 # BVH构建分为三步, 首先计算图元的包围信息存储在数组中, 其次根据分割方法构建二叉树, 每个节点存储一个或多个图元的引用, 最后将树压缩为更高效的无指针实现, 与在树的构建过程中压缩相比这种方法的实现更为简单.\nBVH中的图元通过BVHPrimitive存储, 内部存储其包围盒与在图元数列中的序号. 在构建完成后会生成orderedPrims, 保证同一个叶结点上的图元在内存中连续.\nsize_t primitiveIndex; Bounds3f bounds; pbrt通过标准库中的pmr::monotonic_buffer_resource分配BVH所需要的大内存, 与通用内存分配器相比可以减小10%的空间开销. 这个分配器不保证线程安全, pbrt通过ThreadLocal类实现.\nBVH节点通过BVHNode存储, 其中存储着子树所有图元的包围盒, 对于叶节点会存储第一个图元的序号与图元数量. 叶节点与中间节点通过后代指针是否为nullptr来区分. 在orderedPrims中的需要通过原子变量获取.\nBounds3f bounds; BVHBuildNode *children[2]; int splitAxis, firstPrimOffset, nPrimitives; pbrt选取包围盒长度最长的轴作为分割轴, 以此减小某个图元穿过被分割的两个包围盒的情况, 决定分割轴后根据分割方法将图元分成两组, 递归到子节点中继续分割.\nMiddle是最简单的分割方法, 判断包围盒中心在分割面的哪一侧即可, 利用std::partition可以快速实现. 分割后数据仍然在原有的容器中, std::partition返回的是第二组第一个元素的迭代器.\nauto midIter = std::partition( bvhPrimitives.begin(), bvhPrimitives.end(), [=](const BVHPrimitive \u0026amp;bp) { int b = nBuckets * centroidBounds.Offset(bp.Centroid())[dim]; if (b == nBuckets) b = nBuckets - 1; return b \u0026lt;= minCostSplitBucket; }); mid = midIter - bvhPrimitives.begin(); 对于无法分割为两组的情况, pbrt会回退到EqualCounts方法, 即通过std::nth_element使得位于中间的图元处在正确的位置上, 其余根据图元中心位置分为两组. std::nth_element内部采用部分快速排序, 由于不需要完全排序, 时间复杂度为\\(O(n)\\).\n表面面积启发式分割 # 前两种方法往往会得到不理想的分割结果导致较高的求交开销, 表面面积启发式分割(Surface Area Heuristic, SAH)是较优的分割方法.\n我们认为对于某个叶子节点它的所有图元都需要进行相交测试, 因此将某个节点分为\\(A\\), \\(B\\)两个子树后, 与所有图元计算相交的开销如下, \\(p\\)为与当前节点相交的光线与某个子树相交的概率, \\(t_{trav}\\)为遍历当前节点的开销.\n$$ \\begin{equation} c(A, B) = t_{\\text{trav}} + p_A \\sum_{i = 1}^{n_A} t_{\\text{isect}}(a_i) + p_B \\sum_{i = 1}^{n_B} t_{\\text{isect}}(b_i) \\end{equation} $$\nSAH会将分割轴均分为多个区域(或者说\u0026quot;桶\u0026quot;, bucket, 翻译过来有点怪\u0026hellip;), 根据包围盒中心在哪个区域中进行分组, 以区域边界作为备选分割面. pbrt将包围盒的面积与图元数量的乘积作为启发式开销, 选择最小的分割面使得两侧的聚合图元的启发式开销之和最小, 通过正向与逆向累加可以以\\(O(n)\\)的复杂度计算出结果.\n// Compute costs for splitting after each bucket constexpr int nSplits = nBuckets - 1; Float costs[nSplits] = {}; // Partially initialize _costs_ using a forward scan over splits int countBelow = 0; Bounds3f boundBelow; for (int i = 0; i \u0026lt; nSplits; ++i) { boundBelow = Union(boundBelow, buckets[i].bounds); countBelow += buckets[i].count; costs[i] += countBelow * boundBelow.SurfaceArea(); } // Finish initializing _costs_ using a backward scan over splits int countAbove = 0; Bounds3f boundAbove; for (int i = nSplits; i \u0026gt;= 1; --i) { boundAbove = Union(boundAbove, buckets[i].bounds); countAbove += buckets[i].count; costs[i - 1] += countAbove * boundAbove.SurfaceArea(); } // Find bucket to split at that minimizes SAH metric int minCostSplitBucket = -1; Float minCost = Infinity; for (int i = 0; i \u0026lt; nSplits; ++i) { // Compute cost for candidate split and update minimum if // necessary if (costs[i] \u0026lt; minCost) { minCost = costs[i]; minCostSplitBucket = i; } } pbrt认为当前节点遍历开销为0.5, 图元相交开销为1, 此时若为叶节点则开销为图元数量, 否则为0.5加上启发式开销除以所有图元的包围盒的面积. 遍历开销实际上是较大的, pbrt设置为0.5使得BVH树的深度不会过大.\n// Compute leaf cost and SAH split cost for chosen split Float leafCost = bvhPrimitives.size(); minCost = 1.f / 2.f + minCost / bounds.SurfaceArea(); 线性包围结构层级分割 # 线性包围结构层级分割即LBVH分割方法. 每个节点都计算SAH开销较大, 且不利于并行化. LBVH可以解决这些问题, 它通过Morton码对包围盒中心排序, 选取中间的图元进行分割. pbrt实现了层级线性包围结构层级(hierarchical linear bounding volume hierarchy, HLBVH), 自底向上构建BVH.\npbrt通过MortonPrimitive存储图元序号与对应的Morton码, \\(x\\), \\(y\\), \\(z\\)各占10位. 图元包围盒中心在当前节点的相对位置值域在\\([0,1]\\)中, 通过缩放\\(2^{10}\\)倍来获取Morton码. pbrt采用基数排序, 每次处理6位, 经过试验效率高于std::sort. 排序后的图元簇采用LBVHTreelet表示, 存储在mortonPrims中的序号与数量.\nstruct MortonPrimitive { int primitiveIndex; uint32_t mortonCode; }; struct LBVHTreelet { size_t startIndex, nPrimitives; BVHBuildNode *buildNodes; }; pbrt首先根据高12位进行图元分簇, 完成分簇后立即分配BVHBuildNode所需的空间, 即\\(2^n - 1\\)个节点. 由于每次并行处理的图元簇都具有相同的高位, 包围盒可以从中获取. 同时当前分割位与分割轴是相关的, 无需额外进行分割轴的选取, 处理到最后一位或图元数小于阈值时会创建叶节点. 叶子节点建立完成后即可开始创建中间节点, 由于所有节点已经按照Morton码排序, 创建过程中节省了许多划分与重排的开销. 各个高位对应的子树都处理完成后, 剩余节点仍然采用SAH构建\n加速树压缩 # pbrt在flattenBVH()中实现压缩, 压缩后的二叉树转为数组存储, 利用下标表达父子关系. 压缩后的节点存储为LinearBVHNode, 最终得到的数组指针存储在BVHAggregate中.\nstruct alignas(32) LinearBVHNode { Bounds3f bounds; union { int primitivesOffset; // leaf int secondChildOffset; // interior }; uint16_t nPrimitives; // 0 -\u0026gt; interior node uint8_t axis; // interior node: xyz }; 相交测试 # 相交测试时pbrt将需要访问的节点序号存储在nodesToVisit栈中, 由于访问的节点数量不会很多, pbrt用数组手工模拟.\nint toVisitOffset = 0, currentNodeIndex = 0; int nodesToVisit[64]; int nodesVisited = 0; ","date":"2024 November 19","externalUrl":null,"permalink":"/render/1731999189039-pbrt-v4-episode-7/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. VII: 图元与加速结构","type":"render"},{"content":" pbrt通过Shape抽象出光线相交, 包围盒等接口, 其余形状无关的功能由Primitive封装. 本章主要介绍Shape.\n基础接口 # 包围结构 # Shape中Bounds()接口返回包围盒, NormalBounds()返回法线方向的包围锥.\n光线-包围结构相交 # Bounds3\u0026lt;T\u0026gt;::IntersectP接口提供该功能. 光线与各个轴上的近平面与远平面相交, 三轴近平面上最大的\\(t\\)即为\\(t_{near}\\), 同理可得\\(t_{far}\\), 若\\(t_{far} \u0026lt; t_{near}\\)则与包围盒不相交. 为提高效率, pbrt支持传入光线方向倒数与表示各个轴方向是否为负的向量, 避免重复计算. 对于NaN, 由于任何NaN参与的逻辑运算都为否, 这里不需要特殊处理.\n相交测试 # Shape的派生类需要实现Intersect接口, 传入的光线位于渲染空间, 返回ShapeIntersection, 代表最近的相交点. 同样的派生类实现IntersectP用于判断是否相交而非具体相交细节.\n// ShapeIntersection Definition struct ShapeIntersection { SurfaceInteraction intr; Float tHit; std::string ToString() const; }; 相交坐标空间 # 大部分形状的相交在渲染空间中计算, 部分形状需要在本地空间表示, 例如球. 变换不会影响相交的\\(t\\).\n面判断 # 光栅化中通常只考虑物体的正面, pbrt中为避免光追失效正反面都需要判断相交.\n面积 # 派生类需要实现Area接口来提供面积信息, 用于将Shape作为面积光源.\n采样 # 采样返回当前采样点的几何信息.\n// ShapeSample Definition struct ShapeSample { Interaction intr; Float pdf; std::string ToString() const; }; Shape的采样可以采用类似于二维概率密度函数的形式, 调用者需要保证传入的坐标在形状范围内.\nPBRT_CPU_GPU inline pstd::optional\u0026lt;ShapeSample\u0026gt; Sample(Point2f u) const; PBRT_CPU_GPU inline Float PDF(const Interaction \u0026amp;) const; 同样也可以提供参考点, 例如将Shape作为面积光照, 某点需要在Shape上采样来计算辐射亮度, 此时提供参考点或立体角的采样会更加合适. 采样的实现可能需要判断当前立体角对应的光线是否相交.\nPBRT_CPU_GPU inline pstd::optional\u0026lt;ShapeSample\u0026gt; Sample(const ShapeSampleContext \u0026amp;ctx, Point2f u) const; PBRT_CPU_GPU inline Float PDF(const ShapeSampleContext \u0026amp;ctx, Vector3f wi) const; 球体 # 球面坐标可以转化为uv方程以用于纹理映射, 也可以用于表示不完整的球.\n$$ \\begin{equation} \\begin{aligned} \\phi \u0026amp;= u \\phi_{\\max}\\\\ \\theta \u0026amp;= \\theta_{\\min} + v(\\theta_{\\max} - \\theta_{\\min}) \\end{aligned} \\end{equation} $$\n由于球体使用本地空间, 构造函数需要传入变换. pbrt没有使用添加动画的变换, 动画由Primitive处理.\n包围结构 # 由于球体可能是不完整的, pbrt会计算出对应的\\(z_{\\min}\\)和\\(z_{\\max}\\), x轴与y轴不做额外计算.\nPBRT_CPU_GPU Bounds3f Sphere::Bounds() const { return (*renderFromObject)( Bounds3f(Point3f(-radius, -radius, zMin), Point3f(radius, radius, zMax))); } 表面面积 # 定义在\\([a,b]\\)上的曲线\\(f(x)\\)绕x轴形成的形状的表面积可以表示为下式.\n$$ \\begin{equation} \\begin{aligned} A \u0026amp;= \\phi_{\\max} \\int_a^b f(x) ds\\\\ \u0026amp;= \\phi_{\\max} \\int_a^b f(x) \\sqrt{dx^2 + dy^2}\\\\ \u0026amp;= \\phi_{\\max} \\int_a^b f(x) \\sqrt{1 + f\u0026rsquo;^2(x)} dx \\end{aligned} \\end{equation} $$\n将球面视为绕z轴旋转, 可以得到下式.\n$$ \\begin{equation} \\begin{aligned} A \u0026amp;= \\phi_{\\max} \\int_{z_{\\min}}^{z_{\\max}} \\sqrt{r^2 - z^2} \\sqrt{1 + \\frac{z^2}{r^2 - z^2}} dz\\\\ \u0026amp;= \\phi_{\\max} r (z_{\\max} - z{\\min}) \\end{aligned} \\end{equation} $$\n相交测试 # 球体首先执行BasicIntersect, 获取本地空间下的相交结果, 返回QuadricIntersection, 别的二次曲面形状也会使用这个结构体. 之后再执行InteractionFromIntersection, 这样分离使得IntersectP只需要执行BasicIntersect, 且在GPU上可以先对所有可相交的形状执行BasicIntersect, 找到最近点后在执行InteractionFromIntersection.\nstruct QuadricIntersection { Float tHit; Point3f pObj; Float phi; }; 通过相交点计算出uv后pbrt会计算偏导数, 空间位置的偏导数根据球面坐标的定义计算, 法线的偏导数通过微分几何中常用的Weingarten方程计算.\n上述过程执行完成后即可构造SurfaceInteraction.\nbool flipNormal = reverseOrientation ^ transformSwapsHandedness; Vector3f woObject = (*objectFromRender)(wo); return (*renderFromObject)(SurfaceInteraction(Point3fi(pHit, pError), Point2f(u, v), woObject, dpdu, dpdv, dndu, dndv, time, flipNormal)); 表面采样 # 本地空间下的球面均匀采样较为简单, pdf为面积的倒数. 对于有参考点的采样, pbrt会将采样点朝向球心偏移, 以避免位于球面附近的点因为浮点误差而位于错误的一侧, 同时pdf会从面积微分转为立体角微分.\nPoint3f pCenter = (*renderFromObject)(Point3f(0, 0, 0)); Point3f pOrigin = ctx.OffsetRayOrigin(pCenter); 球外的参考点会与球面形成一个可见锥体, 与参考点到球心形成的中心向量可以形成的最大角度见下式. 此时可以在可见锥体内均匀采样立体角方向, 获取与中心向量的夹角\\(\\theta\\)和绕中心向量的旋转角\\(\\omega\\)即可. pbrt在\\([\\cos\\theta_{max}, 1]\\)这一范围内采样.\n$$ \\begin{equation} \\theta_{\\max} = \\text{arcsin}(\\frac{r}{|p-p_c|}) \\end{equation} $$\n对于\\(\\theta_{max}\\)较小的情况, 由\\(\\cos\\theta\\)计算\\(\\sin\\theta\\)会导致浮点误差, 因为\\(\\cos\\theta\\)接近1, 1附近的浮点精度与0附近相比是不够的. 在角度较小的情况下根据\\(\\sin\\theta\\)的一阶泰勒展开可以得到\\(\\sin\\theta \\approx \\theta\\), 此时可以得到足够的精度. 采样完成后可以计算得到交点.\nif (sin2ThetaMax \u0026lt; 0.00068523f /* sin^2(1.5 deg) */) { // Compute cone sample via Taylor series expansion for small angles sin2Theta = sin2ThetaMax * u[0]; cosTheta = std::sqrt(1 - sin2Theta); oneMinusCosThetaMax = sin2ThetaMax / 2; } 对于pdf, 首先需要满足如下的关系.\n$$ \\begin{equation} \\begin{aligned} 1 \u0026amp;= \\int_{\\Phi} p(\\omega) d\\omega\\\\ \u0026amp;= \\int_0^{2\\pi} \\int_0^{\\theta_{\\max}} p(\\phi)p(\\theta) \\sin\\theta d\\theta d\\omega \\end{aligned} \\end{equation} $$\n已知\\(p(\\phi)=\\frac{1}{2\\pi}\\), \\(p(\\theta)\\)为均匀分布, 则有如下关系.\n$$ \\begin{equation} \\begin{aligned} 1 \u0026amp;= c \\int_0^{\\theta_{\\max}} \\sin\\theta d\\theta\\\\ \u0026amp;= c (1 - \\cos\\theta_{\\max}) \\end{aligned} \\end{equation} $$\n此时可以得到最终的pdf.\n$$ \\begin{equation} p(\\omega) = \\frac{1}{2\\pi(1 - \\cos\\theta_{\\max})} \\end{equation} $$\n圆柱 # 圆柱的参数方程如下, z是圆柱的高度.\n$$ \\begin{equation} \\begin{aligned} \\phi \u0026amp;= u \\phi_{\\max}\\\\ x \u0026amp;= r \\cos\\phi\\\\ y \u0026amp;= r \\sin\\phi\\\\ z \u0026amp;= z_{\\min} + v(z_{\\max} - z_{\\min}) \\end{aligned} \\end{equation} $$\n包围结构 # PBRT_CPU_GPU Bounds3f Cylinder::Bounds() const { return (*renderFromObject)( Bounds3f({-radius, -radius, zMin}, {radius, radius, zMax})); } 表面面积 # PBRT_CPU_GPU Float Area() const { return (zMax - zMin) * radius * phiMax; } 相交测试 # 通过\\(x^2 + y^2 = r^2\\)计算相交, \\(u = \\frac{\\phi}{\\phi_{\\max}}\\), \\(v = \\frac{z - z_{\\min}}{z_{\\max} - z_{\\min}}\\).\n表面采样 # 圆柱体没有特定的根据参考点的立体角采样的方法, 而是先进行面积采样再转为立体角, 根据立体角与面积的转换公式可以获取pdf.\n$$ \\begin{equation} p(\\omega) = \\frac{1}{A} \\frac{r^2}{\\cos\\theta} \\end{equation} $$\n圆盘 # 圆盘参数方程如下, 本地空间中圆盘位于xy平面, \\(r_i\\)代表inner radius.\n$$ \\begin{equation} \\begin{aligned} \\phi \u0026amp;= u \\phi_{\\max}\\\\ x \u0026amp;= ((1-v)r + vr_i)\\cos\\phi\\\\ y \u0026amp;= ((1-v)r + vr_i)\\sin\\phi\\\\ z \u0026amp;= h \\end{aligned} \\end{equation} $$\n包围结构 # PBRT_CPU_GPU Bounds3f Disk::Bounds() const { return (*renderFromObject)( Bounds3f(Point3f(-radius, -radius, height), Point3f(radius, radius, height))); } PBRT_CPU_GPU DirectionCone Disk::NormalBounds() const { Normal3f n = (*renderFromObject)(Normal3f(0, 0, 1)); if (reverseOrientation) n = -n; return DirectionCone(Vector3f(n)); } 表面面积 # $$ \\begin{equation} A = \\frac{\\phi_{\\max}}{2}(r^2 - r^2_i) \\end{equation} $$\n相交测试 # 计算出z位于h时光线对应的t值以及判断该点是否位于圆盘内部即可, \\(u=\\frac{\\phi}{\\phi_{\\max}}, v=\\frac{r - r_{\\text{hit}}}{r - r_i}\\).\n表面采样 # 对于圆盘采样, 如果在\\(r\\)和\\(\\theta\\)上分别均匀采样, 由于半径的增长导致\\(\\phi\\)采样点对应的位置越来越分散, 采样点会集中在圆心附近.\n我们需要满足\\(p(x,y)=\\frac{1}{\\pi}\\), 即\\(p(r,\\theta)=\\frac{r}{\\pi}\\), 此时可以得到如下关系以及根据逆变换法得到的采样方程.\n$$ \\begin{equation} \\begin{aligned} p(r) \u0026amp;= \\int_0^{2\\pi} p(r,\\theta) d\\theta = 2r\\\\ p(\\theta|r) \u0026amp;= \\frac{p(r, \\theta)}{p(r)} = \\frac{1}{2\\pi} \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} r \u0026amp;= \\sqrt{\\epsilon_1}\\\\ \\theta \u0026amp;= 2\\pi\\epsilon_2 \\end{aligned} \\end{equation} $$\n此时由于\\(r\\)的非线性, 导致u,v对应的面积的不均匀, 这影响了分层抽样的效果. pbrt采用同心映射将\\([-1,1]\\)对应的xy平面映射到圆上. 下式分别为\\(|x|\u0026gt;|y|\\)与\\(|y| \\ge |x|\\)的情况.\n$$ \\begin{equation} \\begin{aligned} r \u0026amp;= x\\\\ \\theta \u0026amp;= \\frac{\\pi}{4} \\frac{y}{x} \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} r \u0026amp;= y\\\\ \\theta \u0026amp;= \\frac{\\pi}{2} - \\frac{\\pi}{4} \\frac{x} {y} \\end{aligned} \\end{equation} $$\n三角网格 # 根据Euler–Poincaré公式, 闭合几何体的顶点数\\(V\\), 边数\\(E\\)与面数\\(F\\)满足如下关系, 其中\\(g\\)代表几何体上洞的数量.\n$$ \\begin{equation} V - E + F = 2 (1 - g) \\end{equation} $$\n对于三角形网格还有如下关系, 面数较多时\\(g\\)可以忽略不计.\n$$ \\begin{equation} \\begin{aligned} E \u0026amp;= \\frac{3}{2} F\\\\ F \u0026amp;\\approx 2 V \\end{aligned} \\end{equation} $$\n网格存储 # TriangleMesh类的声明如下. 尽管构造函数传入的是vector, 内部仍然使用指针来存储数据, 以此来达到多个共享几何数据的效果. 尽管pbrt提供了instance功能, 像高精度地形的存储仍然需要这种方式来节省内存.\nclass TriangleMesh { public: // TriangleMesh Public Methods TriangleMesh(const Transform \u0026amp;renderFromObject, bool reverseOrientation, std::vector\u0026lt;int\u0026gt; vertexIndices, std::vector\u0026lt;Point3f\u0026gt; p, std::vector\u0026lt;Vector3f\u0026gt; S, std::vector\u0026lt;Normal3f\u0026gt; N, std::vector\u0026lt;Point2f\u0026gt; uv, std::vector\u0026lt;int\u0026gt; faceIndices, Allocator alloc); std::string ToString() const; bool WritePLY(std::string filename) const; static void Init(Allocator alloc); // TriangleMesh Public Members int nTriangles, nVertices; const int *vertexIndices = nullptr; const Point3f *p = nullptr; const Normal3f *n = nullptr; const Vector3f *s = nullptr; const Point2f *uv = nullptr; const int *faceIndices = nullptr; bool reverseOrientation, transformSwapsHandedness; }; pbrt通过BufferCache类来将vector转为指针, 它会查找cache中是否已经有一份相同的数据并返回它的指针. 为了防止mutex导致的低并发效率, pbrt根据数据的hash将它存储在不同的cache中. pbrt中通过全局对象来访问BufferCache.\nconst T *LookupOrAdd(pstd::span\u0026lt;const T\u0026gt; buf, Allocator alloc) { ++nBufferCacheLookups; // Return pointer to data if _buf_ contents are already in the cache Buffer lookupBuffer(buf.data(), buf.size()); int shardIndex = uint32_t(lookupBuffer.hash) \u0026gt;\u0026gt; (32 - logShards); DCHECK(shardIndex \u0026gt;= 0 \u0026amp;\u0026amp; shardIndex \u0026lt; nShards); mutex[shardIndex].lock_shared(); if (auto iter = cache[shardIndex].find(lookupBuffer); iter != cache[shardIndex].end()) { const T *ptr = iter-\u0026gt;ptr; mutex[shardIndex].unlock_shared(); DCHECK(std::memcmp(buf.data(), iter-\u0026gt;ptr, buf.size() * sizeof(T)) == 0); ++nBufferCacheHits; redundantBufferBytes += buf.size() * sizeof(T); return ptr; } // Add _buf_ contents to cache and return pointer to cached copy mutex[shardIndex].unlock_shared(); T *ptr = alloc.allocate_object\u0026lt;T\u0026gt;(buf.size()); std::copy(buf.begin(), buf.end(), ptr); bytesUsed += buf.size() * sizeof(T); mutex[shardIndex].lock(); // Handle the case of another thread adding the buffer first if (auto iter = cache[shardIndex].find(lookupBuffer); iter != cache[shardIndex].end()) { const T *cachePtr = iter-\u0026gt;ptr; mutex[shardIndex].unlock(); alloc.deallocate_object(ptr, buf.size()); ++nBufferCacheHits; redundantBufferBytes += buf.size() * sizeof(T); return cachePtr; } cache[shardIndex].insert(Buffer(ptr, buf.size())); mutex[shardIndex].unlock(); return ptr; } Buffer类用于存储指针并在构造时计算hash.\nstruct Buffer { // BufferCache::Buffer Public Methods Buffer() = default; Buffer(const T *ptr, size_t size) : ptr(ptr), size(size) { hash = HashBuffer(ptr, size); } bool operator==(const Buffer \u0026amp;b) const { return size == b.size \u0026amp;\u0026amp; hash == b.hash \u0026amp;\u0026amp; std::memcmp(ptr, b.ptr, size * sizeof(T)) == 0; } const T *ptr = nullptr; size_t size = 0, hash; } 对于三角网格pbrt会在构造时将顶点位置, 法线等属性转到渲染空间中, 然后再存储到cache, 以此节省后续访问时的计算开销. 显然cache miss会增加, 但是计算开销减小了.\n三角形类 # 为节省空间开销, Triangle类只存储对应的TriangleMesh的序号以及自身在网格中的序号.\nTriangle() = default; Triangle(int meshIndex, int triIndex) : meshIndex(meshIndex), triIndex(triIndex) {} NormalBounds计算三角面的几何法线, 如果几何法线与顶点法线的插值结果不指向同一侧, 几何法线会被调整.\nPBRT_CPU_GPU DirectionCone Triangle::NormalBounds() const { // Get triangle vertices in _p0_, _p1_, and _p2_ const TriangleMesh *mesh = GetMesh(); const int *v = \u0026amp;mesh-\u0026gt;vertexIndices[3 * triIndex]; Point3f p0 = mesh-\u0026gt;p[v[0]], p1 = mesh-\u0026gt;p[v[1]], p2 = mesh-\u0026gt;p[v[2]]; Normal3f n = Normalize(Normal3f(Cross(p1 - p0, p2 - p0))); // Ensure correct orientation of geometric normal for normal bounds if (mesh-\u0026gt;n) { Normal3f ns(mesh-\u0026gt;n[v[0]] + mesh-\u0026gt;n[v[1]] + mesh-\u0026gt;n[v[2]]); n = FaceForward(n, ns); } else if (mesh-\u0026gt;reverseOrientation ^ mesh-\u0026gt;transformSwapsHandedness) n *= -1; return DirectionCone(Vector3f(n)); } 相交测试 # 三角形的光线测试是一个独立函数, 而非实现了Shape的接口. pbrt首先变换到以光线起始点为原点, 光线方向为\\(z\\)轴的空间, 这样可以避免恰好打到边上的光线被认为不相交, 后续章节会解释. 由于浮点精度问题, 需要判断转换后的三角形是否退化为线段.\n变换分为三步, 首先平移变换将光线起始点移到原点, 其次将绝对值最大的轴置换为\\(z\\)轴以保证\\(z\\)非0, 最后通过切变变换将光线方向与z轴对齐. 切变变换定义如下, 用于将光线方向中\\(x\\),\\(y\\)置0, \\(z\\)置1, 与旋转相比切变的开销较小. 经过变换后, 只需要判断\\((0, 0)\\)是否位于三角形在\\(xy\\)平面的投影上.\n$$ \\begin{equation} \\begin{aligned} S = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; -\\frac{\\bold{d}_x}{\\bold{d}_z} \u0026amp; 0\\\\ 0 \u0026amp; 1 \u0026amp; -\\frac{\\bold{d}_y}{\\bold{d}_z} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{1}{\\bold{d}_z} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix} \\end{aligned} \\end{equation} $$\n叉乘结果具有方向, 利用行列式可以构造边方程, 用于判断判断点\\(p\\)在边\\(p_0p_1\\)的哪一侧. 若某点位于三角形三条边的同侧, 可以认为它位于三角形内部. 由于行列式也可以用于计算两条边组成的平行四边形的面积, 边方程同时计算了重心坐标.\n$$ \\begin{equation} \\begin{aligned} e(p) = \\begin{vmatrix} p_x - p_{0x} \u0026amp; p_y - p_{0y}\\\\ p_{1x} - p_{0x} \u0026amp; p_{1y} - p_{0y} \\end{vmatrix} \\end{aligned} \\end{equation} $$\n为避免除以分母带来的误差, pbrt计算交点时不使用面积归一化边方程结果. 经过变换后\\(z\\)与\\(t\\)相同, 相交测试完成后可计算重心坐标与相交的\\(t\\)值.\n// Compute scaled hit distance to triangle and test against ray $t$ range p0t.z *= Sz; p1t.z *= Sz; p2t.z *= Sz; Float tScaled = e0 * p0t.z + e1 * p1t.z + e2 * p2t.z; if (det \u0026lt; 0 \u0026amp;\u0026amp; (tScaled \u0026gt;= 0 || tScaled \u0026lt; tMax * det)) return {}; else if (det \u0026gt; 0 \u0026amp;\u0026amp; (tScaled \u0026lt;= 0 || tScaled \u0026gt; tMax * det)) return {}; // Compute barycentric coordinates and $t$ value for triangle intersection Float invDet = 1 / det; Float b0 = e0 * invDet, b1 = e1 * invDet, b2 = e2 * invDet; Float t = tScaled * invDet; 三角形内部各个值根据重心坐标线性插值, 包括\\(uv\\)也是线性变化, 因此各个值在\\(uv\\)上的偏导数在三角形内部相同. 因此求解线性方程即可获取位置, 法线等关于\\(uv\\)的偏导数. 位置偏导数主要用于法线纹理, 法线偏导数则用于视差纹理.\n$$ \\begin{equation} \\begin{aligned} \\begin{pmatrix} u_0 - u_2 \u0026amp; v_0 - v_2\\\\ u_1 - u_2 \u0026amp; v_1 - v_2 \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial p}{\\partial u}\\\\ \\frac{\\partial p}{\\partial v} \\end{pmatrix} = \\begin{pmatrix} p_0 - p_2\\\\ p_1 - p_2 \\end{pmatrix} \\end{aligned} \\end{equation} $$\npbrt每次相交都会重新计算偏导数, 以时间换空间. 如果没有\\(uv\\)值pbrt会使用默认值. SurfaceInteraction将几何法线初始化为p在\\(uv\\)偏导的叉乘, 三角网格由于贴图\\(uv\\)的缘故无法采用这种方式, pbrt采用边的叉乘来得到几何边线. 若顶点拥有法线与切线, pbrt会采用插值结果, 且采用类似的方式计算法线在\\(uv\\)的偏导.\n表面采样 # 采样通过将均匀采样结果转化为重心坐标来实现, 因此在任意形状的三角形上采样均不影响结果. 通过将正方形中关于对角线对称的采样结果视为同一个点可以得到均匀的采样分布, 但这会使得原本相距较远的采样点变为同一个采样点, 这会影响部分采样器的效果.\npbrt采用如下转换方式. 更直观地说, 这将\\(y=1-x\\),\\(x=0\\)和\\(y=0\\)围成的三角形根据\\(y=x\\)分割, 每部分映射到\\(y=x\\),\\(y=1-x\\)和\\(x=0\\)或\\(y=0\\)围成的三角形中. 此时Jacobi行列式为常数, 所以具有面积保持的特征.\n$$ \\begin{equation} \\begin{aligned} f(x, y) = (x - \\delta, y - \\delta), \\delta = \\begin{cases} \\frac{x}{2} \u0026amp; x \u0026lt; y\\\\ \\frac{y}{2} \u0026amp; y \\le x \\end{cases} \\end{aligned} \\end{equation} $$\n假设三角形光源各个点发射相同的光, BSDF为常数值, 在三角形面积上均匀采样, 利用面积与立体角微分的转换可以得到如下的采样公式, 其中\\(V\\)为可见性方程, \\(p\\)为观察点位置, \\(p\u0026rsquo;\\)为光源上的采样点的位置. 由于分母上的平方项, 距离光源较近的物体会有较大的采样误差, 因此直接将立体角采样转为面积采样并不合适. 对于立体角范围过小和过大的三角形, 由于浮点误差pbrt仍然采用面积采样.\n$$ \\begin{equation} \\frac{\\rho L_e}{1/A}\\left(V(p, p\u0026rsquo;)|\\cos\\theta\u0026rsquo;|\\frac{|\\cos\\theta_1|}{\\Vert p\u0026rsquo; - p \\Vert^2} \\right) \\end{equation} $$\n对于其他情况, pbrt使用Stratified Sampling of Spherical Triangles提出的球面三角形采样. 首先根据参考点构建单位球, 将三角形投影到单位球上形成球面三角形\\(abc\\), 在\\(abc\\)上执行均匀面积采样. 各个边均可与球心构成平面, 计算平面法线, 各个面法线的夹角的补角为平面夹角, 等价于球面三角形的内角, 使用\\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\)分别表示.\n实际采样算法如下: 令\\(abc\\)面积为A, 首先根据\\(\\epsilon_0\\)获取在\\(\\overset{\\frown}{ac}\\)上的点\\(c\u0026rsquo;\\), 使形成的三角形\\(abc\u0026rsquo;\\)面积为\\(\\epsilon_0 A\\). 然后令在\\(c\u0026rsquo;\\)处与\\(\\overset{\\frown}{bc\u0026rsquo;}\\)垂直的微分底边与\\(b\\)形成的微分三角形面积为\\(A_{\\overset{\\frown}{bc\u0026rsquo;}}\\), 在\\(\\overset{\\frown}{bc\u0026rsquo;}\\)上根据\\(\\epsilon_1\\)采样, 获取\\(c\u0026rsquo;\u0026rsquo;\\)使得构成的微分三角形\\(A_{\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;}}\\)面积为\\(\\epsilon_1A_{\\overset{\\frown}{bc\u0026rsquo;}}\\).\n由于\\(A_\\pi=\\alpha+\\beta+\\gamma=A+\\pi\\), pbrt直接使用\\(A_\\pi\\)执行采样, 以减少小三角形计算\\(A_\\pi-\\pi\\)导致的浮点误差, 这通过均匀采样并在\\(\\pi\\)与\\(A_\\pi\\)间插值实现.\n\\(abc\u0026rsquo;\\)的内角为\\(\\alpha\\),\\(\\beta\u0026rsquo;\\),\\(\\gamma\u0026rsquo;\\), \\(\\alpha\\)与\\(A\u0026rsquo;_\\pi\\)已知, \\(\\beta\u0026rsquo;\\)与\\(\\gamma\u0026rsquo;\\)未知. 求解\\(c\u0026rsquo;\\)需求解\\(\\overset{\\frown}{ac\u0026rsquo;}\\)的长度, 此时根据球面三角公式可得如下关系.\n$$ \\begin{equation} \\begin{aligned} \\cos\\beta\u0026rsquo;\u0026amp;=-\\cos\\gamma\u0026rsquo;\\cos\\alpha+\\sin\\gamma\u0026rsquo;\\sin\\alpha\\cos\\overset{\\frown}{ac\u0026rsquo;}\\\\ \\cos\\overset{\\frown}{ac\u0026rsquo;} \u0026amp;=\\frac{\\cos\\beta\u0026rsquo;+\\cos(A\u0026rsquo;_\\pi-\\alpha-\\beta\u0026rsquo;)\\cos\\alpha}{\\sin(A\u0026rsquo;_\\pi-\\alpha-\\beta\u0026rsquo;)\\sin\\alpha}\\\\ \u0026amp;=\\frac{\\cos\\beta\u0026rsquo;+\\cos(\\phi-\\beta\u0026rsquo;)\\cos\\alpha}{\\sin(\\phi-\\beta\u0026rsquo;)\\sin\\alpha}\\\\ \u0026amp;=\\frac{\\cos\\beta\u0026rsquo;+(\\cos\\phi\\cos\\beta\u0026rsquo; + \\sin\\phi\\sin\\beta\u0026rsquo;)\\cos\\alpha}{(\\sin\\phi\\cos\\beta\u0026rsquo;-\\cos\\phi\\sin\\beta\u0026rsquo;)\\sin\\alpha}\\\\ \\end{aligned} \\end{equation} $$\n此时\\(\\beta\u0026rsquo;\\)仍然未知, 引入已知量\\(\\overset{\\frown}{ab}\\), 可得如下关系, 其中\\(k_1\\),\\(k_2\\)皆为已知量.\n$$ \\begin{equation} \\begin{aligned} \\cos(\\phi-\\beta\u0026rsquo;)\u0026amp;=-\\cos\\beta\u0026rsquo;\\cos\\alpha+\\sin\\beta\u0026rsquo;\\sin\\alpha\\cos\\overset{\\frown}{ab}\\\\ 0 \u0026amp;=(\\cos\\phi+\\cos\\alpha)\\cos\\beta\u0026rsquo;+(\\sin\\phi-\\sin\\alpha\\cos\\overset{\\frown}{ab})\\sin\\beta\u0026rsquo;\\\\ \u0026amp;=k_1\\cos\\beta\u0026rsquo;+k_2\\sin\\beta\u0026rsquo;\\\\ \\cos\\beta\u0026rsquo;\u0026amp;=\\frac{\\pm k_2}{\\sqrt{k_1^2+k_2^2}}\\\\ \\sin\\beta\u0026rsquo;\u0026amp;=\\frac{\\mp k_1}{\\sqrt{k_1^2+k_2^2}} \\end{aligned} \\end{equation} $$\n将上式代入, \\(\\cos\\overset{\\frown}{ac\u0026rsquo;}\\)求解结果如下, 获取\\(\\overset{\\frown}{ac\u0026rsquo;}\\)后即可计算\\(c\u0026rsquo;\\)的实际位置.\n$$ \\begin{equation} \\begin{aligned} \\cos\\overset{\\frown}{ac\u0026rsquo;}\u0026amp;=\\frac{k_2+(k_2\\cos\\phi-k_1\\sin\\phi)\\cos\\alpha}{(k_2\\sin\\phi+k_1\\cos\\phi)\\sin\\alpha}\\\\ \\bold{c\u0026rsquo;}\u0026amp;=\\cos\\overset{\\frown}{ac\u0026rsquo;}\\bold{a}+\\sin\\overset{\\frown}{ac\u0026rsquo;}\\bold{c_\\perp} \\end{aligned} \\end{equation} $$\n将\\(b\\)变换到球的北极, 根据微分立体角转微分面积的公式, 以及经过\\(b\\)的两平面的夹角\\(\\beta\\)与所占方位角\\(\\phi\\)相等这一关系, \\(c\u0026rsquo;\u0026rsquo;\\)处与\\(\\overset{\\frown}{bc\u0026rsquo;}\\)垂直的微分圆弧长度为\\(\\sin\\overset{\\frown}{bc\u0026rsquo;}d\\overset{\\frown}{bc\u0026rsquo;}d\\beta\\). 此时可根据\\(\\overset{\\frown}{bc\u0026rsquo;}\\)上的积分求出微分三角形的面积.\n$$ \\begin{equation} \\begin{aligned} A_{\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;}}=\\int_0^{\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;}} \\sin\\theta d\\theta d\\beta=(1-\\cos\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;})d\\beta \\end{aligned} \\end{equation} $$\n根据\\(A_{\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;}}\\)与\\(A_{\\overset{\\frown}{bc\u0026rsquo;}}\\)的比值, 可得根据\\(\\epsilon_1\\)采样\\(c\u0026rsquo;\u0026rsquo;\\)的方式, 向量\\(\\bold{c\u0026rsquo;\u0026rsquo;}\\)即为采样方向\\(\\omega\\). 由于不再需要判断光线是否相交, 此时根据\\(o+t\\bold{d}=(1-b_1-b_2)v_0+b_1v_1+b_2v_2\\)求解重心坐标即可.\n$$ \\begin{equation} \\begin{aligned} \\epsilon_1\u0026amp;=\\frac{1-\\cos\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;}}{1-\\cos\\overset{\\frown}{bc\u0026rsquo;}}\\\\ \\cos\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;}\u0026amp;=1-\\epsilon_1(1-\\cos\\overset{\\frown}{bc\u0026rsquo;}) \\end{aligned} \\end{equation} $$\n完整采样过程实现在SampleSphericalTriangle.\n// Sampling Function Definitions PBRT_CPU_GPU pstd::array\u0026lt;Float, 3\u0026gt; SampleSphericalTriangle(const pstd::array\u0026lt;Point3f, 3\u0026gt; \u0026amp;v, Point3f p, Point2f u, Float *pdf) { if (pdf) *pdf = 0; // Compute vectors _a_, _b_, and _c_ to spherical triangle vertices Vector3f a(v[0] - p), b(v[1] - p), c(v[2] - p); CHECK_GT(LengthSquared(a), 0); CHECK_GT(LengthSquared(b), 0); CHECK_GT(LengthSquared(c), 0); a = Normalize(a); b = Normalize(b); c = Normalize(c); // Compute normalized cross products of all direction pairs Vector3f n_ab = Cross(a, b), n_bc = Cross(b, c), n_ca = Cross(c, a); if (LengthSquared(n_ab) == 0 || LengthSquared(n_bc) == 0 || LengthSquared(n_ca) == 0) return {}; n_ab = Normalize(n_ab); n_bc = Normalize(n_bc); n_ca = Normalize(n_ca); // Find angles $\\alpha$, $\\beta$, and $\\gamma$ at spherical triangle vertices Float alpha = AngleBetween(n_ab, -n_ca); Float beta = AngleBetween(n_bc, -n_ab); Float gamma = AngleBetween(n_ca, -n_bc); // Uniformly sample triangle area $A$ to compute $A\u0026#39;$ Float A_pi = alpha + beta + gamma; Float Ap_pi = Lerp(u[0], Pi, A_pi); if (pdf) { Float A = A_pi - Pi; *pdf = (A \u0026lt;= 0) ? 0 : 1 / A; } // Find $\\cos\\beta\u0026#39;$ for point along _b_ for sampled area Float cosAlpha = std::cos(alpha), sinAlpha = std::sin(alpha); Float sinPhi = std::sin(Ap_pi) * cosAlpha - std::cos(Ap_pi) * sinAlpha; Float cosPhi = std::cos(Ap_pi) * cosAlpha + std::sin(Ap_pi) * sinAlpha; Float k1 = cosPhi + cosAlpha; Float k2 = sinPhi - sinAlpha * Dot(a, b) /* cos c */; Float cosBp = (k2 + (DifferenceOfProducts(k2, cosPhi, k1, sinPhi)) * cosAlpha) / ((SumOfProducts(k2, sinPhi, k1, cosPhi)) * sinAlpha); // Happens if the triangle basically covers the entire hemisphere. // We currently depend on calling code to detect this case, which // is sort of ugly/unfortunate. CHECK(!IsNaN(cosBp)); cosBp = Clamp(cosBp, -1, 1); // Sample $c\u0026#39;$ along the arc between $a$ and $c$ Float sinBp = SafeSqrt(1 - Sqr(cosBp)); Vector3f cp = cosBp * a + sinBp * Normalize(GramSchmidt(c, a)); // Compute sampled spherical triangle direction and return barycentrics Float cosTheta = 1 - u[1] * (1 - Dot(cp, b)); Float sinTheta = SafeSqrt(1 - Sqr(cosTheta)); Vector3f w = cosTheta * b + sinTheta * Normalize(GramSchmidt(cp, b)); // Find barycentric coordinates for sampled direction _w_ Vector3f e1 = v[1] - v[0], e2 = v[2] - v[0]; Vector3f s1 = Cross(w, e2); Float divisor = Dot(s1, e1); CHECK_RARE(1e-6, divisor == 0); if (divisor == 0) { // This happens with triangles that cover (nearly) the whole // hemisphere. return {1.f / 3.f, 1.f / 3.f, 1.f / 3.f}; } Float invDivisor = 1 / divisor; Vector3f s = p - v[0]; Float b1 = Dot(s, s1) * invDivisor; Float b2 = Dot(w, Cross(s, e1)) * invDivisor; // Return clamped barycentrics for sampled direction b1 = Clamp(b1, 0, 1); b2 = Clamp(b2, 0, 1); if (b1 + b2 \u0026gt; 1) { b1 /= b1 + b2; b2 /= b1 + b2; } return {Float(1 - b1 - b2), Float(b1), Float(b2)}; } 对于需要根据采样方向倒推PDF的情况, 由于\\(c\u0026rsquo;\u0026rsquo;\\)已知, 根据\\(\\overset{\\frown}{bc\u0026rsquo;\u0026rsquo;}\\)与\\(\\overset{\\frown}{ac}\\)的交点可求得\\(c\u0026rsquo;\\). 交点为圆弧构成的平面的相交直线与球的交点, 直线方向通过两平面法线叉乘求得, 选择与\\(\\bold{a}+\\bold{c}\\)同向的交点, 同时已知交线会经过球心, 此时可以确定\\(c\u0026rsquo;\\)以及\\(abc\u0026rsquo;\\)的面积, 以此求得\\(\\epsilon_0\\). \\(\\epsilon_1\\)根据概率公式直接求出即可.\npbrt实现了InvertSphericalTriangleSample执行倒推过程, 对于\\(ac\u0026rsquo;\\)长度较小的情况, 为避免浮点误差\\(\\beta\u0026rsquo;\\)较小时认为\\(\\epsilon_0=0\\).\n// Via Jim Arvo\u0026#39;s SphTri.C PBRT_CPU_GPU Point2f InvertSphericalTriangleSample(const pstd::array\u0026lt;Point3f, 3\u0026gt; \u0026amp;v, Point3f p, Vector3f w) { // Compute vectors _a_, _b_, and _c_ to spherical triangle vertices Vector3f a(v[0] - p), b(v[1] - p), c(v[2] - p); CHECK_GT(LengthSquared(a), 0); CHECK_GT(LengthSquared(b), 0); CHECK_GT(LengthSquared(c), 0); a = Normalize(a); b = Normalize(b); c = Normalize(c); // Compute normalized cross products of all direction pairs Vector3f n_ab = Cross(a, b), n_bc = Cross(b, c), n_ca = Cross(c, a); if (LengthSquared(n_ab) == 0 || LengthSquared(n_bc) == 0 || LengthSquared(n_ca) == 0) return {}; n_ab = Normalize(n_ab); n_bc = Normalize(n_bc); n_ca = Normalize(n_ca); // Find angles $\\alpha$, $\\beta$, and $\\gamma$ at spherical triangle vertices Float alpha = AngleBetween(n_ab, -n_ca); Float beta = AngleBetween(n_bc, -n_ab); Float gamma = AngleBetween(n_ca, -n_bc); // Find vertex $\\VEC{c\u0026#39;}$ along $\\VEC{a}\\VEC{c}$ arc for $\\w{}$ Vector3f cp = Normalize(Cross(Cross(b, w), Cross(c, a))); if (Dot(cp, a + c) \u0026lt; 0) cp = -cp; // Invert uniform area sampling to find _u0_ Float u0; if (Dot(a, cp) \u0026gt; 0.99999847691f /* 0.1 degrees */) u0 = 0; else { // Compute area $A\u0026#39;$ of subtriangle Vector3f n_cpb = Cross(cp, b), n_acp = Cross(a, cp); CHECK_RARE(1e-5, LengthSquared(n_cpb) == 0 || LengthSquared(n_acp) == 0); if (LengthSquared(n_cpb) == 0 || LengthSquared(n_acp) == 0) return Point2f(0.5, 0.5); n_cpb = Normalize(n_cpb); n_acp = Normalize(n_acp); Float Ap = alpha + AngleBetween(n_ab, n_cpb) + AngleBetween(n_acp, -n_cpb) - Pi; // Compute sample _u0_ that gives the area $A\u0026#39;$ Float A = alpha + beta + gamma - Pi; u0 = Ap / A; } // Invert arc sampling to find _u1_ and return result Float u1 = (1 - Dot(w, b)) / (1 - Dot(cp, b)); return Point2f(Clamp(u0, 0, 1), Clamp(u1, 0, 1)); } Kajiya方程中的\\(\\cos\\theta\\)项同样也会影响方差, pbrt将其包括在pdf中. 由于在\\(\\epsilon_0\\epsilon_1\\)上它是平滑变化的, 已知\\(a\\)对应\\((0, 1)\\), \\(b\\)对应\\((0, 0)\\)与\\((1, 0)\\), \\(c\\)对应\\((1, 1)\\), 通过在单位正方形将顶点对应的\\(\\cos\\theta\\)作为采样权重, 内部采样权重为顶点双线性插值结果, 可执行重要性抽样, 将双线性采样拆解为两次线性采样即可.\n// Sample spherical triangle from reference point // Apply warp product sampling for cosine factor at reference point Float pdf = 1; if (ctx.ns != Normal3f(0, 0, 0)) { // Compute $\\cos\\theta$-based weights _w_ at sample domain corners Point3f rp = ctx.p(); Vector3f wi[3] = {Normalize(p0 - rp), Normalize(p1 - rp), Normalize(p2 - rp)}; pstd::array\u0026lt;Float, 4\u0026gt; w = pstd::array\u0026lt;Float, 4\u0026gt;{std::max\u0026lt;Float\u0026gt;(0.01, AbsDot(ctx.ns, wi[1])), std::max\u0026lt;Float\u0026gt;(0.01, AbsDot(ctx.ns, wi[1])), std::max\u0026lt;Float\u0026gt;(0.01, AbsDot(ctx.ns, wi[0])), std::max\u0026lt;Float\u0026gt;(0.01, AbsDot(ctx.ns, wi[2]))}; u = SampleBilinear(u, w); DCHECK(u[0] \u0026gt;= 0 \u0026amp;\u0026amp; u[0] \u0026lt; 1 \u0026amp;\u0026amp; u[1] \u0026gt;= 0 \u0026amp;\u0026amp; u[1] \u0026lt; 1); pdf = BilinearPDF(u, w); } PBRT_CPU_GPU inline Point2f SampleBilinear(Point2f u, pstd::span\u0026lt;const Float\u0026gt; w) { DCHECK_EQ(4, w.size()); Point2f p; // Sample $y$ for bilinear marginal distribution p.y = SampleLinear(u[1], w[0] + w[1], w[2] + w[3]); // Sample $x$ for bilinear conditional distribution p.x = SampleLinear(u[0], Lerp(p.y, w[0], w[2]), Lerp(p.y, w[1], w[3])); return p; } 双线性片 # 由四个点组成的面可以覆盖\\([0,1]^2\\)的uv空间的形状即位双线性片, 表面上的点对应的值可以通过插值获取. 与三角形网格类似, BilinearPatchMesh内部数据存储在cache中, 构造时变换到渲染空间, BilinearPatch中只存储序号.\n$$ \\begin{equation} \\begin{aligned} f(u,v) \u0026amp;= (1 - u)(1 - v)p_{0,0} + u (1 - v) p_{1,0} + (1 - u) v p_{0,1} + u v p_{1,1}\\\\ \\frac{\\partial p}{\\partial u} \u0026amp;= (1 - v)(p_{1,0} - p_{0,0}) + v(p_{1,1} - p_{0,1})\\\\ \\frac{\\partial p}{\\partial v} \u0026amp;= (1 - u)(p_{1,0} - p_{0,0}) + u(p_{1,1} - p_{0,1}) \\end{aligned} \\end{equation} $$\n双线性片很多时候以矩形的形式出现, 这种情况可以简化很多计算, pbrt通过判断某个点到第四个点的向量是否与前三个点组成的平面的法线垂直来检查四个点是否共面, 通过判断四个点到他们的中心距离是否相等来判断是否是矩形.\nPBRT_CPU_GPU bool IsRectangle(const BilinearPatchMesh *mesh) const { // Get bilinear patch vertices in _p00_, _p01_, _p10_, and _p11_ const int *v = \u0026amp;mesh-\u0026gt;vertexIndices[4 * blpIndex]; Point3f p00 = mesh-\u0026gt;p[v[0]], p10 = mesh-\u0026gt;p[v[1]]; Point3f p01 = mesh-\u0026gt;p[v[2]], p11 = mesh-\u0026gt;p[v[3]]; if (p00 == p01 || p01 == p11 || p11 == p10 || p10 == p00) return false; // Check if bilinear patch vertices are coplanar Normal3f n(Normalize(Cross(p10 - p00, p01 - p00))); if (AbsDot(Normalize(p11 - p00), n) \u0026gt; 1e-5f) return false; // Check if planar vertices form a rectangle Point3f pCenter = (p00 + p01 + p10 + p11) / 4; Float d2[4] = {DistanceSquared(p00, pCenter), DistanceSquared(p01, pCenter), DistanceSquared(p10, pCenter), DistanceSquared(p11, pCenter)}; for (int i = 1; i \u0026lt; 4; ++i) if (std::abs(d2[i] - d2[0]) / d2[0] \u0026gt; 1e-4f) return false; return true; } 双线性片的法线包围锥体由四个点处法线的均值决定.\n// Compute average normal and return normal bounds for patch Vector3f n = Normalize(n00 + n10 + n01 + n11); Float cosTheta = std::min({Dot(n, n00), Dot(n, n01), Dot(n, n10), Dot(n, n11)}); return DirectionCone(n, Clamp(cosTheta, -1, 1)); 相交测试 # 首先找到一条对\\(u\\)进行插值形成的直线使得它到光线的距离为0, 计算两条不平行的直线的距离首先求二者叉乘获取法线, 再与两条直线分别组成两个平行的平面, 求二者的距离即可. 最终得到的\\(u\\)的二次方程系数如下.\n$$ \\begin{equation} \\begin{aligned} a \u0026amp;= ((p_{1,0} - p_{0,0}) \\times (p_{0,1} - p_{1, 1})) \\cdot \\bold{d}\\\\ c \u0026amp;= (p_{0,0} - \\bold{o}) \\times \\bold{d}) \\cdot (p_{0,1} - p_{0,0})\\\\ b \u0026amp;= (p_{1,0} - \\bold{o}) \\times \\bold{d}) \\cdot (p_{1,1} - p_{1,0}) - (a + c) \\end{aligned} \\end{equation} $$\n若\\(u\\)有解则可以按如下方式得到\\(v\\)与光线的\\(t\\)值.\n$$ \\begin{equation} f_u(v) \u0026amp;= (1 - v)p_{u,0} + vp_{u,1}\\\\ \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} t \u0026amp;= \\frac{\\text{det}(f_u(0) - \\bold{o}, f_u(1) - f_u(0), \\bold{d} \\times (f_u(1) - f_u(0)))}{\\Vert \\bold{d} \\times (f_u(1) - f_u(0)) \\Vert^2}\\\\ v \u0026amp;= \\frac{\\text{det}(f_u(0) - \\bold{o}, \\bold{d}, \\bold{d} \\times (f_u(1) - f_u(0)))}{\\Vert \\bold{d} \\times (f_u(1) - f_u(0)) \\Vert^2} \\end{aligned} \\end{equation} $$\n为了不与BilinearPatch本身的\\(uv\\)混淆, 贴图的\\(uv\\)用\\(st\\)来表示. 由于SurfaceInteraction中的位置在\\(uv\\)上的偏导实际上是在sv上的偏导, pbrt通过链式法则求得该值.\n$$ \\begin{equation} \\begin{aligned} \\frac{\\partial p}{\\partial u} \u0026amp;= p_{1,0} + v (p_{1,1} - p{1,0}) - p_{0, 0} - v (p_{0, 1} - p{0, 0})\\\\ \\frac{\\partial s}{\\partial u} \u0026amp;= s_{1,0} + v (s_{1,1} - s{1,0}) - s_{0, 0} - v (s_{0, 1} - s{0, 0})\\\\ \\end{aligned} \\end{equation} $$\n表面采样 # pbrt中双线性片采样的pdf与当前的微分面积相关, 这使得\\(uv\\)变化较为剧烈处不会聚集过多的采样点.\n// Compute PDF for sampling the $(u,v)$ coordinates given by _intr.uv_ Float pdf; if (mesh-\u0026gt;imageDistribution) pdf = mesh-\u0026gt;imageDistribution-\u0026gt;PDF(uv); else if (!IsRectangle(mesh)) { // Initialize _w_ array with differential area at bilinear patch corners pstd::array\u0026lt;Float, 4\u0026gt; w = { Length(Cross(p10 - p00, p01 - p00)), Length(Cross(p10 - p00, p11 - p10)), Length(Cross(p01 - p00, p11 - p01)), Length(Cross(p11 - p10, p11 - p01))}; pdf = BilinearPDF(uv, w); } else pdf = 1; // Find $\\dpdu$ and $\\dpdv$ at bilinear patch $(u,v)$ Point3f pu0 = Lerp(uv[1], p00, p01), pu1 = Lerp(uv[1], p10, p11); Vector3f dpdu = pu1 - pu0; Vector3f dpdv = Lerp(uv[0], p01, p11) - Lerp(uv[0], p00, p10); // Return final bilinear patch area sampling PDF return pdf / Length(Cross(dpdu, dpdv)); 对于非矩形, 有采样分布贴图或面积较小的双线性片采用面积采样转化为立体角采样的方法, 否则将矩形投影到球上形成球面矩形再进行采样. 对于矩形的\\(uv\\), 可以通过将点投影到边上并根据边长归一化获得.\n曲线 # pbrt的Curve类采用具有宽度的一维三次Bézier曲线, 可以渲染为平面, 圆柱体或带状曲面. 对于带状曲面, pbrt会提供顶点的法线用于后续的插值, 支持只表示曲线的某一部分.\n$$ \\begin{equation} p(u) = (1 - u)^3 p_0 + 3(1 - u)^2 u p_1 + 3(1 - u)u^2 p_2 + u^3 p_3 \\end{equation} $$\n包围结构 # pbrt首先计算控制点形成的包围盒, 再根据曲线宽度扩展包围盒. 法线包围结构返回的是完整的球这一保守结果.\nPBRT_CPU_GPU Bounds3f Curve::Bounds() const { pstd::span\u0026lt;const Point3f\u0026gt; cpSpan(common-\u0026gt;cpObj); Bounds3f objBounds = BoundCubicBezier(cpSpan, uMin, uMax); // Expand _objBounds_ by maximum curve width over $u$ range Float width[2] = {Lerp(uMin, common-\u0026gt;width[0], common-\u0026gt;width[1]), Lerp(uMax, common-\u0026gt;width[0], common-\u0026gt;width[1])}; objBounds = Expand(objBounds, std::max(width[0], width[1]) * 0.5f); return (*common-\u0026gt;renderFromObject)(objBounds); } 相交测试 # Curve类的相交测试接口通过调用IntersectRay成员函数来实现, 通过不断二分判断当前曲线包围盒是否与光线相交, 最终使得曲线区域接近线性线段方便计算相交.\n将曲线转换到光线空间使用lookAt矩阵实现, 相机正上方对应的向量会被设置为与曲线两端连成的向量垂直, 这使得曲线位于\\(xy\\)平面上且与\\(x\\)轴接近平行, 可以获取范围更小的包围盒以加速二分.\npbrt根据variation diminishing判断细分曲线所需要的深度, 深度为0时控制点形成的曲线接近直线. 由于可能出现与曲线拥有多个交点的情况, 非阴影光线递归求交时若深度不为0二分的两个分支都会搜索.\n// Compute refinement depth for curve, _maxDepth_ Float L0 = 0; for (int i = 0; i \u0026lt; 2; ++i) L0 = std::max( L0, std::max(std::max(std::abs(cp[i].x - 2 * cp[i + 1].x + cp[i + 2].x), std::abs(cp[i].y - 2 * cp[i + 1].y + cp[i + 2].y)), std::abs(cp[i].z - 2 * cp[i + 1].z + cp[i + 2].z))); int maxDepth = 0; if (L0 \u0026gt; 0) { Float eps = std::max(common-\u0026gt;width[0], common-\u0026gt;width[1]) * .05f; // width / 20 // Compute log base 4 by dividing log2 in half. int r0 = Log2Int(1.41421356237f * 6.f * L0 / (8.f * eps)) / 2; maxDepth = Clamp(r0, 0, 10); } 深度为0判断相交时, 首先根据控制点获得首尾两侧与曲线垂直的直线, 计算在\\(xy\\)平面上对于当前原点的边函数, 以判断光线交点是否在曲线范围内.\n// Intersect ray with curve segment // Test ray against segment endpoint boundaries // Test sample point against tangent perpendicular at curve start Float edge = (cp[1].y - cp[0].y) * -cp[0].y + cp[0].x * (cp[0].x - cp[1].x); if (edge \u0026lt; 0) return false; // Test sample point against tangent perpendicular at curve end edge = (cp[2].y - cp[3].y) * -cp[3].y + cp[3].x * (cp[3].x - cp[2].x); if (edge \u0026lt; 0) return false; 对于带状曲面, pbrt会根据球面插值得到的法线调整条带宽度.\n// Compute $u$ coordinate of curve intersection point and _hitWidth_ Float u = Clamp(Lerp(w, u0, u1), u0, u1); Float hitWidth = Lerp(u, common-\u0026gt;width[0], common-\u0026gt;width[1]); Normal3f nHit; if (common-\u0026gt;type == CurveType::Ribbon) { // Scale _hitWidth_ based on ribbon orientation if (common-\u0026gt;normalAngle == 0) nHit = common-\u0026gt;n[0]; else { Float sin0 = std::sin((1 - u) * common-\u0026gt;normalAngle) * common-\u0026gt;invSinNormalAngle; Float sin1 = std::sin(u * common-\u0026gt;normalAngle) * common-\u0026gt;invSinNormalAngle; nHit = sin0 * common-\u0026gt;n[0] + sin1 * common-\u0026gt;n[1]; } hitWidth *= AbsDot(nHit, ray.d) / rayLength; } 曲线上的\\(uv\\)空间的\\(v\\)与点在与曲线\\(u\\)处的垂线上的位置有关.\n// Initialize _SurfaceInteraction_ _intr_ for curve intersection // Compute $v$ coordinate of curve intersection point Float ptCurveDist = std::sqrt(ptCurveDist2); Float edgeFunc = dpcdw.x * -pc.y + pc.x * dpcdw.y; Float v = (edgeFunc \u0026gt; 0) ? 0.5f + ptCurveDist / hitWidth : 0.5f - ptCurveDist / hitWidth; u上的偏微分可以直接由Bézier曲线的定义获取. 对于条状曲线, 由于法线已知, 可以直接计算v上的偏微分. 对于平面, v上的偏微分方向沿着垂线, 且长度与当前宽度相等. 对于圆柱体, v上的偏微分会绕u上的偏微分旋转.\n// Compute $\\dpdu$ and $\\dpdv$ for curve intersection Vector3f dpdu, dpdv; EvaluateCubicBezier(pstd::MakeConstSpan(common-\u0026gt;cpObj), u, \u0026amp;dpdu); CHECK_NE(Vector3f(0, 0, 0), dpdu); if (common-\u0026gt;type == CurveType::Ribbon) dpdv = Normalize(Cross(nHit, dpdu)) * hitWidth; else { // Compute curve $\\dpdv$ for flat and cylinder curves Vector3f dpduPlane = objectFromRay.ApplyInverse(dpdu); Vector3f dpdvPlane = Normalize(Vector3f(-dpduPlane.y, dpduPlane.x, 0)) * hitWidth; if (common-\u0026gt;type == CurveType::Cylinder) { // Rotate _dpdvPlane_ to give cylindrical appearance Float theta = Lerp(v, -90, 90); Transform rot = Rotate(-theta, dpduPlane); dpdvPlane = rot(dpdvPlane); } dpdv = objectFromRay(dpdvPlane); } 浮点精度 # 浮点精度对渲染结果具有很大的影响, 典型的就是实时渲染中的depth bias, 光追中的浮点误差通常发生在求交中. 比较简单的做法是通过添加\\(\\epsilon\\)值来做offset, pbrt的浮点误差处理不需要使用这种方式.\n浮点算数 # 算数运算 # 默认当前浮点运算采用的是IEEE754的默认舍入模式, 即4以下向下取, 6以上想上去, 5舍入到最近的偶数, 这种方式可以减少四舍五入时5总是向上舍入带来的系统误差.\n对于指数为\\(e\\)的浮点数, 各个浮点数之间的最小距离为\\(2^{e-23}\\), 这个距离被称为最低有效位的量级(ulp). 对于浮点加法的运算结果, 令其误差范围为\\([(a+b)(1-\\epsilon),(a+b)(1+\\epsilon)]\\), 由于此时ulp为\\((a+b)2^{-23}\\), 可知\\(|\\epsilon| \\le 2^{-24} \\approx 5.960464\\ldots \\times 10^{-8}\\).\n工具代码 # pbrt支持获取浮点数中的下一个值, 即当前指数下距离最近的两个浮点数, 除NaN, 无穷大等特殊情况, 这通过直接修改最后一位bit来实现.\nPBRT_CPU_GPU inline float NextFloatUp(float v) { // Handle infinity and negative zero for _NextFloatUp()_ if (IsInf(v) \u0026amp;\u0026amp; v \u0026gt; 0.f) return v; if (v == -0.f) v = 0.f; // Advance _v_ to next higher float uint32_t ui = FloatToBits(v); if (v \u0026gt;= 0) ++ui; else --ui; return BitsToFloat(ui); } 误差传播 # 绝对误差与相对误差的定义如下.\n$$ \\begin{equation} \\begin{aligned} \\delta_a \u0026amp;= |\\tilde{a} - a|\\\\ \\delta_r \u0026amp;= |\\frac{\\tilde{a} - a}{a}| = \\frac{\\delta_a}{a} \\end{aligned} \\end{equation} $$\n舍入后的浮点数与对应的实数具有如下关系.\n$$ \\tilde{a} \\in a \\pm \\sigma_a = a(1 \\pm \\sigma_r) $$\n进行多次浮点加法的舍入结果如下.\n$$ (((a \\oplus b) \\oplus c) \\oplus d) \\in (a+b)(1 \\pm \\epsilon_m)^3 + c(1 \\pm \\epsilon_m)^2 + d(1 \\pm \\epsilon_m) $$\n对于高阶误差的幂具有如下的不等式.\n$$ (1 \\pm \\epsilon_m)^n \\le (1 \\pm (n + 1) \\epsilon_m) $$\n此时简化舍入后的结果, 获得的最大浮点误差如下.\n$$ \\begin{equation} 4 \\epsilon_m |a + b| + 3 \\epsilon_m |c| + 2 \\epsilon_m |d| \\end{equation} $$\n上述方法被称为前向误差分析, 也可以通过判断输入得到同一个输出的输入范围来进行后向误差分析, 这不是很适用于几何计算.\n下述不等式具有更精确的上界.\n$$ \\begin{equation} \\begin{aligned} (1 \\pm \\epsilon_m)^n \\le 1 + \\gamma_n\\\\ \\gamma_n = \\frac{n \\epsilon_m}{1 - n \\epsilon_m} \\end{aligned} \\end{equation} $$\n可以用上式来表示计算时输入本身所带有的误差, 对于乘法和加法可得如下结果, 可以看出乘法的误差比加法小很多, 且当加法输入绝对值相近但符号相反时误差会很大, 这种现象被称为灾难性抵消.\n$$ a(1 \\pm \\gamma_i) \\otimes b(1 \\pm \\gamma_j) \\in ab(1 \\pm \\gamma_{i + j + 1})\\\\ \\delta_r = \\gamma_{i+j+1} $$\n$$ a(1 \\pm \\gamma_i) \\oplus b(1 \\pm \\gamma_j) \\in a(1 \\pm \\gamma_{i+1}) + b(1 \\pm \\gamma_{j+1})\\\\ \\delta_r = \\frac{|a|\\gamma_{i+1} + |b|\\gamma_{j+1}}{a + b} $$\n误差分析 # pbrt通过Interval类提供误差分析的功能, 每次执行运算时它都会执行误差区间累积的计算.\n保守光线-包围结构相交 # 光线相交计算的误差如下. 若\\(t_{\\min}\\)与\\(t_{\\max}\\)的误差区间重合, pbrt会给\\(t_{\\max}\\)增加\\(2 \\gamma_3 t_{\\max}\\)来保守的确定光线与物体相交.\n$$ \\begin{equation} \\begin{aligned} t = (x \\ominus o_x) \u0026amp;\\otimes (1 \\oslash \\bold{d}_x) \\in \\frac{x - o_x}{\\bold{d}_x}(1 \\pm \\epsilon)^3\\\\ \\frac{x - o_x}{\\bold{d}_x} \u0026amp;\\in t (1 \\pm \\gamma_3)\\\\ \\delta_r \u0026amp;= \\gamma_3 |t| \\end{aligned} \\end{equation} $$\n精确二次方程判别式 # 球和圆柱等物体的相交计算需要用到二次方程判别式\\(b^2 - 4ac\\), 当物体较远时若\\(b^2 \\approx 4ac\\)会导致灾难性抵消现象的出现.\n球体和圆柱体的二次方程判别式可以转为如下形式, 此时不再需要计算\\(c\\), 因此误差更小.\n$$ \\begin{equation} \\begin{aligned} b^2 - 4ac \u0026amp;= 4a\\left(\\frac{b^2}{4a} - c\\right)\\\\ \u0026amp;= 4a\\left((\\bold{o} \\cdot \\hat{\\bold{d}})^2 - (\\bold{o} \\cdot \\bold{o}) + r^2\\right)\\\\ \u0026amp;= 4a\\left(-\\Vert \\bold{o} - \\frac{b}{2a}\\bold{d} \\Vert^2 + r^2\\right) \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} b^2 - 4ac = 4a \\left(r^2 - \\Vert \\bold{o_{xy}} - \\frac{b}{2a} \\bold{d_{xy}} \\Vert^2\\right) \\end{equation} $$\n稳定三角形相交 # 由于边方程只需要判断符号, 浮点误差的影响不大. 对于边方程为0的情况暂时没有很好的精度误差检查方法, 需要用double重新计算, 实际使用中几乎不可能有这种情况.\n边界交点误差 # 若\\(t\\)本身带有误差, 光线相交的绝对误差如下.\n$$ \\begin{equation} \\delta_a = \\gamma_1|o_x|+\\delta_t(1 + \\gamma_2)|\\bold{d_x}|+\\gamma_2|t_{\\text{hit}}\\bold{d_x}| \\end{equation} $$\n二次曲面重投影 # 计算出与二次曲面的交点后可以进行重投影来减小误差, 例如下式中对于球面可以通过半径来重投影, 误差为\\(\\gamma_5\\). 圆柱只需要在\\(xy\\)上投影, 误差为\\(\\gamma_3\\). 圆盘由于只需要设置\\(z\\)值, 它相当于是没有误差的.\n$$ \\begin{equation} x' = x \\frac{r}{x^2 + y^2 + z^2} \\end{equation} $$\n三角形参数评估 # 采用边方程计算重心坐标后再进行插值的误差如下.\n$$ \\begin{equation} \\delta_a = \\gamma_7(|b_0x_0| + |b_1x_1| + |b_2x_2|) \\end{equation} $$\n双线性片参数评估 # 双线性插值误差如下.\n$$ \\begin{equation} \\gamma_6(|x_{0,0}|+|x_{0,1}|+|x_{1,0}|+|x_{1,1}|) \\end{equation} $$\n曲线参数评估 # 为避免离开曲线的光线与其重新相交, 误差会被设置为曲线的宽度, 若曲线宽度过宽用双线性片来代替是更好的选择.\n变换误差 # 变换后的\\(x\u0026rsquo;\\)误差如下, 下式分别是原值不包括和包括误差的情况.\n$$ \\begin{equation} \\gamma_3(|m_{0,0}x|+|m_{0,1}y|+|m_{0,2}|z+|m_{0,3}|) \\end{equation} $$\n$$ \\begin{equation} (\\gamma_3+1)(|m_{0,0}|\\delta_x + |m_{0,1}|\\delta_y + |m_{0,2}|\\delta_z) + \\gamma_3(|m_{0,0}x| + |m_{0,1}y| + |m_{0,2}z| + |m_{0,3}|) \\end{equation} $$\n稳定生成光线起点 # 我们需要将某个面附近的光线起点沿着法线移动, 使得它位于交点的误差范围之外, 以此使用最小的偏移量避免错误的相交, 保证了阴影, 反射等效果的质量. 偏移向量定义如下, 为避免向下舍入pbrt会将值移动一个ulp.\n$$ \\begin{equation} \\bold{n} \\cdot (\\delta_x, \\delta_y, \\delta_z) \\end{equation} $$\nfor (int i = 0; i \u0026lt; 3; ++i) { if (offset[i] \u0026gt; 0) po[i] = NextFloatUp(po[i]); else if (offset[i] \u0026lt; 0) po[i] = NextFloatDown(po[i]); } 在阴影与光源求交的计算中有可能因为距离光源过近的物体导致错误相交, pbrt通过提前停止来求交来简单的处理.\nconstexpr Float ShadowEpsilon = 0.0001f; 为避免变换带来的误差, 每次变换中光线起点都会移动到误差边界.\nif (Float lengthSquared = LengthSquared(d); lengthSquared \u0026gt; 0) { Float dt = Dot(Abs(d), o.Error()) / lengthSquared; o += d * dt; if (tMax) *tMax -= dt; } 避免光线起点后方的相交 # 由于误差实际为负的\\(t\\)值可能计算结果为正, 对于部分形状pbrt实现了高效的保守误差分析.\n三角形 # 采用边方程重心坐标计算出的\\(t\\)误差如下, 若不超过这个值则认为交点在后方.\n$$ \\begin{equation} \\begin{aligned} \\delta_e \u0026amp;= 2(\\gamma_2 \\max_i|x_i|\\max_i|y_i| + \\delta_y\\max_i|x_i|+\\delta_x\\max_i|y_i|)\\\\ \\delta_t \u0026amp;= 3(\\gamma_3 \\max_i|e_i||z_i| + \\delta_e\\max_i|z_i|+\\delta_z\\max_i|e_i|) \\end{aligned} \\end{equation} $$\n双线性片 # pbrt通过计算一个简单的\\(\\epsilon\\)来解决后方相交误差.\n$$ \\begin{equation} \\begin{aligned} c_{\\max}(\\bold{v}) \u0026amp;= \\max(\\bold{v_x}, \\bold{v_y}, \\bold{v_z})\\\\ \\epsilon \u0026amp;= \\gamma_10 (c_{\\max}(|\\bold{o}|) + c_{\\max}(|\\bold{d}|)\\\\ \u0026amp;+ c_{\\max}(|\\bold{p_{0,0}}|)+ c_{\\max}(|\\bold{p_{0,1}}|)\\\\ \u0026amp;+ c_{\\max}(|\\bold{p_{1,0}}|)+ c_{\\max}(|\\bold{p_{1,1}}|)) \\end{aligned} \\end{equation} $$\n","date":"2024 November 5","externalUrl":null,"permalink":"/render/1730785503440-pbrt-v4-episode-6/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. VI: 几何形状","type":"render"},{"content":" 相机接口 # pbrt的相机接口生成的样本包括time成员, 用于模拟在相机快门打开这一时间段的不同时刻抵达的光线. 这给Monte Carlo增加了一个维度, 采样\\((0,1)\\)均匀分布即可.\npbrt的相机接口支持修改图片元数据, 最终会写入硬盘.\n坐标空间 # 光栅化渲染器通常使用相机空间作为渲染空间来裁掉视锥空间以外的物体, 光追渲染器则以世界空间为主, 这保证了基于轴对齐包围盒的加速结构的有效性,但世界空间很容易带来浮点精度问题. pbrt采用相机世界空间, 即原点位于相机但是坐标轴与世界空间对齐.\npbrt的相机保留以下两个变换, 通过修改renderFromCamera来渲染运动物体, 否则修改worldFromRender会影响包围盒的构建, 因为运动物体的包围盒需要考虑运动范围. 这两个变换从场景指定的worldFromCamera分解出来.\nAnimatedTransform renderFromCamera; Transform worldFromRender; 基类 # 基类CameraBase在GenerateRayDifferential实现了光线微分的计算, 通过多次调用GenerateRay来实现. 该函数计算dx与dy, 为防止超出图像范围, 正负两侧都会尝试计算. 由于pbrt不使用虚函数, 派生类需要实现相关函数并把this传入.\npstd::optional\u0026lt;CameraRayDifferential\u0026gt; CameraBase::GenerateRayDifferential( Camera camera, CameraSample sample, SampledWavelengths \u0026amp;lambda) { // Generate regular camera ray _cr_ for ray differential pstd::optional\u0026lt;CameraRay\u0026gt; cr = camera.GenerateRay(sample, lambda); if (!cr) return {}; RayDifferential rd(cr-\u0026gt;ray); // Find camera ray after shifting one pixel in the $x$ direction pstd::optional\u0026lt;CameraRay\u0026gt; rx; for (Float eps : {.05f, -.05f}) { CameraSample sshift = sample; sshift.pFilm.x += eps; // Try to generate ray with _sshift_ and compute $x$ differential if (rx = camera.GenerateRay(sshift, lambda); rx) { rd.rxOrigin = rd.o + (rx-\u0026gt;ray.o - rd.o) / eps; rd.rxDirection = rd.d + (rx-\u0026gt;ray.d - rd.d) / eps; break; } } // Find camera ray after shifting one pixel in the $y$ direction pstd::optional\u0026lt;CameraRay\u0026gt; ry; for (Float eps : {.05f, -.05f}) { CameraSample sshift = sample; sshift.pFilm.y += eps; if (ry = camera.GenerateRay(sshift, lambda); ry) { rd.ryOrigin = rd.o + (ry-\u0026gt;ray.o - rd.o) / eps; rd.ryDirection = rd.d + (ry-\u0026gt;ray.d - rd.d) / eps; break; } } // Return approximate ray differential and weight rd.hasDifferentials = rx \u0026amp;\u0026amp; ry; return CameraRayDifferential{rd, cr-\u0026gt;weight}; } 投影相机 # 光追渲染器只通过投影矩阵生成光线, 不考虑光栅化渲染中常见的裁剪问题.\n正交投影 # 正交投影的性质使得光线微分只需要考虑光线原点的位移.\n透视投影 # 略.\n薄镜头模型 # 现实里的小孔成像模型需要长时间的曝光, 会导致严重的动态模糊. 真实镜头系统可以调节光圈, 光圈小则物体清晰但进光量小, 否则远处物体模糊但进光量大. pbrt通过RealisticCamera实现薄镜头模型近似, 通过传统投影模型来模拟真实镜头, 镜头厚度相较于镜头曲率具有较小的值. pbrt遵循高斯镜头公式, 距离焦距过远会导致弥散圆, 弥散圆的半径可以根据三角形的相似性计算. 镜头光圈大小通常通过焦距与镜头半径的比值来表示, 即f-stop值.\n$$ \\frac{1}{z^\u0026rsquo;} = \\frac{1}{z} + \\frac{1}{f} $$\n对于薄镜头模型, pbrt首先计算成像点与镜头中心形成的光线与对焦平面的交点, 由于所有经过透镜到达当前成像点的光线都需要经过该点, 因此只需要圆盘采样镜头上的位置与该点形成一条新的光线, 此时可以获得景深效果.\n球形相机 # pbrt通过SphericalCamera实现球形相机, 采用球面坐标采样, 可以通过等效矩形投影或等面积投影获取渲染图像.\n胶片成像 # 相机测量方程 # 将基于立体角积分的辐射照度转换为基于面积的积分, 该式可用于积分计算镜头后切面上各个点发出的辐射亮度汇聚到胶片上某点后形成的辐射照度, 其中\\(z_f\\)是胶片到镜头的距离. 对于镜头半径与镜头距离的比值较大的镜头系统, \\(\\cos\\theta\\)可以有效的降低边缘光线的影响, 现代摄像机会有意的增加边缘光线的贡献度.\n$$ \\begin{equation} d\\omega = \\frac{dA\\cos\\theta}{r^2} \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} E(p) \u0026amp;= \\int_{A_e} L_i(p, p\u0026rsquo;) \\frac{|\\cos\\theta \\cos\\theta\u0026rsquo;|}{\\Vert p\u0026rsquo; - p \\Vert^2} dA_e\\\\ \u0026amp;= \\frac{1}{z^2_f} \\int_{A_e} L_i(p, p\u0026rsquo;) |\\cos\\theta|^4 dA_e \\end{aligned} \\end{equation} $$\n在时间上对辐射照度进行积分可以获得辐射曝光度.\n$$ \\begin{equation} H(p) = \\int_{t_0}^{t_1} \\frac{1}{z^2_f} \\int_{A_e} L_i(p, p\u0026rsquo;, t\u0026rsquo;) |\\cos\\theta|^4 dA_e dt' \\end{equation} $$\n在感光单元面积上进行积分即可获取相机测量方程, 获取的积分值为感光元件所接收到的能量.\n$$ \\begin{equation} J = \\int_{A_p} \\int_{t_0}^{t_1} \\frac{1}{z^2_f} \\int_{A_e} L_i(p, p\u0026rsquo;, t\u0026rsquo;) |\\cos\\theta|^4 dA_e dt\u0026rsquo; dA_p \\end{equation} $$\n感光元件感应建模 # 感光元件捕捉到的值可以通过光谱感应曲线计算, 由于人眼对绿色更敏感, 相机胶片中绿色感光元件的数量通常为红色与蓝色的两倍.\n相机胶卷通常会设置ISO值, 高ISO值需要较少的时间来记录像素值. 在数码相机上会调整相机增益, 也就是直接给原始像素乘上某个值. 通常调高ISO值会带来更多的噪点.\n现代相机可能会按照扫描线的方式捕获图像, 需要多次打开快门, 这可能会导致动态环境下错误的渲染结果.\npbrt不会模拟噪点, 马赛克, 泛光这些现象, ISO可以用于调整曝光.\npbrt通过PixelSensor类来定义感光元件, 用于控制曝光, RGB响应与白平衡. 由于pbrt有小孔相机等理想模型, pbrt会特殊处理他们, 否则像小孔相机就会因为曝光量过小导致全黑的图像. 对于真实相机, 在生成相机样本时会考虑每个光线的权重, 前文薄镜头模型有提到. 光圈大小由相机类负责, 因此感光元件类只需要考虑ISO与快门时间, 这两个值构成了图像比率imagingRatio.\nPixelSensor的构造需要RGB响应方程, 图像比率, 色彩空间与标准光源. 记录像素的色彩空间与输出图像的色彩空间未必是相同的, 前者由感光元件本身的性质决定, 后者与设备无光, 因此需要计算转换到XYZ空间的变换矩阵, pbrt通过积分计算在当前设定的标准光源与响应方程下各类反照率在RGB与XYZ空间下的颜色, 然后通过最小二乘法获取变换矩阵.\nPixelSensor(Spectrum r, Spectrum g, Spectrum b, const RGBColorSpace *outputColorSpace, Spectrum sensorIllum, Float imagingRatio, Allocator alloc) : r_bar(r, alloc), g_bar(g, alloc), b_bar(b, alloc), imagingRatio(imagingRatio) { // Compute XYZ from camera RGB matrix // Compute _rgbCamera_ values for training swatches Float rgbCamera[nSwatchReflectances][3]; for (int i = 0; i \u0026lt; nSwatchReflectances; ++i) { RGB rgb = ProjectReflectance\u0026lt;RGB\u0026gt;(swatchReflectances[i], sensorIllum, \u0026amp;r_bar, \u0026amp;g_bar, \u0026amp;b_bar); for (int c = 0; c \u0026lt; 3; ++c) rgbCamera[i][c] = rgb[c]; } // Compute _xyzOutput_ values for training swatches Float xyzOutput[24][3]; Float sensorWhiteG = InnerProduct(sensorIllum, \u0026amp;g_bar); Float sensorWhiteY = InnerProduct(sensorIllum, \u0026amp;Spectra::Y()); for (size_t i = 0; i \u0026lt; nSwatchReflectances; ++i) { Spectrum s = swatchReflectances[i]; XYZ xyz = ProjectReflectance\u0026lt;XYZ\u0026gt;(s, \u0026amp;outputColorSpace-\u0026gt;illuminant, \u0026amp;Spectra::X(), \u0026amp;Spectra::Y(), \u0026amp;Spectra::Z()) * (sensorWhiteY / sensorWhiteG); for (int c = 0; c \u0026lt; 3; ++c) xyzOutput[i][c] = xyz[c]; } // Initialize _XYZFromSensorRGB_ using linear least squares pstd::optional\u0026lt;SquareMatrix\u0026lt;3\u0026gt;\u0026gt; m = LinearLeastSquares(rgbCamera, xyzOutput, nSwatchReflectances); if (!m) ErrorExit(\u0026#34;Sensor XYZ from RGB matrix could not be solved.\u0026#34;); XYZFromSensorRGB = *m; } PixelSensor的ToSensorRGB通过Monte Carlo计算出某种光谱分布在感光元件上的RGB值, 并乘上imagingRatio来矫正最终得到的结果.\nRGB ToSensorRGB(SampledSpectrum L, const SampledWavelengths \u0026amp;lambda) const { L = SafeDiv(L, lambda.PDF()); return imagingRatio * RGB((r_bar.Sample(lambda) * L).Average(), (g_bar.Sample(lambda) * L).Average(), (b_bar.Sample(lambda) * L).Average()); } 色彩适应与白平衡 # 由于色彩适应, 在不同的光照条件下人眼可以看到一致的颜色, 相机也会实现色彩适应的过程以保证获取与拍摄者观察到的结果相一致. pbrt实现了von Kries算法, 即计算当前光源与目标光源在LMS空间下的值, 将目标LMS与源LMS的比值赋给矩阵的对角线即可获取色彩适应矩阵.\n感光元件响应采样 # 直接使用Y响应曲线采样由于峰值较为集中会导致噪点过多, 使用X,Y,Z响应曲线之和采样会导致采样点集中在人眼不敏感的波长. pbrt采用的概率分布实现了二者的平衡, 其中\\(A=0.0072\\text{nm}^{-1}\\), \\(B=538\\text{nm}\\), 波长采样范围为\\([360, 830]\\text{nm}\\).\n$$ \\begin{equation} \\begin{aligned} p_v(\\lambda) \u0026amp;= (\\int_{\\lambda_{\\min}}^{\\lambda_{\\max}} f(\\lambda) d\\lambda)^{-1} f(\\lambda)\\\\ f(\\lambda) \u0026amp;= (\\cosh^2 (A(\\lambda - B)))^{-1} \\end{aligned} \\end{equation} $$\n图像样本滤波 # 对于滤波函数\\(f\\)与图像函数\\(r\\), 滤波可以表示为以下形式, 所有像素的样本都可以影响滤波结果.\n$$ \\begin{equation} r_f(x,y) = \\int f(x - x\u0026rsquo;, y - y\u0026rsquo;) r(x\u0026rsquo;, y\u0026rsquo;) dx\u0026rsquo; dy' \\end{equation} $$\n通常认为每个点的贡献是相同的, 因此离散形式可以简化, \\(A\\)为胶片面积.\n$$ \\begin{equation} r_f(x,y) \\approx \\frac{1}{n} \\sum_i^n frac{f(x - x_i, y - y_i) r(x_i, y_i)}{p(x_i, y_i)} \\end{equation} $$\n$$ \\begin{equation} r_f(x,y) \\approx \\frac{A}{n} \\sum_i^n f(x - x_i, y - y_i) r(x_i, y_i) \\end{equation} $$\n上式为无偏估计, 但样本较少时会产生估计错误, 例如图像方程为常数时由于滤波函数的和不为\\(1\\)导致错误的结果, 通常使用归一化的离散估计.\n$$ \\begin{equation} r_f(x,y) \\approx \\frac{\\sum_i f(x - x_i, y - y_i) r(x_i, y_i)}{\\sum_i f(x - x_i, y - y_i)} \\end{equation} $$\n将滤波函数作为概率密度函数可以实现重要性滤波, 只需要使用当前像素的样本的性质提高了并发效率. 此时\\(p \\propto f\\), 二者可以相互抵消. 考虑到滤波函数为负的情况, 最终可以表示为如下形式.\n$$ \\begin{equation} r_f(x,y) \\approx (\\int |f(x\u0026rsquo;,y\u0026rsquo;)| dx\u0026rsquo; dy\u0026rsquo;)(\\frac{1}{n} \\sum_i^n \\text{sign}(f(x - x_i, y - y_i)) r(x_i, y_i)) \\end{equation} $$\n由于同样的原因pbrt采用归一化的估计.\n$$ \\begin{equation} \\begin{aligned} r_f(x,y) \u0026amp;\\approx \\frac{\\sum_i w(x - x_i, y - y_i) r(x_i, y_i)} {\\sum_i w(x - x_i, y - y_i)}\\\\ w(x,y) \u0026amp;= \\frac{f(x,y)}{p(x,y)} \\end{aligned} \\end{equation} $$\n胶片接口 # 光线传播算法要求将光线的贡献溅射到相邻像素中, pbrt在Film类中定义了AddSplat接口. 与AddSample不同, AddSplat是线程安全的.\nRGBFilm # RGBFilm类记录用RGB表示的图像, 因此构造函数需要传入色彩空间, 同时会计算与感光元件的色彩空间的变换. 为保证样本较多时的权重求和精度, RGBFilm采用double存储, 尽管这种情况十分罕见.\n为避免高亮噪点, 或者说萤火虫像素, RGBFilm中会截断RGB值, 尽管会带来能量损失, 这有效的提升了图像质量.\nFloat m = std::max({rgb.r, rgb.g, rgb.b}); if (m \u0026gt; maxComponentValue) rgb *= maxComponentValue / m; RGBFilm通过滤波的半径来决定溅射范围, 根据滤波函数决定溅射值的权重.\nPBRT_CPU_GPU void RGBFilm::AddSplat(Point2f p, SampledSpectrum L, const SampledWavelengths \u0026amp;lambda) { CHECK(!L.HasNaNs()); // Convert sample radiance to _PixelSensor_ RGB RGB rgb = sensor-\u0026gt;ToSensorRGB(L, lambda); // Optionally clamp sensor RGB value Float m = std::max({rgb.r, rgb.g, rgb.b}); if (m \u0026gt; maxComponentValue) rgb *= maxComponentValue / m; // Compute bounds of affected pixels for splat, _splatBounds_ Point2f pDiscrete = p + Vector2f(0.5, 0.5); Vector2f radius = filter.Radius(); Bounds2i splatBounds(Point2i(Floor(pDiscrete - radius)), Point2i(Floor(pDiscrete + radius)) + Vector2i(1, 1)); splatBounds = Intersect(splatBounds, pixelBounds); for (Point2i pi : splatBounds) { // Evaluate filter at _pi_ and add splat contribution Float wt = filter.Evaluate(Point2f(p - pi - Vector2f(0.5, 0.5))); if (wt != 0) { Pixel \u0026amp;pixel = pixels[pi]; for (int i = 0; i \u0026lt; 3; ++i) pixel.rgbSplat[i].Add(wt * rgb[i]); } } } GBufferFilm # 与实时渲染类似, GBufferFilm在颜色信息之外会存储与当前像素对应的光线相交的物体的几何信息, 以下是GBufferFilm中的Pixel的定义.\n// GBufferFilm::Pixel Definition struct Pixel { Pixel() = default; double rgbSum[3] = {0., 0., 0.}; double weightSum = 0., gBufferWeightSum = 0.; AtomicDouble rgbSplat[3]; Point3f pSum; Float dzdxSum = 0, dzdySum = 0; Normal3f nSum, nsSum; Point2f uvSum; double rgbAlbedoSum[3] = {0., 0., 0.}; VarianceEstimator\u0026lt;Float\u0026gt; rgbVariance[3]; }; ","date":"2024 November 4","externalUrl":null,"permalink":"/render/1730695131466-pbrt-v4-episode-5/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. V: 相机模型","type":"render"},{"content":" 辐射度量学研究光的表示与传播, pbrt通过光谱而非RGB来表示颜色.\n辐射度量学 # 几何光学足够用于完成渲染任务, 主要损失在于无法模拟干涉与衍射. 几何光学具有以下特征.\n线性 能量守恒 无偏振 无荧光、磷光, 即光在某个波长下的表现与别的波长或时间下的表现无关 状态稳定, 即辐射亮度分布不随时间变化 基本量 # 能量 # 光源发出光子, 光子携带能量. 能量单位为焦耳(J), 特定波长的光子携带的能量如下式. 其中c为光速, h为Planck常量, \\(h = 6.626\\times 10^{-34} m^2 kg/s\\).\n$$ \\begin{equation} Q = \\frac{hc}{\\lambda} \\end{equation} $$\n辐射通量 # 辐射通量是(radiant flux)单位时间通过表面或空间的能量, 也可以被称作功率(power), 单位为J/s, 即瓦特(W). 辐射通量的定义见下式.\n$$ \\begin{equation} \\Phi = \\frac{dQ}{dt} \\end{equation} $$\n对于一个点光源, 辐射通量为以光源为球心的球面单位时间接收到的能量, 球的半径不影响辐射通量的值.\n辐射照度 \u0026amp; 辐射出射度 # 辐射照度(irradiance)是单位面积接收到的辐射通量, 与之对应的辐射出射度(radiant exitance)是单位面积发出的辐射通量, 他们的单位为\\(W/m^2\\).\n$$ \\begin{equation} E(p) = \\frac{d\\Phi}{dA} \\end{equation} $$\n同样以点光源为例, 以光源为球心的球面的辐射照度见下式.\n$$ \\begin{equation} E = \\frac{\\Phi}{4 \\pi r^2} \\end{equation} $$\n非垂直光线根据投影到光线垂直面的面积计算, \\(\\theta\\)为光线与法线的夹角.\n$$ \\begin{equation} E(p) = \\frac{d\\Phi \\cos\\theta}{dA} \\end{equation} $$\n辐射强度 # 辐射强度(radiant intensity)是单位立体角上的辐射通量, 它描述了光在方向上的分布, 但实际上只对点光源有意义.\n$$ \\begin{equation} I = \\frac{dQ}{d\\omega} \\end{equation} $$\n以点光源为球心的球面的辐射强度见下式.\n$$ \\begin{equation} I = \\frac{\\Phi}{4 \\pi} \\end{equation} $$\n辐射亮度 # 辐射亮度(radiance)是在单位面积的单位立体角上的辐射通量, 即将辐射照度进一步在每个方向上微分. 辐射亮度定义见下式, 其中\\(E_{\\omega}\\)代表与\\(\\omega\\)垂直的表面的辐射照度.\n$$ \\begin{equation} L(p, \\omega) = \\frac{E_{\\omega}(p)}{d\\omega} = \\frac{d^2\\Phi}{d\\omega dA^{\\perp}} = \\frac{d^2\\Phi}{d\\omega dA \\cos\\theta} \\end{equation} $$\n由于随着传播范围增大, 单位面积的辐射通量减小, 但同时它所占的立体角也减小, 因此光在真空中传播时具有辐射亮度不变的特性.\n入射/出射辐射方程 # 辐射亮度在表面边界处未必是连续的, 表面某点上方与下方的极限值需要单独表示.\n$$ \\begin{equation} L^+(p,\\omega)=\\lim_{t \\to 0^+} L(p + t \\bold{n}_p, \\omega) \\end{equation} $$\n$$ \\begin{equation} L^-(p,\\omega)=\\lim_{t \\to 0^-} L(p - t \\bold{n}_p, \\omega) \\end{equation} $$\n为解决这一问题需要区分入射与出射辐射亮度.\n$$ \\begin{equation} L_i(p, \\omega) = \\begin{cases} L^+(p, -\\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026gt; 0\\\\ L^-(p, -\\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026lt; 0 \\end{cases} \\end{equation} $$\n$$ \\begin{equation} L_i(p, \\omega) = \\begin{cases} L^+(p, \\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026gt; 0\\\\ L^-(p, \\omega), \u0026amp; \\omega \\cdot \\bold{n}_p \u0026lt; 0 \\end{cases} \\end{equation} $$\n对于空间中不在表面上的某点, 辐射亮度是连续的.\n$$ \\begin{equation} L_o(p, \\omega) = L_i(p, -\\omega) = L(p, \\omega) \\end{equation} $$\n辐射光谱分布 # 辐射亮度可以进一步对波长微分以获取辐射光谱分布.\n$$ \\begin{equation} L_\\lambda = \\frac{dL}{d\\lambda} \\end{equation} $$\n亮度与光度 # 辐射度单位都有与之对应的光度单位, 这里只讨论最基本的亮度, 其余可以积分得到. 亮度表示人眼观察到的某个光谱功率分布的值, 定义如下. V为响应曲线即人眼对各个波长的光的敏感程度, 目前所使用的响应曲线是基于室内的实验得到的, 人眼在较暗环境对颜色的敏感度会降低, 因此无法很好的表示室外光照环境, 但仍然将其作为研究基准.\n$$ \\begin{equation} Y = \\int_{\\lambda} L_\\lambda(\\lambda) V(\\lambda) d\\lambda \\end{equation} $$\n辐射度量值的积分 # 从辐射亮度到辐射照度的积分如图所示, 其中\\(\\Omega\\)是法线上方半球覆盖的立体角, \\(\\theta\\)是立体角在单位球上对应的向量与法线的夹角.\n$$ \\begin{equation} E(p, \\bold{n}) = \\int_\\Omega L_i(p,\\omega) |\\cos\\theta| d\\omega \\end{equation} $$\n投影立体角上的积分 # 通过将单位球上的立体角投影到与法线垂直的平面可以转化为2D上的积分, 投影立体角与立体角满足Lambert定律. pbrt不会使用这种积分.\n$$ \\begin{equation} \\begin{aligned} d\\omega^{\\perp} \u0026amp;= d\\omega|cos\\theta|\\\\ E(p, \\bold{n}) \u0026amp;= \\int_{H^2(\\bold{n})} L_i(p,\\omega) d\\omega^{\\perp} \\end{aligned} \\end{equation} $$\n球面坐标系上的积分 # 利用单位球表面积可以将立体角微分转化为球面坐标系.\n$$ \\begin{equation} \\begin{aligned} d\\omega \u0026amp;= sin\\theta d\\theta d\\phi\\\\ E(p, \\bold{n}) \u0026amp;= \\int_0^{2\\pi} \\int_0^{\\frac{\\pi}{2}} L_i(p, \\theta, \\phi) cos\\theta sin\\theta d\\theta d\\phi \\end{aligned} \\end{equation} $$\n面积上的积分 # 这里的面积指的是立体角对应的入射光源处的面积, 这种转化可以方便度量面积光源对某一点的影响. \\(\\theta_o\\)是这个面积位于的平面与立体角对应的向量的夹角, r是这个表面与辐射照度度量点的距离.\n$$ \\begin{equation} \\begin{aligned} d\\omega \u0026amp;= \\frac{\\cos\\theta_o dA}{r^2}\\\\ E(p, \\bold{n}) \u0026amp;= \\int_{A} L cos\\theta_i \\frac{\\cos\\theta_o dA}{r^2} \\end{aligned} \\end{equation} $$\n表面反射 # 我们需要反射光线的光谱与方向分布来描述反射, 对于透明物体更复杂的次表面光线传播会影响出射光线的位置. 渲染任务中通过BRDF与BSSRDF来抽象这一过程, BRDF描述反射, BSSRDF在此基础上考虑透明物体.\nBRDF # BRDF代表双向反射分布函数, 它描述出射辐射亮度与入射辐射照度的关系.\n$$ \\begin{equation} f_r(p, \\omega_o, \\omega_i) = \\frac{dL_o(p, \\omega_o)}{dE(p, \\omega_i)} = \\frac{dL_o(p, \\omega_o)}{L_i(p, \\omega_i) \\cos\\theta_i d\\omega_i} \\end{equation} $$\nBRDF具有以下两点性质.\n互易性 $$ \\begin{equation} f_r(p, \\omega_o, \\omega_i) = f_r(p, \\omega_i, \\omega_o) \\end{equation} $$\n能量守恒 $$ \\begin{equation} \\int_\\Omega f_r(p, \\omega_o, \\omega_i) cos\\theta_i d\\omega_i \u0026lt; 1 \\end{equation} $$\nBRDF的半球-方向反射量可以用于表示入射光从所有方向均匀照射时某个方向的反射辐射亮度, 由于互易性也可以表示各个方向都具有相同的反射辐射亮度时对应的某个方向的入射辐射亮度.\n$$ \\begin{equation} \\rho_{hd}(\\omega_o) = \\int_\\Omega f_r(p, \\omega_o, \\omega_i) cos\\theta_i d\\omega_i \\end{equation} $$\nBRDF的半球-半球反射量代表入射光从所有方向均匀照射时的反射率.\n$$ \\begin{equation} \\rho_{hh} = \\int_\\Omega \\frac{\\int_\\Omega f_r(p, \\omega_o, \\omega_i) \\cos\\theta_i d\\omega_i}{\\int_\\Omega \\cos\\theta_i d\\omega_i} \\cos\\theta_o d\\omega_o \\end{equation} $$\nBTDF # BTDF代表双向透射分布函数, 与BRDF具有相似的形式, 它不遵循互易性.\nBSDF # 将BRDF与BTDF一起考虑时被称为BSDF, 即双向散射分布函数, 此时可以使用整个球面的入射光线计算出射方向的辐射亮度.\n$$ \\begin{equation} L_o(p, \\omega_o) = \\int_\\Theta f(p, \\omega_o, \\omega_i) L_i(p, \\omega_i) |\\cos\\theta_i| d\\omega_i \\end{equation} $$\nBSSRDF # BSSRDF代表双向散射表面反射分布函数, 时出射位置辐射亮度微分与入射位置辐射通量微分的比值, 用于表示光线在表面内部传播再后离开表面的现象, 即次表面散射.\n$$ \\begin{equation} S(p_o, \\omega_o, p_i, \\omega_i) = \\frac{dL_o(p_o, \\omega_o)}{d\\Phi(p_i, \\omega_i)} \\end{equation} $$\n出射辐射亮度需要计算在入射立体角与面积上的积分.\n$$ \\begin{equation} L_o(p_o, \\omega_o) = \\int_A \\int_\\Omega S(p_o, \\omega_o, p_i, \\omega_i) L_i(p_i, \\omega_i) |\\cos\\theta_i| d\\omega_i dA \\end{equation} $$\n自发光 # 达到一定温度后带电荷的原子的运动会导致不同波长的电磁辐射的释放, 室温下大部分物体只发射红外光.\n发光效率代表光源将多少功率转化为可见光, 单位lm/W. 分母可以是光源使用的功率或发出的所有波长上的功率, 若为使用功率, 则发光效率也代表光源将功率转化为电磁辐射的效率.\n此外, 光出射度与辐射照度在单位面积上的比值或出射亮度与辐射亮度在单位面积单位立体角上的比值也可以定义发光效率.\n$$ \\begin{equation} \\frac{\\int_\\lambda \\Phi_e(\\lambda) V(\\lambda) d\\lambda}{\\int_\\lambda \\Phi_i(\\lambda) d\\lambda} \\end{equation} $$\n黑体发光 # 黑体是一种理想发光光源, 可以最高效率的将功率转化为电磁辐射. 黑体这个名字是因为它几乎吸收所有波长的光线且不会反射它们.\nPlanck定律表达了黑体中波长、温度与辐射亮度的关系. h为Planck常数, c为光速, \\(k_b\\)为Boltzmann常数, \\(k_b = 1.3806488 \\times 10^{-23} J/K\\).\n$$ \\begin{equation} L_e(\\lambda, T) = \\frac{2hc^2}{\\lambda^5(e^{\\frac{hc}{\\lambda k_b T}} - 1)} \\end{equation} $$\n根据Kirchhoff定律, 非黑体的辐射与它吸收掉的辐射亮度相关, 利用半球-方向反射量可以得到下式.\n$$ \\begin{equation} {L_e}\u0026rsquo;(T, \\omega, \\lambda) = L_e(\\lambda, T)(1 - \\rho_{hd}(\\omega)) \\end{equation} $$\nStefan–Boltzmann定律给出了黑体的辐射出射度, \\(\\sigma\\)为Stefan–Boltzmann常数, \\(\\sigma = 5.67032 \\times 10^{-8} Wm^{-2}K^{-4}\\).\n$$ \\begin{equation} M(p) = \\sigma T^4 \\end{equation} $$\n若发光体发出的光谱分布与某个温度下黑体辐射发出的光谱分布类似, 此时该发光体以该温度作为色温. 通过光源发光最大处的波长与Wien位移定律可以确定当前的色温, b为Wien位移常数, \\(b = 2.897721 \\times 10^{-3}mK\\).\n$$ \\begin{equation} \\lambda_{\\max} = \\frac{b}{T} \\end{equation} $$\n通常5000K以上的色温为冷色, 2700-3000K为暖色.\n标准光源 # 标准光源是由CIE(国际照明委员会)定义的.\n标准光源A用于表示常见的白炽灯, 色温2856K.\n标准光源D用于描述日光的不同阶段, 一个权重用于表示受云量影响的黄蓝变化, 另一个表示受湿度影响的粉绿变化. D65与欧洲中午光照类似, 色温6504K, CIE推荐将它作为标准日光.\n标准光源F用于表示荧光.\n光谱分布 # 本节主要介绍pbrt中对光谱的抽象, 注意这里并不特指辐射光谱分布, 可以是任意值的分布. pbrt只会存储可见光.\nconstexpr Float Lambda_min = 360, Lambda_max = 830; 光谱接口 # pbrt中的Spectrum继承自TaggedPointer来实现运行时多态并避免虚表开销, TaggedPointer中定义的函数子类必须实现.\nclass Spectrum : public TaggedPointer\u0026lt;ConstantSpectrum, DenselySampledSpectrum, PiecewiseLinearSpectrum, RGBAlbedoSpectrum, RGBUnboundedSpectrum, RGBIlluminantSpectrum, BlackbodySpectrum\u0026gt; { // ... }; Spectrum通过函数子返回特定波长下的分布. Dispatch用于确定分派函数到具体实现.\ninline Float Spectrum::operator()(Float lambda) const { auto op = [\u0026amp;](auto ptr) { return (*ptr)(lambda); }; return Dispatch(op); } Spectrum的实现必须提供MaxValue以保证高效的采样.\nFloat MaxValue() const; 通用光谱分布 # ConstantSpectrum # 返回常数值.\nDenselySampledSpectrum # DenselySampledSpectrum存储\\([\\lambda_min, \\lambda_max]\\)下以1nm为区间采样到的值. 这通过采样另一个Spectrum来实现. 显然这种查表方法会分配较大的内存.\nDenselySampledSpectrum(Spectrum spec, int lambda_min = Lambda_min, int lambda_max = Lambda_max, Allocator alloc = {}) : lambda_min(lambda_min), lambda_max(lambda_max), values(lambda_max - lambda_min + 1, alloc) { if (spec) for (int lambda = lambda_min; lambda \u0026lt;= lambda_max; ++lambda) values[lambda - lambda_min] = spec(lambda); } PiecewiseLinearSpectrum # PiecewiseLinearSpectrum定义少量插值点再插值得到各个波长下的值, 对于部分区间比较平滑的分布这可以有效节省内存. 构造函数中会对插值点排序, 读取功率时PiecewiseLinearSpectrum找到对应区间并插值.\nFloat PiecewiseLinearSpectrum::operator()(Float lambda) const { // Handle _PiecewiseLinearSpectrum_ corner cases if (lambdas.empty() || lambda \u0026lt; lambdas.front() || lambda \u0026gt; lambdas.back()) return 0; // Find offset to largest _lambdas_ below _lambda_ and interpolate int o = FindInterval(lambdas.size(), [\u0026amp;](int i) { return lambdas[i] \u0026lt;= lambda; }); DCHECK(lambda \u0026gt;= lambdas[o] \u0026amp;\u0026amp; lambda \u0026lt;= lambdas[o + 1]); Float t = (lambda - lambdas[o]) / (lambdas[o + 1] - lambdas[o]); return Lerp(t, values[o], values[o + 1]); } BlackbodySpectrum # BlackbodySpectrum通过温度构造, 由于黑体光谱中功率过大采样时会通过最大功率值归一化.\nPBRT_CPU_GPU BlackbodySpectrum(Float T) : T(T) { // Compute blackbody normalization constant for given temperature Float lambdaMax = 2.8977721e-3f / T; normalizationFactor = 1 / Blackbody(lambdaMax * 1e9f, T); } PBRT_CPU_GPU Float operator()(Float lambda) const { return Blackbody(lambda, T) * normalizationFactor; } 嵌入光谱数据 # 部分常见的光谱分布可以直接通过字符串获取, 例如DenselySampledSpectrum类型的D65光源.\nSpectrum GetNamedSpectrum(std::string name); 采样光谱分布 # pbrt不提供复杂的积分计算功能, 但是会提供采样函数以执行Monte Carlo积分, 默认采样4个不同的波长.\nSampledSpectrum # SampledSpectrum用于存储多个采样样本.\nexplicit SampledSpectrum(Float c) { values.fill(c); } SampledSpectrum(pstd::span\u0026lt;const Float\u0026gt; v) { for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) values[i] = v[i]; } pbrt提供bool重载使得采样值全为0时可以跳过计算.\nexplicit operator bool() const { for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) if (values[i] != 0) return true; return false; } pbrt支持逐样本数学计算, 例如加法.\nSampledSpectrum \u0026amp;operator+=(const SampledSpectrum \u0026amp;s) { for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) values[i] += s.values[i]; return *this; } SampledWavelengths # SampledWavelengths会存储每个样本的采样波长与概率密度, 与SampledSpectrum分开存储主要是因为SampledSpectrum在渲染过程中(尤其是GPU)需要大量创建, 分离出去可以减小对象的内存占用. 同时, 经过一段时间的开发后, pbrt的作者发现混合不同波长的计算并不会导致bug.\npstd::array\u0026lt;Float, NSpectrumSamples\u0026gt; lambda, pdf; 最基础的均匀采样如下.\nPBRT_CPU_GPU static SampledWavelengths SampleUniform(Float u, Float lambda_min = Lambda_min, Float lambda_max = Lambda_max) { SampledWavelengths swl; // Sample first wavelength using _u_ swl.lambda[0] = Lerp(u, lambda_min, lambda_max); // Initialize _lambda_ for remaining wavelengths Float delta = (lambda_max - lambda_min) / NSpectrumSamples; for (int i = 1; i \u0026lt; NSpectrumSamples; ++i) { swl.lambda[i] = swl.lambda[i - 1] + delta; if (swl.lambda[i] \u0026gt; lambda_max) swl.lambda[i] = lambda_min + (swl.lambda[i] - lambda_max); } // Compute PDF for sampled wavelengths for (int i = 0; i \u0026lt; NSpectrumSamples; ++i) swl.pdf[i] = 1 / (lambda_max - lambda_min); return swl; } 散射可能导致不同波长的光具有不同的传播路径, pbrt支持只保留一个样本继续传播光线. 由于这些样本都遵循相同的分布, pbrt保留第0个样本即可. 类似于俄罗斯轮盘, 保留的样本的概率密度会乘上它在这个过程中存活的概率1 / NSpectrumSamples.\nPBRT_CPU_GPU void TerminateSecondary() { if (SecondaryTerminated()) return; // Update wavelength probabilities for termination for (int i = 1; i \u0026lt; NSpectrumSamples; ++i) pdf[i] = 0; pdf[0] /= NSpectrumSamples; } PBRT_CPU_GPU bool SecondaryTerminated() const { for (int i = 1; i \u0026lt; NSpectrumSamples; ++i) if (pdf[i] != 0) return false; return true; } 颜色 # 与光谱分布相比, 颜色会更多的考虑人眼的感知, 而非单纯的物理量. pbrt基于光谱分布而非颜色, 但是由于处理渲染图像输出、部分场景描述使用颜色来表示反射率等信息等原因, pbrt需要正确的处理颜色与光谱分布的转换.\n三刺激理论中使用三个光谱匹配函数计算得到的刺激值即可表示颜色. 匹配函数是以波长为参数的函数, 值代表某个波长的光对应的刺激值. 某种颜色的光通常由多个波长上的光混合得到, 与匹配函数内积相当于把每个波长上的光转为刺激值后再线性相加. 由于人眼对光刺激的响应是线性的, 在色彩空间中颜色的加法与缩放是允许的, 但是颜色之间并不能相乘, 这也是RGB渲染的问题之一.\n颜色匹配积分如下, S为光谱分布, \\(m_{1,2,3}\\)为三刺激理论中RGB对应的波长各自的匹配函数.\n$$ \\begin{equation} v_i = \\int_\\lambda S(\\lambda)m_i(\\lambda)d\\lambda \\end{equation} $$\nXYZ色彩空间 # CIE通过大量实验定义了RGB色彩空间, 通过将选定的三原色混合来形成所测量的颜色, 根据三种颜色的功率获取对应的当前波长的颜色在色彩匹配函数中的值. 其中R是有负值的, 因为部分颜色无法表示, 需要从相反方向添加红色形成该颜色.\nRGB色度图边缘代表光谱颜色, 即某个波长的光形成的颜色. 非光谱颜色由多个波长的光混合得到, 即对色度图边缘上的点做线性插值. 由于色度图边缘形成凸包, 因此非光谱颜色一定位于色度图的内部.\n由于RGB空间有负值不便于计算, 经过线性变换后得到XYZ色彩空间. XYZ色彩空间是设备无关的, 通常用于色彩空间转换的中介.\nY上的匹配函数在设计时特地与用于计算亮度的光谱响应曲线成正比, 满足\\(V(\\lambda) = 683 Y(\\lambda)\\). pbrt中使用Y归一化后的色彩值, 这使得常数光谱的Y值仍然为相同的常数.\n$$ \\begin{equation} \\begin{aligned} x_\\lambda \u0026amp;= \\frac{\\int_\\lambda S(\\lambda)X(\\lambda)d\\lambda}{\\int_\\lambda Y(\\lambda)d\\lambda}\\\\ y_\\lambda \u0026amp;= \\frac{\\int_\\lambda S(\\lambda)Y(\\lambda)d\\lambda}{\\int_\\lambda Y(\\lambda)d\\lambda}\\\\ z_\\lambda \u0026amp;= \\frac{\\int_\\lambda S(\\lambda)Z(\\lambda)d\\lambda}{\\int_\\lambda Y(\\lambda)d\\lambda} \\end{aligned} \\end{equation} $$\npbrt支持获取X、Y、Z对应的DenselySampledSpectrum类型的光谱分布.\nnamespace Spectra { const DenselySampledSpectrum \u0026amp;X(); const DenselySampledSpectrum \u0026amp;Y(); const DenselySampledSpectrum \u0026amp;Z(); } pbrt支持通过计算积分将光谱分布转化为XYZ空间的颜色.\nXYZ SpectrumToXYZ(Spectrum s) { return XYZ(InnerProduct(\u0026amp;Spectra::X(), s), InnerProduct(\u0026amp;Spectra::Y(), s), InnerProduct(\u0026amp;Spectra::Z(), s)) / CIE_Y_integral; } SampledSpectrum可以通过Monte Carlo转化为XYZ(感觉样本不太够).\nXYZ SampledSpectrum::ToXYZ(const SampledWavelengths \u0026amp;lambda) const { // Sample the $X$, $Y$, and $Z$ matching curves at _lambda_ SampledSpectrum X = Spectra::X().Sample(lambda); SampledSpectrum Y = Spectra::Y().Sample(lambda); SampledSpectrum Z = Spectra::Z().Sample(lambda); // Evaluate estimator to compute $(x,y,z)$ coefficients SampledSpectrum pdf = lambda.PDF(); return XYZ(SafeDiv(X * *this, pdf).Average(), SafeDiv(Y * *this, pdf).Average(), SafeDiv(Z * *this, pdf).Average()) / CIE_Y_integral; } xyY色彩空间 # 颜色可以被分离为亮度(lightness, 不是luminance)与色度(chroma), 色度通过投影到\\(x+y+z=1\\)平面即可得到, 投影后为舌状图.\n$$ \\begin{equation} \\begin{aligned} x \u0026amp;= \\frac{x_\\lambda}{x_\\lambda + y_\\lambda + z_\\lambda}\\\\ y \u0026amp;= \\frac{y_\\lambda}{x_\\lambda + y_\\lambda + z_\\lambda}\\\\ Y \u0026amp;= x_\\lambda + y_\\lambda + z_\\lambda \\end{aligned} \\end{equation} $$\nRGB颜色 # 每个显示器都具有不同的RGB响应曲线, 这代表着显示器三原色的光谱响应特性, 其它颜色都通过三原色的线性相加获取. 在RGB响应曲线已知的情况下, 通过XYZ匹配函数获取原色色度, 根据白点添加色度变换, 即可定义到XYZ空间的色彩变换矩阵.\n$$ \\begin{equation} \\begin{bmatrix} x_\\lambda\\\\ y_\\lambda\\\\ z_\\lambda \\end{bmatrix} = \\begin{pmatrix} \\int_\\lambda R(\\lambda) X(\\lambda)d\\lambda \u0026amp; \\int_\\lambda G(\\lambda) X(\\lambda)d\\lambda \u0026amp; \\int_\\lambda B(\\lambda) X(\\lambda)d\\lambda\\\\ \\int_\\lambda R(\\lambda) Y(\\lambda)d\\lambda \u0026amp; \\int_\\lambda G(\\lambda) Y(\\lambda)d\\lambda \u0026amp; \\int_\\lambda B(\\lambda) Y(\\lambda)d\\lambda\\\\ \\int_\\lambda R(\\lambda) Z(\\lambda)d\\lambda \u0026amp; \\int_\\lambda G(\\lambda) Z(\\lambda)d\\lambda \u0026amp; \\int_\\lambda B(\\lambda) Z(\\lambda)d\\lambda \\end{pmatrix} \\begin{bmatrix} r\\\\ g\\\\ b \\end{bmatrix} \\end{equation} $$\npbrt中通过三刺激值直接得到对应的光谱, 这步是不对的, 代码里没有这么做, 同时矩阵也是反的.\nRGB色彩空间 # 某种响应曲线对应下三原色(R为当前响应曲线下的(1, 0, 0)对应的颜色, G、B同理)的色度在色度图上构成的三角形定义了当前色彩空间的范围. 该色彩空间下三色值为1的颜色在色度图上的色度为白点, 由于人眼感知的问题白色通常在短波具有更高的功率, 一般选用D65作为白点. 根据白点的不同, 需要对色彩空间添加对应的变换.\nRGBColorSpace的构造需要提供三原色的色度以及白点光谱分布. 通过三原色可以确定从XYZ到当前色彩空间的变换矩阵. 白点色度转换首先将白点从XYZ转到当前色彩空间, 然后应用缩放矩阵, 这使得当前色彩空间下的白色\\((1.0, 1.0, 1.0)\\)可以映射到正确的颜色上. 矩阵表达式与构造函数代码如下.\n$$ \\begin{equation} \\begin{bmatrix} w_x \\\\ w_y \\\\ w_z \\\\ \\end{bmatrix} = \\begin{pmatrix} r_x \u0026amp; g_x \u0026amp; b_x\\\\ r_y \u0026amp; g_y \u0026amp; b_y\\\\ r_z \u0026amp; g_z \u0026amp; b_z \\end{pmatrix} \\begin{pmatrix} c_x \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; c_y \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; c_z \\end{pmatrix} \\begin{bmatrix} 1\\\\ 1\\\\ 1 \\end{bmatrix} \\end{equation} $$\nRGBColorSpace::RGBColorSpace(Point2f r, Point2f g, Point2f b, Spectrum illuminant, const RGBToSpectrumTable *rgbToSpec, Allocator alloc) : r(r), g(g), b(b), illuminant(illuminant, alloc), rgbToSpectrumTable(rgbToSpec) { // Compute whitepoint primaries and XYZ coordinates XYZ W = SpectrumToXYZ(illuminant); w = W.xy(); XYZ R = XYZ::FromxyY(r), G = XYZ::FromxyY(g), B = XYZ::FromxyY(b); // Initialize XYZ color space conversion matrices SquareMatrix\u0026lt;3\u0026gt; rgb(R.X, G.X, B.X, R.Y, G.Y, B.Y, R.Z, G.Z, B.Z); XYZ C = InvertOrExit(rgb) * W; XYZFromRGB = rgb * SquareMatrix\u0026lt;3\u0026gt;::Diag(C[0], C[1], C[2]); RGBFromXYZ = InvertOrExit(XYZFromRGB); } 标准色彩空间 # 常见的色彩空间如下, 它们在pbrt中都被预定义了.\nsRGB, 90年代为Web标准颜色而开发, 目前应用最广泛 DCI-P3, 为数字影视行业开发, 色域广于sRGB, 应用逐渐扩大(比如我写这篇文章的mba就默认P3色域) Rec2020, 为UHDTV开发, 色域广于DCI-P3 ACES2065-1, 色彩空间范围超过色度图, 可用于长期数据存储, 不受行业发展的影响. 使用光谱渲染的原因 # RGB色彩空间中颜色相乘不等于对应的光谱相乘, 例如用RGB表示入射光与反射率时得到的漫反射颜色是不正确的. 提到的另一点强调光谱提供的波长信息可以更方便的对色散、薄膜干涉、微表面的衍射等现象建模, 这一点我感觉更重要.\n波长样本数的选择 # 由于每个像素会生成多个样本, 通常采样到不同的波长, 每个样本并不需要采样过多的波长. 经过数据分析简单场景下采样32个波长可以达到最优的效果, 而复杂场景下8个样本可以达到最优. Monte Carlo下需要每个像素生成多个不同光线路径的样本来减小损失, 且Monte Carlo带来的损失要大于波长样本数造成的损失, 因此pbrt采用默认4个样本.\nRGB转光谱 # 光谱转RGB的过程是确定的, 但由于同色异谱等原因RGB转光谱要相对困难. 由于现有3D工具通常以RGB参数或纹理存储反射率、自发光等信息, RGB转光谱是一项重要的任务.\n转换过程需要考虑3种光谱分布.\n发光光谱, 用于自发光光源, RGB取值范围是无界的 反射光谱, 用于描述可吸收光照的表面的反射率, 由于能量守恒RGB位于[0,1]中 无界光谱, 自发光之外的其他无界值, 如折射率与介质散射 反射光谱 # 首先解决反射光谱转换, 它需要满足以下三点性质.\n一致性, 转换得到光谱可以通过一般方法转换为当前的RGB 光滑性, RGB值的微小变动应该也对应光谱的微小变动 能量守恒 pbrt使用2次多项式对光谱建模, 利用sigmoid函数保持能量守恒. 由于sigmoid函数的特征, 反射率为0与1需要特殊处理.\n$$ \\begin{equation} \\begin{aligned} s(x) \u0026amp;= \\frac{1}{2} + \\frac{x}{2 \\sqrt{1 + x^2}}\\\\ S(\\lambda) \u0026amp;= s(c_2 \\lambda^2 + c_1 \\lambda + c_0)\\\\ \\end{aligned} \\end{equation} $$\npbrt通过数值优化来求解参数, 由于反照率表示的是白光垂直照在材质上的漫反射颜色, 优化方程中需要加入白点. 这也使得解出的白色是均匀分布的光谱, 因为本身色彩空间响应曲线就会将白点映射到\\((1,1,1)\\), 只有与均匀光谱内积才能得到三个通道上值相同的颜色. pbrt选用CIE76\\(\\Delta E\\)作为优化范式, 利用Gauss-Newton方法求解.\n$$ \\begin{equation} (c_0^*, c_1^*, c_2^*) = \\underset{c_0,c_1,c_2} {\\operatorname{argmin}} \\left\\Vert \\begin{bmatrix} r\\\\ g\\\\ b \\end{bmatrix} - \\int \\begin{bmatrix} R(\\lambda)\\\\ G(\\lambda)\\\\ B(\\lambda) \\end{bmatrix} S(\\lambda, c_0, c_1, c_2) W(\\lambda) d\\lambda \\right\\Vert \\end{equation} $$\n为了使插值更平滑, 根据对色彩空间中参数梯度变化, pbrt根据RGB哪个值最大来决定要查的表. 例如当R最大时会把颜色做如下的转换. x、y在表中的位置是线性的, z因为在0与1附近变化最大, 是非线性的, 需要通过二分找到在表中的位置.\n$$ \\begin{equation} (x,y,z)=(\\frac{g}{r}, \\frac{b}{r}, r) \\end{equation} $$\n此时我们可以定义RGBAlbedoSpectrum, 构造函数通过颜色来得到反射率分布.\nRGBAlbedoSpectrum::RGBAlbedoSpectrum(const RGBColorSpace \u0026amp;cs, RGB rgb) { rsp = cs.ToRGBCoeffs(rgb); } 无界光谱 # 无界光谱定义在RGBUnboundedSpectrum中, 由于同样与白点相关, 可以通过缩放复用反射光谱. pbrt通过将颜色除以两倍的最大值以提升参数优化的效果, 如果按照一般的除以最大值的归一化方法, 得到的高饱和度颜色会使得优化求解出的光谱在非饱和区域分布过多.\nRGBUnboundedSpectrum::RGBUnboundedSpectrum(const RGBColorSpace \u0026amp;cs, RGB rgb) { Float m = std::max({rgb.r, rgb.g, rgb.b}); scale = 2 * m; rsp = cs.ToRGBCoeffs(scale ? rgb / scale : RGB(0, 0, 0)); } Float RGBUnboundedSpectrum::operator()(Float lambda) const { return scale * rsp(lambda); } Float RGBUnboundedSpectrum::MaxValue() const { return scale * rsp.MaxValue(); } 自发光光谱 # 自发光光谱定义在RGBIlluminantSpectrum中, 在RGBUnboundedSpectrum的基础上, 自发光光源在取值时会乘上当前色彩空间的标准光源在该波长下的值, 因为反照率乘上白点光谱是可以得到对应颜色的光照的.\nRGBIlluminantSpectrum::RGBIlluminantSpectrum(const RGBColorSpace \u0026amp;cs, RGB rgb) : illuminant(\u0026amp;cs.illuminant) { Float m = std::max({rgb.r, rgb.g, rgb.b}); scale = 2 * m; rsp = cs.ToRGBCoeffs(scale ? rgb / scale : RGB(0, 0, 0)); } Float RGBIlluminantSpectrum::operator()(Float lambda) const { if (!illuminant) return 0; return scale * rsp(lambda) * (*illuminant)(lambda); } 结语 # 这章对辐射度量学与光谱渲染进行了详细的介绍, 反射模型相关内容也有涉及, 由于它直接影响渲染过程中光线传播显示的颜色, 后面第9章会有单独的章节细化这些内容.\nRGB渲染只能说是光谱渲染的hack, 不过考虑到现有GPU架构, 光谱渲染应用在实时渲染应该还有一段距离, 积分的计算有点为难shader了.\n另外, TaggedPointer这种显示指明子类的多态实现属实有点丑陋, 但不借助反射的话应该也没什么好方法了.\n","date":"2024 October 7","externalUrl":null,"permalink":"/render/1728265562044-pbrt-v4-episode-4/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. IV: 辐射与光","type":"render"},{"content":" 对于所有图形学任务, 几何物体的表示都是设计的核心部分. 这一章主要介绍pbrt中几何物体接口的设计.\n坐标系 # 左手系, y朝上.\nn元基类 # pbrt中n元类都继承自n元基类, n元基类是带有子类的模板类, 这样可以更方便的实现子类的模板方法. Tuple3定义如下.\ntemplate \u0026lt;template \u0026lt;typename\u0026gt; class Child, typename T\u0026gt; class Tuple3 { // ... }; pbrt并未将tuple长度模板化, 这样可以支持类似v.x的访问方式, 当然长度模板化后可以通过下标访问, 如v[i], pbrt也是支持的.\npbrt实现的方法都会限制输入输出类型与子类一致, 以加法重载为例, 参数与返回值都限制为Child类. 在pbrt的设计中, 子类也是模板类, 例如Vector3\u0026lt;T\u0026gt;. 包含不同类型参数的子类是可以运算的, 返回值由模板推导得到.\ntemplate \u0026lt;typename U\u0026gt; auto operator+(Child\u0026lt;U\u0026gt; c) const -\u0026gt; Child\u0026lt;decltype(T{} + U{})\u0026gt; { return {x + c.x, y + c.y, z + c.z}; } 向量 # 向量类支持计算长度, 长度类型通过TupleLength类提供, 其定义如下.\ntemplate \u0026lt;typename T\u0026gt; struct TupleLength { using type = Float; }; template \u0026lt;\u0026gt; struct TupleLength\u0026lt;double\u0026gt; { using type = double; }; 长度计算方法如下. 这里使用using是为了通过自定义sqrt来支持不被std::sqrt支持的类型.\ntemplate \u0026lt;typename T\u0026gt; T LengthSquared(Vector3\u0026lt;T\u0026gt; v) { return Sqr(v.x) + Sqr(v.y) + Sqr(v.z); } template \u0026lt;typename T\u0026gt; auto Length(Vector3\u0026lt;T\u0026gt; v) -\u0026gt; typename TupleLength\u0026lt;T\u0026gt;::type { using std::sqrt; return sqrt(LengthSquared(v)); } 支持长度计算后Normalize的支持就顺水推舟了, 这里通过auto来保证归一化后具有正确的类型, 例如Vector3\u0026lt;int\u0026gt;转化为Vector3\u0026lt;Float\u0026gt;.\ntemplate \u0026lt;typename T\u0026gt; auto Normalize(Vector3\u0026lt;T\u0026gt; v) { return v / Length(v); } 为避免std::acos在向量接近平行处的精度损失, pbrt采用如下方式计算夹角, 参数需要是单位向量.\ntemplate \u0026lt;typename T\u0026gt; Float AngleBetween(Vector3\u0026lt;T\u0026gt; v1, Vector3\u0026lt;T\u0026gt; v2) { if (Dot(v1, v2) \u0026lt; 0) return Pi - 2 * SafeASin(Length(v1 + v2) / 2); else return 2 * SafeASin(Length(v2 - v1) / 2); } pbrt支持施密特正交的计算.\ntemplate \u0026lt;typename T\u0026gt; Vector3\u0026lt;T\u0026gt; GramSchmidt(Vector3\u0026lt;T\u0026gt; v, Vector3\u0026lt;T\u0026gt; w) { return v - Dot(v, w) * w; } pbrt支持叉乘, DifferenceOfProducts可以为a*b-c*d保留更高的精度.\ntemplate \u0026lt;typename T\u0026gt; Vector3\u0026lt;T\u0026gt; Cross(Vector3\u0026lt;T\u0026gt; v, Vector3\u0026lt;T\u0026gt; w) { return {DifferenceOfProducts(v.y, w.z, v.z, w.y), DifferenceOfProducts(v.z, w.x, v.x, w.z), DifferenceOfProducts(v.x, w.y, v.y, w.x)}; } pbrt支持通过一个Vector3来生成一个坐标系, 其余两个基向量如下. 为避免\\(1 + v_z = 0\\), 式中的符号根据\\(v_z\\)的符号修改.\n$$ \\left( 1 - \\frac{v_x^2}{1 + v_z}, -\\frac{v_x v_z}{1 + v_z}, -v_x \\right) $$ $$ \\left( -\\frac{v_x v_y}{1 + v_z}, 1 - \\frac{v_y^2}{1 + v_z}, -v_y \\right) $$\ntemplate \u0026lt;typename T\u0026gt; void CoordinateSystem(Vector3\u0026lt;T\u0026gt; v1, Vector3\u0026lt;T\u0026gt; *v2, Vector3\u0026lt;T\u0026gt; *v3) { Float sign = pstd::copysign(Float(1), v1.z); Float a = -1 / (sign + v1.z); Float b = v1.x * v1.y * a; *v2 = Vector3\u0026lt;T\u0026gt;(1 + sign * Sqr(v1.x) * a, sign * b, -sign * v1.x); *v3 = Vector3\u0026lt;T\u0026gt;(b, sign + Sqr(v1.y) * a, -v1.y); } 点 # 对点进行减法可以返回向量, 点之间的距离通过向量的长度计算.\ntemplate \u0026lt;typename U\u0026gt; auto operator-(Point3\u0026lt;U\u0026gt; p) const -\u0026gt; Vector3\u0026lt;decltype(T{} - U{})\u0026gt; { return {x - p.x, y - p.y, z - p.z}; } template \u0026lt;typename T\u0026gt; auto DistanceSquared(Point3\u0026lt;T\u0026gt; p1, Point3\u0026lt;T\u0026gt; p2) { return LengthSquared(p1 - p2); } 法线 # 法线可以由平面上两个不平行的切线向量的叉乘得到, 法线可以不归一化. 与向量类相比, 法线类不允许叉乘、相加等操作.\n法线通常需要在平面上方, 即某个向量对应的半球上, pbrt中通过FaceForward修改法线方向.\ntemplate \u0026lt;typename T\u0026gt; Normal3\u0026lt;T\u0026gt; FaceForward(Normal3\u0026lt;T\u0026gt; n, Vector3\u0026lt;T\u0026gt; v) { return (Dot(n, v) \u0026lt; 0.f) ? -n : n; } 光线 # 光线类定义了一个射线, 包括一个Point3f类型的原点与Vector3f类型的射线方向.\npbrt通过函数子计算光线上某点, 即\\(o+td\\).\nPoint3f operator()(Float t) const { return o + d * t; } Ray拥有时间成员time, 用于特定时间的采样动态场景.\nRay同时拥有介质成员medium, 用于光线传播体渲染的计算.\n光线微分 # 光线微分继承自光线, 主要用于获取\\(x\\)与\\(y\\)方向相邻样本对应的光线的信息, 以计算光线对应的面积来实现纹理采样的抗锯齿.\n包围盒 # pbrt使用轴对称包围盒(AABB), 支持2D包围盒Bounds2与3D包围盒Bounds3, 同样是通过模板类支持顶点为不同类型的包围盒.\n包围盒的构造函数为赋值为当前类型的极大值与极小值.\nBounds3() { T minNum = std::numeric_limits\u0026lt;T\u0026gt;::lowest(); T maxNum = std::numeric_limits\u0026lt;T\u0026gt;::max(); pMin = Point3\u0026lt;T\u0026gt;(maxNum, maxNum, maxNum); pMax = Point3\u0026lt;T\u0026gt;(minNum, minNum, minNum); } 包围盒支持通过下标访问最小顶点与最大顶点.\nPoint3\u0026lt;T\u0026gt; operator[](int i) const { return (i == 0) ? pMin : pMax; } Point3\u0026lt;T\u0026gt; \u0026amp;operator[](int i) { return (i == 0) ? pMin : pMax; } Corner函数用于通过bit flag来返回顶点, 0对应最小点, 1对应最大点.\nPoint3\u0026lt;T\u0026gt; Corner(int corner) const { return Point3\u0026lt;T\u0026gt;((*this)[(corner \u0026amp; 1)].x, (*this)[(corner \u0026amp; 2) ? 1 : 0].y, (*this)[(corner \u0026amp; 4) ? 1 : 0].z); } 通过比较某点到最小点与最大点的距离可以得出该点与包围盒的最短距离, 距离类型为TupleLength.\ntemplate \u0026lt;typename T, typename U\u0026gt; auto DistanceSquared(Point3\u0026lt;T\u0026gt; p, const Bounds3\u0026lt;U\u0026gt; \u0026amp;b) { using TDist = decltype(T{} - U{}); TDist dx = std::max\u0026lt;TDist\u0026gt;({0, b.pMin.x - p.x, p.x - b.pMax.x}); TDist dy = std::max\u0026lt;TDist\u0026gt;({0, b.pMin.y - p.y, p.y - b.pMax.y}); TDist dz = std::max\u0026lt;TDist\u0026gt;({0, b.pMin.z - p.z, p.z - b.pMax.z}); return Sqr(dx) + Sqr(dy) + Sqr(dz); } template \u0026lt;typename T, typename U\u0026gt; auto Distance(Point3\u0026lt;T\u0026gt; p, const Bounds3\u0026lt;U\u0026gt; \u0026amp;b) { auto dist2 = DistanceSquared(p, b); using TDist = typename TupleLength\u0026lt;decltype(dist2)\u0026gt;::type; return std::sqrt(TDist(dist2)); } pbrt支持通过AABB对角线构建包围球.\nvoid BoundingSphere(Point3\u0026lt;T\u0026gt; *center, Float *radius) const { *center = (pMin + pMax) / 2; *radius = Inside(*center, *this) ? Distance(*center, pMax) : 0; } 球体 # 球体可以用于高效的构建多个方向向量的包围结构.\n立体角 # 以锥体的顶点作为球心作球面, 这个面积与半径平方的比值即为立体角, 一个球体对应的立体角为\\(4\\pi\\). 立体角可以用于表示物体投影到单位圆上的投影面积, 根据球面积分单位立体角具有如下的映射方式, 其中\\(\\theta\\)为极角, \\(\\phi\\)为水平角.\n$$ \\begin{equation} d\\bold{l} = \\sin \\theta d\\theta d\\phi \\end{equation} $$\n球面多边形 # 球形多边形即为某个多面锥体在单位球上的投影面积.\n球面多边形每个角的角度是这个顶点对应的两个锥体上的平面形成的二面角, 球面角超是球面多边形内角和超过平面多边形面积的部分, 它与球面多边形的面积相等.\n$$ \\begin{equation} E = \\sum_{i=1}^{n} \\theta_i - (n - 2)\\pi \\end{equation} $$\n在pbrt中, 利用球面三角恒等式将球面角超的计算化简为如下形式, 以避免过多使用反三角函数损失精度.\n$$ \\begin{equation} \\tan\\left(\\frac{1}{2} A\\right) = \\frac{\\bold{a} \\cdot (\\bold{b} \\times \\bold{c})}{1 + (\\bold{a} \\cdot \\bold{b}) + (\\bold{a} \\cdot \\bold{c}) + (\\bold{b} \\cdot \\bold{c})} \\end{equation} $$\npbrt中球面四边形仍然采用直接计算二面角的方式来计算.\n球面参数化 # 球面坐标系 # $$ \\begin{equation} \\begin{aligned} x \u0026amp;= r \\sin\\theta \\cos\\phi\\\\ y \u0026amp;= r \\sin\\theta \\sin\\phi\\\\ z \u0026amp;= r \\cos\\theta \\end{aligned} \\end{equation} $$\n逆运算如下.\n$$ \\begin{equation} \\begin{aligned} \\theta \u0026amp;= \\arccos z\\\\ \\phi \u0026amp;= \\arctan \\frac{y}{x} \\end{aligned} \\end{equation} $$\n\\(\\phi\\)对应的三角函数也可以快速计算.\n$$ \\begin{equation} \\begin{aligned} \\cos\\theta \u0026amp;= \\frac{x}{r \\sin\\theta}\\\\ \\sin\\theta \u0026amp;= \\frac{y}{r \\sin\\theta} \\end{aligned} \\end{equation} $$\n八面体编码 # 由于浮点精度, 球面坐标系的两极比赤道具有更高的精度, 八面体压缩得到更均匀的分布. 利用八面体压缩可以将Vector3f展开到二维平面, pbrt将每个元素用2个字节存储, 只需要4个字节即可存储一个单位向量.\n八面体压缩收集计算绝对值向量投影到\\(x+y+z=1\\)平面, 再投影到\\(xy\\)平面得到压缩向量\\((x, y)\\), 上半球面的向量只需要设置符号, 下半球面向量先计算其对应上半球面绝对值向量的压缩值关于\\(x+y=1\\)的对称值再去修改符号.\nOctahedralVector(Vector3f v) { v /= std::abs(v.x) + std::abs(v.y) + std::abs(v.z); if (v.z \u0026gt;= 0) { x = Encode(v.x); y = Encode(v.y); } else { x = Encode((1 - std::abs(v.y)) * Sign(v.x)); y = Encode((1 - std::abs(v.x)) * Sign(v.y)); } } pbrt将八面体压缩值最终存储在整数中.\nstatic uint16_t Encode(Float f) { return pstd::round(Clamp((f + 1) / 2, 0, 1) * 65535.f); } 解压缩过程如下.\nexplicit operator Vector3f() const { Vector3f v; v.x = -1 + 2 * (x / 65535.f); v.y = -1 + 2 * (y / 65535.f); v.z = 1 - (std::abs(v.x) + std::abs(v.y)); if (v.z \u0026lt; 0) { v.x = (1 - std::abs(v.y)) * Sign(v.x); v.y = (1 - std::abs(v.x)) * Sign(v.y); } return Normalize(v); } 等面积映射 # 等面积映射保证球面上任意区域的面积与参数化后的空间中对应的面积的比例相似.\n令\\((u,v)\\in[-1,1]\\), \\(u\\ge0\\)且\\(u-|v|\\ge0\\)时等面积映射的极坐标见下式. 此时\\(\\phi\\in[-\\frac{\\pi}{4}, \\frac{\\pi}{4}]\\), 其它区域的映射具有相似的形式.\n$$ \\begin{equation} \\begin{aligned} r \u0026amp;= u\\\\ \\phi \u0026amp;= \\frac{\\pi}{4}\\frac{v}{u} \\end{aligned} \\end{equation} $$\n极坐标到球面坐标的等面积映射如下.\n$$ \\begin{equation} \\begin{aligned} x \u0026amp;= (\\cos\\phi) r \\sqrt{2-r^2}\\\\ y \u0026amp;= (\\sin\\phi) r \\sqrt{2-r^2}\\\\ z \u0026amp;= 1 - r^2 \\end{aligned} \\end{equation} $$\npbrt中等面积映射的解压缩遵循如下步骤.\n取\\((u, v)\\)的绝对值即映射到第一象限来简化计算 根据与象限对角线的距离来计算\\(r\\) 计算出对应的极坐标, 并且由于旋转需要\\(\\phi+\\frac{\\pi}{4}\\) 根据\\(u,v\\)位于\\(x+y=1\\)的哪一侧确定z的方向. 等面积映射到球面坐标, 根据\\(u,v\\)的符号确定最终映射值的符号 压缩过程基本是解压缩的逆过程.\n方向包围结构 # 方向包围结构用于快速获取对应的立体角范围, 典型应用场景是剔除掉没有射向物体方向的光线.\npbrt在DirectionCone中通过锥体的中心轴方向与锥体扩散角的余弦定义了包围锥.\npbrt支持通过包围盒与锥体顶点计算出对应的包围锥体, 这通过计算顶点到包围盒对应的包围球的切线扩散角来实现.\nPBRT_CPU_GPU inline DirectionCone BoundSubtendedDirections(const Bounds3f \u0026amp;b, Point3f p) { // Compute bounding sphere for _b_ and check if _p_ is inside Float radius; Point3f pCenter; b.BoundingSphere(\u0026amp;pCenter, \u0026amp;radius); if (DistanceSquared(p, pCenter) \u0026lt; Sqr(radius)) return DirectionCone::EntireSphere(); // Compute and return _DirectionCone_ for bounding sphere Vector3f w = Normalize(pCenter - p); Float sin2ThetaMax = Sqr(radius) / DistanceSquared(pCenter, p); Float cosThetaMax = SafeSqrt(1 - sin2ThetaMax); return DirectionCone(w, cosThetaMax); } 变换 # 图形学中通常利用四维矩阵进行三维空间中物体的变换.\n齐次坐标 # 通过4D的齐次坐标可以只用一个矩阵表示变换, 要求第4个元素不为0, 前三个元素除以第四个元素可以得到3D空间上的值.\n变换类定义 # Transform类存储SquareMatrix\u0026lt;4\u0026gt;类型的矩阵m与逆矩阵mInv. 为避免相同的矩阵占有过多内存, pbrt通过InternCache类构建哈希表, 相同的变换使用同一块存储在哈希表中的内存.\n基础操作 # 变换初始化时为单位变换, 即对角线为1其余为0. 对于奇异矩阵即非可逆矩阵, mInv会被初始化为NaN.\n平移 # 通过设置矩阵第四列可以实现平移.\n缩放 # 通过设置对角线上前三个元素可以实现缩放.\nx,y,z旋转 # 通过设置另外两个轴的元素可以实现顺时针旋转. 由于y轴下x到z是逆时针的, 所以符号不同.\n任意轴旋转 # 任意轴旋转通过Rodrigues公式实现, 遵循以下步骤.\n将旋转轴转为单位向量 向量投影到旋转轴顶端对应的平面 投影向量与旋转轴叉乘, 二者组成坐标系 在该坐标系下执行旋转, 最后乘上向量长度 通过获取x,y,z轴旋转后的结果可以得到旋转矩阵.\n$$ \\begin{equation} \\begin{aligned} \\bold{v_c} \u0026amp;= \\bold{a}||\\bold{v}|| \\cos\\alpha = \\bold{a}(\\bold{v} \\cdot \\bold{a})\\\\ \\bold{v_1} \u0026amp;= \\bold{v} - \\bold{v_c}\\\\ \\bold{v_2} \u0026amp;= \\bold{v_1} \\times \\bold{a}\\\\ \\bold{v\u0026rsquo;} \u0026amp;= \\bold{v_c} + \\bold{v_1}\\cos\\theta + \\bold{v_2}\\sin\\theta \\end{aligned} \\end{equation} $$\n从一个向量旋转到另一个 # 给定两个向量, 我们可以通过叉乘来生成旋转坐标轴, 但是在两个向量接近平行时这种方法不再稳定, 且需要昂贵的三角函数参与.\npbrt通过Householder矩阵实现反射.\n$$ \\begin{equation} \\begin{aligned} H(\\bold{v}) \u0026amp;= I - 2 \\frac{\\bold{v} \\bold{v}^T}{\\bold{v} \\cdot \\bold{v}}\\\\ H(\\bold{v})\\bold{x} \u0026amp;= \\bold{x} - 2 \\frac{\\bold{v}}{||\\bold{v}||}(\\frac{\\bold{v}}{||\\bold{v}||} \\cdot \\bold{x}) \\end{aligned} \\end{equation} $$\npbrt默认参数是归一化的, 通过向量的数值选择距离两个向量相对较远的轴作为反射中间轴. 这里0.72使用是因为\\(0.72\\approx\\frac{\\sqrt{2}}{2}\\).\nVector3f refl; if (std::abs(from.x) \u0026lt; 0.72f \u0026amp;\u0026amp; std::abs(to.x) \u0026lt; 0.72f) refl = Vector3f(1, 0, 0); else if (std::abs(from.y) \u0026lt; 0.72f \u0026amp;\u0026amp; std::abs(to.y) \u0026lt; 0.72f) refl = Vector3f(0, 1, 0); else refl = Vector3f(0, 0, 1); 最终旋转矩阵如下式. 由于这里f、t、r都是归一化的, Householder相当于根据等腰三角形的长边来反射.\n$$ \\begin{equation} R = H(\\bold{r} - \\bold{t}) H(\\bold{r} - \\bold{f}) \\end{equation} $$\n观察矩阵 # 给出摄像机位置、目标位置、上方向即可很快通过叉乘构建出坐标系.\n应用变换 # 点 \u0026amp; 向量 # 直接矩阵计算.\n法线 # 法线需要考虑不均匀缩放带来的影响. 令t为变换前与法线正交的切线, T为一般的变换, S为正确的变换, ‘代表变换后的结果, 可得下式.\n$$ \\begin{equation} \\begin{aligned} 0 \u0026amp;= (\\bold{n}\u0026rsquo;)^T \\bold{t}\u0026rsquo;\\\\ \u0026amp;= (S\\bold{n})^T (T\\bold{t})\\\\ \u0026amp;= \\bold{n}^T S^T T \\bold{t} \\end{aligned} \\end{equation} $$\n由于\\(\\bold{n}^T\\bold{t}=0\\), 故\\(S=(M^{-1})^T\\).\n光线 # 应用变换在光线起始点与光线方向.\n包围盒 # 应用变换在包围盒中心点与包围盒范围(即对角线的一半, 与方向类似).\n变换的组合 \u0026amp; 坐标系的变换 # 都是线性代数的基础知识.\n交互 # 渲染任务中需要处理各类物体的交互, 例如光线与表面的交互影响反射方向、光线与介质的交互影响radiance. pbrt中定义了Interaction类来对各类交互进行抽象, 构造函数如下.\nInteraction(Point3fi pi, Normal3f n, Point2f uv, Vector3f wo, Float time) : pi(pi), n(n), uv(uv), wo(Normalize(wo)), time(time) {} 交互都需要存储点, 例如光线与表面的交点. pbrt通过Point3i中的Interval来表示交点的数值误差.\n部分交互需要存储方向, 例如光线的方向, pbrt将其存储在wo中.\n由于部分交互并不关心是表面交互还是介质交互, 表面相关的值为0时就将其忽略, 所以pbrt将法线与表面uv这些表面参数存储在基类中以简化交互的实现. pbrt支持通过法线判断当前为表面交互还是介质交互.\nbool IsSurfaceInteraction() const { return n != Normal3f(0, 0, 0); } bool IsMediumInteraction() const { return !IsSurfaceInteraction(); } Interaction类中通过MediumInterface来表示介质间的交互, 并存储某个点的介质.\nconst MediumInterface *mediumInterface = nullptr; Medium medium = nullptr; 表面交互 # SurfaceInteraction会额外存储点和法线在u、v上的偏导数, 法线是根据点的偏导数的叉乘计算的, u、v的偏导数可以不是正交的.\npbrt在SurfaceInteraction类中定义了shading成员来存储着色后的值, 例如normal mapping会修改mesh实际的法线. shading用几何物体上的实际值来初始化.\nstruct { Normal3f n; Vector3f dpdu, dpdv; Normal3f dndu, dndv; } shading; 部分着色过程需要用到mesh的三角形编号, 这会被存储在SurfaceInteraction中.\nint faceIndex = 0; pbrt中闭合形状的法线是指向外侧的, 如果着色过程中生成的法线指向内侧, pbrt支持通过传入参数决定几何法线和着色法线哪个需要改变方向.\nshading.n = ns; if (orientationIsAuthoritative) n = FaceForward(n, shading.n); else shading.n = FaceForward(shading.n, n); 介质交互 # MediumInteraction在Interaction基础上添加了PhaseFunction.\n结语 # 这部分并未涉及具体几何形状的存储方式, 主要介绍渲染过程中用到的各类三维空间中的工具, 具体几何形状的内容会在第6章详细介绍.\n","date":"2024 October 5","externalUrl":null,"permalink":"/render/1728092546418-pbrt-v4-episode-3/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. III: 几何与变换","type":"render"},{"content":" 随机模拟, 或者说Monte Carlo方法, 是很常用的统计学方法, 渲染任务往往通过大量采样来渲染方程积分结果. pbrt中基本都采用无偏采样器, SPPMIntegrator是个例外. Monte Carlo通用形式如下.\n$$ \\begin{equation} \\begin{aligned} F_n \u0026amp;\\approx E(\\frac{1}{n} \\sum_{i=1}^n \\frac{f(X_i)}{p(X_i)})=\\int \\frac{f(x)}{p(x)}p(x)dx \\end{aligned} \\end{equation} $$\n这部分可以结合北大的统计计算, 想起来本科时还上过这个课, 一点都不记得, 很惭愧.\n效率优化 # 分层抽样 # 将样本空间划分为多份, 每个空间被称为“层”, 采样时从各层中分别采样. 每层的Monte Carlo积分值可用下式表示.\n$$ \\begin{equation} F_i = \\frac{1}{n_i} \\sum_{j=1}^{n_i} \\frac{f(X_{i,j})}{p(X_{i,j})} \\end{equation} $$\npbrt中认为使用的PDF仍然分布在未分层的空间中, 因此需要除以第i层对应区域的CDF\\(v_i\\), 此时\\(F_i\\)期望值的证明见下式.\n$$ \\begin{equation} \\begin{aligned} E(F_i) \u0026amp;= E(\\frac{1}{n_i}\\sum_{j=1}^{n_i}\\frac{f(X_{i,j})}{p(X_{i,j})})\\\\ \u0026amp;= \\frac{1}{n_i}E(\\sum_{j=1}^{n_i}\\frac{f(X_{i,j})}{p(X_{i,j})})\\\\ \u0026amp;= \\frac{1}{n_i}n_iE(\\frac{f(X)}{p(X)})\\\\ \u0026amp;\\approx \\int_{\\Lambda_i} \\frac{f(x)}{p(x)} \\frac{p(x)}{v_i} dx\\\\ \u0026amp;= \\frac{1}{v_i} \\int_{\\Lambda_i} f(x) dx \\end{aligned} \\end{equation} $$\n由此可得最终的Monte Carlo表示方式.\n$$ \\begin{equation} F = \\sum_{i=1}^n v_i F_i \\end{equation} $$\n分层抽样主要用于降低方差, 对于独立变量\\(X\\)和\\(Y\\), 有\\(Var(X+Y)=Var(X)+Var(Y)\\), 因此每一层的方差如下.\n$$ \\begin{equation} \\begin{aligned} Var(F_i) \u0026amp;= Var(\\frac{1}{n_i}\\sum_{j=1}^{n_i}\\frac{f(X_{i,j})}{p(X_{i,j})})\\\\ \u0026amp;= \\frac{1}{n^2_i}Var(\\sum_{j=1}^{n_i}\\frac{f(X_{i,j})}{p(X_{i,j})})\\\\ \u0026amp;= \\frac{1}{n^2_i}n_i Var(\\frac{f(X)}{p(X)})\\\\ \u0026amp;\\approx \\frac{1}{n_i}\\sigma_{i}^2 \\end{aligned} \\end{equation} $$\n令层数为m, 可以得出Monte Carlo的方差为下式.\n$$ \\begin{equation} \\begin{aligned} Var(F) \u0026amp;= Var(\\sum_{i=1}^m v_i F_i)\\\\ \u0026amp;= \\sum_{i=1}^m Var(v_i F_i)\\\\ \u0026amp;= \\sum_{i=1}^m \\frac{v_i^2\\sigma_i^2}{n_i} \\end{aligned} \\end{equation} $$\n令每层的样本数与每层的样本范围线性正相关, 此时每层\\(n_i=nv_i\\), 方差可以简化为下式.\n$$ \\begin{equation} Var(F)=\\frac{1}{n} \\sum_{i=1}^m v_i\\sigma_i^2 \\end{equation} $$\n对于非分层抽样, 可以看作是先随机选择一个层, 然后在该层中随机抽样出一个值, 抽样出的值\\(X_i\\)是依赖于选择到该层\\(I_i\\)的概率的. 此时积分的方差可以表示为下式.\n$$ \\begin{equation} \\begin{aligned} Var(F) \u0026amp;= \\frac{1}{n^2} \\sum_{i=1}^n Var(\\frac{f(X_i)}{P(X_i)})\\\\ \u0026amp;= \\frac{1}{n} Var(\\frac{f(X)}{P(X)}) \\end{aligned} \\end{equation} $$\n全概率定理如下.\n$$ \\begin{equation} \\begin{aligned} E(E(X|Y)) \u0026amp;=\\int p(y) \\int x p(x|y) dx dy\\\\ \u0026amp;=\\int \\int x p(x,y) dx dy\\\\ \u0026amp;=\\int x p(x) dx\\\\ \u0026amp;=E(X) \\end{aligned} \\end{equation} $$\n全方差定理如下.\n$$ \\begin{equation} \\begin{aligned} Var(X)\u0026amp;=E(Var(X|Y))+Var(E(X|Y))\\\\ E(Var(X|Y)) \u0026amp;=E(E(X^2|Y)-E^2(X|Y))\\\\ \u0026amp;=E(E(X^2|Y))-E(E^2(X|Y))\\\\ \u0026amp;=E(X^2)-E(E^2(X|Y))\\\\ Var(E(X|Y)) \u0026amp;=E(E^2(X|Y))-E^2(E(X|Y))\\\\ \u0026amp;=E(E^2(X|Y))-E^2(X) \\end{aligned} \\end{equation} $$\n已知落入某层的概率即为该层在积分中的占比, 即\\(p(I = v) = v\\), 记\\(G=\\frac{f(X)}{P(X)}\\), 此时可以解出下式.\n$$ \\begin{equation} \\begin{aligned} E(Var(G|I)) \u0026amp;= \\sum_{i=1}^m Var(G|I=v_i)p(I=v_i)\\\\ \u0026amp;= \\sum_{i=1}^m \\sigma_i^2 v_i \\end{aligned} \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} Var(E(G|I)) \u0026amp;= \\sum_{i=1}^m (E(G|I=v_i) - E(E(G|I)))^2 p(I=v_i)\\\\ \u0026amp;= \\sum_{i=1}^m (\\mu_i - E(G))^2 v_i\\\\ \u0026amp;= \\sum_{i=1}^m (\\mu_i - Q)^2 v_i \\end{aligned} \\end{equation} $$\n将上式结合即可得到非分层抽样下的方差.\n$$ \\begin{equation} \\begin{aligned} Var(F) \u0026amp;= \\frac{1}{n} Var(G) \u0026amp;= \\frac{1}{n} \\sum_{i=1}^m (\\sigma_i^2 v_i + (\\mu_i - Q)^2 v_i) \\end{aligned} \\end{equation} $$\n可以看到非分层抽样的方差是大于等于分层抽样的方差的, 但是需要估计每一层的积分和. 同时分层数量也随维度指数增加, 通常只会在某一维上增加层数, 其它维度只有少量的层.\n重要性抽样 # 重要性抽样的核心思想就是让采样PDF与积分函数相似, 此时样本会集中在函数值较大处, 有利于积分计算的收敛.根据Jensen不等式可以得到下式, 当且仅当\\(\\frac{|f(X)|}{p(X)}\\)为常数时成立.\n$$ \\begin{equation} \\begin{aligned} Var(\\frac{f(X)}{p(X)}) \u0026amp;= E(\\frac{f^2(X)}{p^2(X)}) - E^2(\\frac{f(X)}{p(X)})\\\\ \u0026amp;\\geq E^2(\\frac{|f(X)|}{p(X)}) - F^2 \\end{aligned} \\end{equation} $$\n对于分层抽样, 可以在每一层内部使用重要性抽样来进一步降低方差. 但显然想找到这样的PDF是比较困难的.\n多重重要性抽样 # 积分式往往是由多个方程组成的, 我们可以分别选取与各个方程相似的PDF, 这被称为多重重要性抽样, 简称MIS, 若为无偏估计则在采样结果相同时\\(\\sum_{i=1}^n \\omega_i(x) = 1\\), 且当\\(p_i(x) = 0\\)时\\(\\omega_i(x) = 0\\)否则由于概率为0使得权重不产生影响上一个条件不成立, 证明如下.\n$$ \\begin{equation} \\begin{aligned} F \u0026amp;=E(\\sum_{i=1}^n \\frac{1}{n_i} \\sum_{j=1}^{n_i} \\omega_i(X_{i,j})\\frac{f(X_{i,j})}{p_i(X_{i,j})})\\\\ \u0026amp;\\approx\\sum_{i=1}^n\\int\\omega_i(x)\\frac{f(x)}{p_i(x)}p_i(x)dx\\\\ \u0026amp;=\\int\\sum_{i=1}^n\\omega_i(x)\\frac{(f(x))}dx\\\\ \u0026amp;=\\int f(x)dx \\end{aligned} \\end{equation} $$\n我们希望与函数形状相似的分布具有更高的权重, 我们通过平衡启发式来达到这一目的.\n$$ \\begin{equation} \\omega_i(x) = \\frac{n_i p_i(x)}{\\sum_{j=1}^{n} n_j p_j(x)} \\end{equation} $$\n实际使用中幂启发式也是常用的形式, pbrt中幂设置为2.\n$$ \\begin{equation} \\omega_i(x) = \\frac{(n_i p_i(x))^\\beta}{\\sum_{j=1}^{n} (n_j p_j(x))^\\beta} \\end{equation} $$\n若某次采样过程只使用一种PDF, 令选择\\(p_i(x)\\)的概率为\\(q_i\\), 此时可以得到单抽样模型, 同样也是无偏的.\n$$ \\begin{equation} \\begin{aligned} F \u0026amp;=E(\\frac{w_i(X)}{q_i}\\frac{f(X)}{p_i(X)})\\\\ \u0026amp;=\\sum_{i=1}^n\\int\\frac{\\omega_i(x)}{q_i}\\frac{f(x)}{p_i(x)}p_i(x)q_i dx\\\\ \u0026amp;=\\int\\sum_{i=1}^n\\omega_i(x)f(x)dx\\\\ \u0026amp;=\\int f(x)dx \\end{aligned} \\end{equation} $$\n对于MIS, 若其中一个采样分布与函数式接近, MIS会略微提高方差.\nMIS补偿 # MIS中每个PDF都可以单独用于Monte Carlo, 函数值非0处只需要有一个概率分布不为0即可. 将PDF较小处调整为0可以进一步缩小方差, 这被称为MIS补偿, 一种补偿方法如下.\n$$ \\begin{equation} p\u0026rsquo;(x) = \\frac{\\max(0, p(x) - \\delta)}{\\int_\\Omega max(0, p(x) - \\delta) dx} \\end{equation} $$\n俄罗斯轮盘 # 俄罗斯轮盘主要用于跳过估计值较小处的计算, 提高效率的同时可以保持无偏. 选择概率值\\(q\\)与常数\\(c\\), 可以得到下式. \\(c\\)通常为0.\n$$ \\begin{equation} F\u0026rsquo; = \\begin{cases} \\frac{F-qc}{1-q} \u0026amp; \\xi \u0026gt; q\\\\ c \u0026amp; \\text{otherwise} \\end{cases} \\end{equation} $$\n可以证明它是无偏的.\n$$ \\begin{equation} E(F\u0026rsquo;) = (1 - q)\\frac{E(F) - qc}{1 - q} + qc = E(F) \\end{equation} $$\n分离法 # 对于多维积分, 在样本数不变的情况下提高某个维度的样本数被称为分离法, 可以提高采样效率.\n$$ \\begin{equation} \\begin{aligned} \u0026amp;\\frac{1}{nm} \\sum_{i=1}^{nm} \\frac{f(X_i, Y_i)}{p_x(X_i) p_y(Y_i)}\\\\ =\u0026gt;\u0026amp;\\frac{1}{n} \\sum_{i=1}^n \\frac{1}{m} \\sum_{j=1}^m \\frac{f(X_i, Y_{i, j})}{p_x(X_i) p_y(Y_{i, j})} \\end{aligned} \\end{equation} $$\n例如在渲染中, 初始光线方向与相交后的反射方向都是随机变量, 我们可以只发射一次然后对反射方向多次采样来减少初次发射的开销.\n逆变换法 # 逆变换法可以通过采样容易构造的均匀分布来得到选定PDF中的样本. 在PDF已知的情况下, 将均匀分布采样结果输入CDF的逆函数即可获取PDF中的样本. 这里主要证明逆变换法得到的采样结果遵循选定的分布.\n$$ \\begin{equation} P(P_F^{-1}(U) \u0026lt; x) = P(U \u0026lt; P_F(x)) = P_F(x) \\end{equation} $$\n线性函数采样 # 线性函数及其PDF与CDF定义如下.\n$$ \\begin{equation} \\begin{aligned} f(x)\u0026amp;=(1-x)a+xb\\\\ p(x)\u0026amp;=\\frac{2((1-x)a+xb)}{a+b}\\\\ P(x)\u0026amp;=\\frac{x(a(2-x)+bx)}{a+b} \\end{aligned} \\end{equation} $$\n求解CDF逆变换即\\(U=P(X)\\)这一二次方程的结果如下, 为保证\\(a=b\\)时结果稳定对结果做简单变换.\n$$ \\begin{equation} \\begin{aligned} X \u0026amp;=\\frac{a-\\sqrt{(1-U)a^2+Ub^2}}{a-b}\\\\ \u0026amp;=\\frac{U(a+b)}{a+\\sqrt{(1-U)a^2+Ub^2}} \\end{aligned} \\end{equation} $$\n分布变换 # 为了使得变换后的CDF具有如下性质, 我们要求\\(Y=T(X)\\)在每个维度上都单调递增.\n$$ \\begin{equation} P(Y(X)) = P(X) \\end{equation} $$\n此时通过求导可以得到二者PDF的关系, 其中\\(|J_T(x)|\\)代表Jacobi矩阵的行列式.\n$$ \\begin{equation} p_T(y)=p_T(T(x))=\\frac{p(x)}{|J_T(x)|} \\end{equation} $$\n","date":"2024 October 2","externalUrl":null,"permalink":"/render/1727858234035-pbrt-v4-episode-2/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. II: 随机模拟","type":"render"},{"content":"国庆开坑pbrt-v4的学习, 主要想深入了解光谱渲染. pbrt是与pbr-v4这本书配套的渲染器实现. 大部分书只是有配套代码, 而非一个完整的开源软件, pbrt这一点确实不错.\n编译环境 # pbrt-v4的依赖项都写在git submodule里了, 安装cmake即可. 对于nix-darwin用户, 由于编译器不会包含impure的系统framework路径, 需要在flake中手动指定, 否则glfw会编不过.\n{ description = \u0026#34;pbrt devenv\u0026#34;; inputs.nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixpkgs-24.05-darwin\u0026#34;; outputs = { nixpkgs , ... }: let system = \u0026#34;aarch64-darwin\u0026#34;; pkgs = import nixpkgs { inherit system; }; in { devShells.\u0026#34;${system}\u0026#34;.default = pkgs.mkShell { packages = [] ++ (with pkgs; [ clang lldb cmake ]) ++ (with pkgs.darwin.apple_sdk.frameworks; [ Cocoa IOKit CoreFoundation Kernel ]); shellHook = \u0026#39;\u0026#39; exec zsh \u0026#39;\u0026#39;; }; }; } 程序结构 # pbrt-v4基于C++17, 遵循面向对象的结构(会有继承地狱的样子), 针对光线、相机、BxDF等设计了抽象接口. pbrt-v4在设计上同时支持CPU/GPU光追, 支持CUDA与OptiX(显然darwin跑不了GPU, 毕竟23年的M3/A17才加上光追单元).\n运行流程 # 读取参数 解析描述文件 创建场景 integrator渲染循环 一气呵成的结构, 这里把renderer类称作integrator是因为渲染的核心流程就是求解渲染方程这一积分式, 这个名字还是比较贴切的.\n场景中的物体通过Primitive存储, 其中包含Material与Shape, 整个场景都包含在aggregate这一Primitive的实现中. 除aggregate之外场景只会存储lights, pbrt将平行光这类无限距离的光源单独存储, 只考虑这些光源可以更高效的渲染出可以接受的结果. 部分光源需要获取场景的包围盒, 因此pbrt给光源添加了preprocess接口.\nIntegrator接口需要实现Render与Intersect函数. Intersect有一种特殊实现叫做IntersectP, 只考虑是否相交而非具体的相交信息, 通常用于阴影. 作者说这种命名方式来自于Lisp, 其实国庆本来想学SICP的, 可惜时间就这么点.\nImageTileIntegrator # ImageTileIntegrator实现了Integrator, 支持将渲染图像划分为tile来实现并行渲染, 该类的构造函数需要额外的Camera与Sampler, 最终渲染结果存储在Camera中的Film成员. ImageTileIntegrator渲染时会分为多次wave, 每次wave的sample数逐步增加, 以此来实现渲染图像的预览.\n由于需要分配大量小内存来存储光线求解过程中的表面散射信息, pbrt通过自定义的ScratchBuffer来提高效率. 该类通过address offset的递增来快速分配相同大小的内存, 但是释放时只能通过将offset设置为0来释放当前所有分配的小内存, 也因此每个thread都需要创建ScratchBuffer, pbrt通过ThreadLocal模板类来实现.\n虚函数EvaluatePixelSample负责调用Sampler生成采样点供Integrator发射光线. 由于需要存储像素位置等状态, Sampler也通过ThreadLocal来定义. 在每个采样点渲染完成后, 会调用ScratchBuffer::Reset()来统一释放光追过程中分配的内存.\nRayIntegrator # RayIntegrator继承自ImageTileIntegrator(继承链开始变长了, 有种不好的预感), 在划分tile的基础上通过实现EvaluatePixelSample提供光线路径相关的功能.\n不同于传统的RGB渲染, RayIntegrator会在有效光谱范围中均匀采样, 每个sample都具有不同的波长, 默认是4个sample. 按我的理解, RGB就是只有三个固定波长的特殊形式的光谱渲染, 这里是更一般化的形式. RGB是可以三种波长一次计算的, 通用光谱渲染应该是要各个波长单独走光追流程了, 开销更大.\nCamera接口负责实现GenerateRay与GenerateRayDifferential, GenerateRay负责生成光线, GenerateRayDifferential负责生成相邻像素的光线信息以支持抗锯齿. CameraSample用于存储采样点在Film的位置. 它还会包含用于非小孔成像的镜头位置以及样本权重, 主要用于实现非pinhole的camera. 这一章给出的示例图是有景深效果的, pbrt应该实现了透镜镜头.\nRayIntegrator声明了Li这一虚函数用于实现具体的光照过程, 返回值为SampledSpectrum, 即样本的光谱信息. 该函数的参数包含VisibleSurface指针, 对于需要存储物体表面几何信息的Film这会返回它所需要的信息.\nRandomWalkIntegrator # 上面的都是虚类, 这里终于到具体实现了, 继承吼可怕.\nRandomWalkIntegrator主要实现了Monte Carlo方法, 通过物体的自发光与用BSDF得到的反射光线返回的结果得到渲染样本. 这里没有考虑直接光源, 自然会缺少有阴影与高光项, 光线也几乎不会与场景里的光源相交. 按照作者的说法, 那张满是噪点的示例图是每个像素4096个样本的结果, 这里也可以窥见AI降噪缘何如此火热.\n代码使用 # 命名 # 类名采用大写开头camel case, 变量采用小写开头.\n指针 or 引用 # 可变的或者可以传入空值的用指针, 否则const引用.\n标准库 # pbrt尽量使用标准库来降低代码复杂度, 部分标准库的重新实现会放在pstd namespace下.\n内存分配 # pbrt使用std::pmr::polymorphic_allocator来分配对象, 这是c++17提供的内存管理器接口, 用于实现多态的内存管理器. 相比于new\u0026amp;delete, 通过函数调用显示分配内存方便pbrt收集内存分配情况并提高小对象分配效率, 同时也便于分配GPU可见的内存.\n动态分派 # pbrt不使用虚表来实现多态, 而是通过TaggedPointer来存储函数与类型信息, 主要是为了减少复杂场景下大量虚表指针带来的性能开销以及实现GPU代码的多态.\n代码优化 # 这里主要提到了pbrt会优化访存速度, 并未设计具体实现.\n调试 \u0026amp; 错误处理 # pbrt中包含大量单元测试来保证代码的正确性, 运行时通过assertion来报错. pbrt会报告具体哪个像素与样本发生错误, 并支持只重新执行这个样本来查找错误. pbrt中的类提供了toString类来实现类似于运行时反射的功能.\n多线程 # pbrt为了保证效率, 绝大部分数据结构都是非线程安全的, 基本也都是每个线程单独创建自己需要的或者是只读的.\n绝大部分工具类是线程安全的, 例如Camera、 BxDF. Light::Preprocess是非线程安全的, 因为场景的构建过程为单线程. Sampler是非线程安全的, 这是考虑到光线采样过程中的性能开销, 因此每个线程都会创建Sampler.\n所有全局函数都是线程安全的.\n可扩展性 # 教学用的软件可扩展性肯定要保证的, 后面我应该也会尝试实现新的渲染方法.\nBugs # (去pbrt.org提issue吧)\nPBR历史 # 这里我就不总结了, 按我自己的经历来说, 首次接触是在RTR4, 现在在实时渲染上GGX+Smith应该是绝对主流了.\n结语 # 这一章主要介绍pbrt的代码结构, 这对于后续的阅读与代码练习是很有意义的. 至于为什么要着重强调这次加入了GPU光追, 答案很显然: 2/3的作者是nVidia的. 后续章节这两天应该就会更新.\n","date":"2024 October 1","externalUrl":null,"permalink":"/render/1727763944120-pbrt-v4-episode-1/","section":"Rendering","summary":"","title":"pbrt-v4 Ep. I: 代码实现","type":"render"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/cross-compilation/","section":"Tags","summary":"","title":"Cross-Compilation","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/darwin/","section":"Tags","summary":"","title":"Darwin","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/macos/","section":"Tags","summary":"","title":"Macos","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/nix/","section":"Tags","summary":"","title":"Nix","type":"tags"},{"content":"","date":"2024 September 14","externalUrl":null,"permalink":"/tags/nix-darwin/","section":"Tags","summary":"","title":"Nix-Darwin","type":"tags"},{"content":"Nix这边对交叉编译的支持是很不错的, 但它是用来通过stdenv编译nixpkgs中的某个包的. 浙软的高级操作系统Lab需要直接使用交叉编译器, 那么只能通过在环境中导入stdenv.cc来实现, 这一步是有坑的. Homebrew可以一键安装, 但我又无法抛弃通过nix develop来实现便捷的环境配置, 因此相关的解决方案今天记录在这里.\n系统配置 # Nix本身具有良好的交叉编译环境支持, 对于已经记录在lib.systems.examples中的系统, 可以通过pkgs.pkgsCross.[cross-env]直接导入. lib.systems.examples的部分定义如下:\n# ... { # ... aarch64-embedded = { config = \u0026#34;aarch64-none-elf\u0026#34;; libc = \u0026#34;newlib\u0026#34;; rustc.config = \u0026#34;aarch64-unknown-none\u0026#34;; }; # ... gnu64 = { config = \u0026#34;x86_64-unknown-linux-gnu\u0026#34;; }; gnu64_simplekernel = gnu64 // platforms.pc_simplekernel; # see test/cross/default.nix gnu32 = { config = \u0026#34;i686-unknown-linux-gnu\u0026#34;; }; # ... } 这里最核心的部分就是config里这个字符串, 如果没有指定libc等别的要求, 通常可以用这个字符串替代attribute set, 例如:\n# the following are the same system = \u0026#34;aarch64-darwin\u0026#34;; system = { config = \u0026#34;aarch64-darwin\u0026#34;; }; 系统字符串具有特定的格式:\narch-vendor-kernel-abi 该字符串可以包含其中的任意部分, 例如aarch64-darwin就只包含arch-kernel. nixpkgs会利用lib.systems.elaborate来补充省略的部分, 并扩展为一个attribute set来提供更多功能. 例如aarch64-darwin会被扩展为如下形式, 这里截取部分属性作为例子:\n{ # ... config = \u0026#34;aarch64-apple-darwin\u0026#34;; darwinArch = \u0026#34;arm64\u0026#34;; darwinMinVersion = \u0026#34;11.0\u0026#34;; darwinMinVersionVariable = \u0026#34;MACOSX_DEPLOYMENT_TARGET\u0026#34;; darwinPlatform = \u0026#34;macos\u0026#34;; darwinSdkVersion = \u0026#34;11.0\u0026#34;; # ... gcc = { ... }; hasSharedLibraries = true; is32bit = false; is64bit = true; isAarch = true; isAarch32 = false; isAarch64 = true; # ... isBigEndian = false; isCompatible = «lambda @ /Users/tsssni/nixpkgs/lib/systems/default.nix:82:22»; isDarwin = true; # ... isMacOS = true; isMacho = true; # ... libc = \u0026#34;libSystem\u0026#34;; linker = \u0026#34;cctools\u0026#34;; # ... system = \u0026#34;aarch64-darwin\u0026#34;; ubootArch = \u0026#34;arm64\u0026#34;; uname = { ... }; useAndroidPrebuilt = false; useLLVM = false; useiOSPrebuilt = false; } 可以看到系统信息得到了充分的补全, 给用户提供了足够的系统信息, 例如通过(if localSystem.isDarwin)即可判断当前交叉编译环境下的本地系统是否为Darwin.\n自定义系统 # 并非所有交叉编译环境都会在pkgsCross中提供, pkgsCross中的命名方式可能也不符合用户的要求. 例如Homebrew中提供的aarch64-embedded环境的前缀为aarch64-elf, Nix中为aarch64-none-elf. 两者编译出的二进制文件并无区别, 且都是符合gcc交叉编译器的传统命名方式的, 但是部分代码中可能直接指定编译器前缀, 例如我的OS Lab中使用的Unikraft的make文件中有如下定义:\n# set cross compile ifeq ($(call qstrip,$(CONFIG_CROSS_COMPILE)),) ifeq ($(HOSTOSENV),Darwin) CONFIG_CROSS_COMPILE := aarch64-elf- else ifneq ($(CONFIG_UK_ARCH),$(HOSTARCH)) CONFIG_CROSS_COMPILE := aarch64-linux-gnu- endif endif endif 显然它默认我们使用Homebrew(Nix-Darwin确实挺难用的\u0026hellip;), 可以参考Unikraft官方的Homebrew Tap. 此时我们可以自定义系统设置来解决该问题, 例如在我的NUR仓库参照aarch64-embedded定义了如下系统:\n{ aarch64-elf = { config = \u0026#34;aarch64-elf\u0026#34;; libc = \u0026#34;newlib\u0026#34;; rustc.config = \u0026#34;aarch64-unknown-none\u0026#34;; }; } 这会导致Nix编译出的cc-wrapper前缀的变化, 只有在交叉编译环境中才会使用带前缀的cc. 经过我的测试, aarch64-embedded并未存储于nixos cache中, 和aarch64-elf一样需要本地编译, 因此使用体验是相同的. 交叉编译器前缀与系统配置字符串是相同的, 影响交叉编译器前缀的代码如下:\n# pkgs/build-support/cc-wrapper/default.nix # ... let targetPrefix = optionalString (targetPlatform != hostPlatform) (targetPlatform.config + \u0026#34;-\u0026#34;); in: # ... 交叉编译stdenv # 想要在配置中导入自定义交叉编译系统对应的nixpkgs环境, 重新import nixpkgs即可. 例如我这里只需要在develop环境中使用交叉编译器, 可以这样编写mkShell:\nlet aarch64-elf-pkgs = import nixpkgs { localSystem = system; crossSystem = tsssni-lib.systems.aarch64-elf; }; in pkgs.mkShell { packages = [ aarch64-elf-pkgs.stdenv.cc ]; }; 然而此时编译出的aarch64-elf-gcc会报-iframework unknown option错误, 这是darwin平台特有的选项, 对于交叉编译器该选项是不支持的, 显然这是因为cc-wrapper在darwin平台上自动导入这个flag了. 开始我以为这是nixpkgs的bug, 但从cc-wrapper的setup-hook.sh可以看出, 这个flag是只在targetSystem.isDarwin时才会引入.\n归根结底, 这还是由于在一个环境中引入了不同的系统配置导致的. 除了aarch64-elf-gcc之外我还安装了其他darwin-native的包, 因此nix develop会导入darwin-native环境中cc-wrapper的setup-hooks. cc-wrapper是依赖setup-hooks中设置的NIX_CFLAGS_COMPILEF来引入flag的, darwin-native-gcc需要的flags也会被aarch64-elf-gcc使用, 从而导致报错.\n由于这些-isystem和-iframework对于我的OS LAB来说是无关紧要的, 此时在mkShell时可以参照simavr的setup-hook来把-iframework过滤掉, simavr中-isystem也是被过滤掉的, 这里我也一并过滤:\npkgs.mkShell { # ... shellHook = \u0026#39;\u0026#39; # Because it’s getting called from a Darwin stdenv, aarch64-elf-cc will pick up on # Darwin-specific flags, and it will barf and die on -iframework in # particular. Strip them out, so simavr can compile its test firmware. cflagsFilter=\u0026#39;s|-F[^ ]*||g;s|-iframework [^ ]*||g;s|-isystem [^ ]*||g;s| *| |g\u0026#39; # The `CoreFoundation` reference is added by `linkSystemCoreFoundationFramework` in the # Apple SDK’s setup hook. Remove that because aarch64-elf-cc will fail due to file not found. ldFlagsFilter=\u0026#39;s|/nix/store/[^-]*-apple-framework-CoreFoundation[^ ]*||g\u0026#39; # Make sure the global flags aren’t accidentally influencing the platform-specific flags. export NIX_CFLAGS_COMPILE=\u0026#34;$(sed \u0026#34;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_CFLAGS_COMPILE\u0026#34;)\u0026#34; export NIX_LDFLAGS=\u0026#34;$(sed \u0026#34;$ldFlagsFilter;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_LDFLAGS\u0026#34;)\u0026#34; exec zsh \u0026#39;\u0026#39;; } Flake # 此时交叉编译器就可以正常使用了, 完整的flake如下:\n{ description = \u0026#34;OSLAB devenv\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixpkgs-24.05-darwin\u0026#34;; tsssni-nur = { url = \u0026#34;github:tsssni/NUR\u0026#34;; inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; }; }; outputs = { nixpkgs, tsssni-nur, ... }: let system = \u0026#34;aarch64-darwin\u0026#34;; in { devShells.\u0026#34;${system}\u0026#34;.default = let pkgs = import nixpkgs { inherit system; }; tsssni-lib = tsssni-nur.lib; tsssni-pkgs = tsssni-nur.pkgs { localSystem = system; }; aarch64-elf-pkgs = import nixpkgs { localSystem = system; crossSystem = tsssni-lib.systems.aarch64-elf; }; in pkgs.mkShell { packages = [] ++ (with pkgs; [ clang lldb qemu coreutils-prefixed cmake ]) ++ (with tsssni-pkgs.gnu; [ ggrep gmake gsed ]) ++ (with aarch64-elf-pkgs; [ stdenv.cc ]); shellHook = \u0026#39;\u0026#39; # Because it’s getting called from a Darwin stdenv, aarch64-elf-cc will pick up on # Darwin-specific flags, and it will barf and die on -iframework in # particular. Strip them out, so simavr can compile its test firmware. cflagsFilter=\u0026#39;s|-F[^ ]*||g;s|-iframework [^ ]*||g;s|-isystem [^ ]*||g;s| *| |g\u0026#39; # The `CoreFoundation` reference is added by `linkSystemCoreFoundationFramework` in the # Apple SDK’s setup hook. Remove that because aarch64-elf-cc will fail due to file not found. ldFlagsFilter=\u0026#39;s|/nix/store/[^-]*-apple-framework-CoreFoundation[^ ]*||g\u0026#39; # Make sure the global flags aren’t accidentally influencing the platform-specific flags. export NIX_CFLAGS_COMPILE=\u0026#34;$(sed \u0026#34;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_CFLAGS_COMPILE\u0026#34;)\u0026#34; export NIX_LDFLAGS=\u0026#34;$(sed \u0026#34;$ldFlagsFilter;$cflagsFilter\u0026#34; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$NIX_LDFLAGS\u0026#34;)\u0026#34; exec zsh \u0026#39;\u0026#39;; }; }; } ","date":"2024 September 14","externalUrl":null,"permalink":"/unix/1726280965789-nix-darwin-cross-compiler/","section":"Unix","summary":"","title":"在Nix-Darwin中使用交叉编译器","type":"unix"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/tags/university/","section":"Tags","summary":"","title":"University","type":"tags"},{"content":"","date":"2024 June 29","externalUrl":null,"permalink":"/tags/youth/","section":"Tags","summary":"","title":"Youth","type":"tags"},{"content":"提笔时才发现闲时记录的照片已经不在现在的手机上了, 所幸仍未遗失. 全套的电子设备经过了一轮换代, 我过去四年的生活却宛如一张白纸, 亦不知我是否从未改变.\n在长春迎接我的第一场雪就伴随着一场冻雨, 漫天飞雪带来晶莹剔透, 太阳光在琉璃世界中折射出五彩的光芒. 这梦幻的场景或许这一生都不会在重复了, 因为疫情以及我自己性格上的原因我几乎从未出过校门, 但我想这样的景色无法通过刻意追寻求得. 这是我前1/4的人生里最美的一刻, 尽管它有着扑在脸上如烈火焚烧的寒风.\n凭着最初半年的努力顺利进入了唐班, 提前预订保研资格, 随之而来的却是迷惘. 离散数学出分的那个下午, 窗外大雨滂沱, 看着不到3的绩点愣在屏幕前不知所措; 得知操作系统课设没有满绩的那个夜晚, 在V3里麻木的操纵着普鲁士的市场, 乃至萌生了放弃保研的想法. 没有参加竞赛, 尝试参与科研也都是浅尝辄止, 我得过且过的度过自己的学术生涯. 不过窝在寝室里摆烂的日子我也看到了高纬度的冬季天空, 这夕阳刚刚落下时的蓝调色彩总是会给焦虑的我带来一点宽慰.\n如开头所言我的本科四年犹如白纸, 白的就像口罩与防护服. 2022年3月13日, 星期日, 睁开眼就得知封寝的消息. 除了寝室之外禁止踏足任何地点, 几步之遥的厕所也必须戴上口罩, 没有独卫使得整整一个月不能够洗澡. 前半段的餐食免费供应, 后半段需要每天自己预订, 口味重复寡淡且没有一份多余, 忘记订饭的那天靠着两包榨菜度过一整天, 晚上躺在床上肚痛难忍. 大白每天上门核酸, 麻木的开门捅嗓子, 在麻木的回到床上过着看不到头的日子. 2022年5月8日, 早上六点就来到人满为患的机场, 排到九点队伍都没有前进1/10, 靠着工作人员开放的加急通道成功回到家乡, 逃离这地狱一样的景象. 经历了如此严厉的封控, 疫情却不见好转, 下学期回来后对核酸的要求更是变本加厉. 我不想苛责任何人, 包括到现在都被调侃的许婧文同学, 大家都是照章办事. 不像上海封城, 这件事情早已被遗忘, 尽管它们的烈度不相上下. 希望我所说的这些未来不会再发生, 希望世界和平.\n闲暇之余沉迷3D势的VUP A-SOUL, 尤其是珈乐Carol, 她510毕业风波之后第一次有失恋的感觉, 后续的撕皮直播也断断续续看了一年. 当然, 也是因此机缘巧合了解了计算机图形学这一领域. 靠着Introduction to 3D Game Programming with DirectX® 12以及Real-Time Rendering 4th Edition 两本书不断迭代自己的carol-engine, 现在想来这是本科生活里唯一能影响我未来人生的经历. 靠着这股热爱联系了浙大CAD\u0026amp;CG实验室的老师, 进入了对于985学校来说相对容易的浙大软院, 现在在图形相关的岗位上实习, 也算对的起每天打开Visual Studio 2022坐着写一整天C++和HLSL的自己了.\n我的保研之路并没有多坎坷, 很早就选好导师并且开始给老板干活, 从一开始就想好要all in浙软. 不过真的到了夏令营和预推免还是会很紧张, 毕竟政策随时在变化. 当时夏令营的内容是两周复现NeRF并优化, 有一点CG与DL基础的我并没有遇到很多困难, 了解了NeRF的体渲染实现方式后比较顺利的完成了Instant-NGP的复现, 并与Mip-NeRF 360的distortion loss结合以实现unbound场景的降噪. 做项目的时候顺手用python给NeRF写了一个实时渲染器, 不过性能不怎么样, 也没空再优化了. 浙软夏令营的优营只会给一个预推免的入场券, 后面真的快要预推免的时候整个人焦虑的不行, 每天疯狂的复习408, 刷PAT题库, 好在机试的成绩比我预想的高很多, 面试主要问了计网, 数据库以及carol-engine的项目, 回答的很流利, 最后推免排名十分靠前. 说真的高考远没有保研结束的那一刻舒畅, 大概是因为保研时对于结束后的生活有了明确的规划: 学习NeoVim, 双十一组一台光追性能强劲的电脑, 通关往日之影. 最后这些规划也都一一实现, 活着还是很幸福的.\n说是实习, 其实是在导师公司, 相当于提前给老板打工了. 这里最神奇的是开发系统是Arch Linux, 尽管大二大三有着使用Ubuntu与Deepin的基础, 但把Linux作为工作环境还是第一次. 接触Arch就很难不被它高度自定义化的特性所感染, 双十一装机后我也在自己的电脑上安装了Arch, 更进一步的我开始自定义桌面环境, 用Hyprland, ElKowars wacky widges, rofi与dunst搭起一套桌面环境, 成为一名Unix Ricer, 现在这套配置已经迁移到了NixOS上. Rice确实给人一种光阴虚度的感觉, 但我作为一位程序员, 去接触不同的开源软件并了解它们的设计, 尝试掌控自己的电脑, 这是很有意义的.\n中学时家里配置最高的电脑是拥有GT 630M的笔记本, 到了2016年甚至魔兽世界7.0最低画质也只有个位数帧数了. 我在初一的寒假拥有了PS4, 我的第一台游戏主机, 也正因此我更偏爱主机游戏. 上了大学后的我拥有了游戏自由, 我在八十稻羽驱散天之狭雾, 在辰巳人工岛静静倾听神木秋成的粉色鳄鱼, 在初始之火的火炉继承乌薪王的传火遗志, 在黑雾之塔的底部与烟之骑士雷姆鏖战四天四夜, 在1992年的洛圣都的K-DST电台里听着Young Turks, 在黑门34年重回艾泽拉斯\u0026hellip; 我在大学里完成了游戏生涯补完计划, 以至于有些电子ED. 最近对JRPG颇有兴趣, 618靠着工资买了一台Steam Deck, 希望未来三年能完成JRPG的补完.\n多年以后,\n面对倒下的烟之骑士,\n他会回想起在天空的渔村\n第一次遇见科斯孤儿的\n那个遥远的下午.\n文学作品的阅读量远不如高中了, 毕竟无需再为作文而刻意去搜罗素材, 仔细想来其实只读了英语课上了解到的乔伊斯的都柏林人这一本短篇集, 捧着实体书读着都柏林众生的故事会给我一种莫名的温馨感. 之后也试着去读乔伊斯的尤利西斯, 很遗憾没有对意识流的品鉴能力, 几页过后就草草收场. 文学造诣一天天倒退, 对ACGN作品的兴趣却一天天的浓郁, 尤其是大四开始实习之后, 架不住公司里浓郁的二次元氛围被成功传染. 不过本科期间最令我动容的作品是2022年10月的赛博朋克: 边缘行者, 作为游戏预购玩家的我对2077的剧情并没有多感冒, I really want to stay at you house也只是体温电台里纪念威尔斯的一首歌, 但扳机社在边缘行者里悲剧般的描写让我在之后的两个星期里不断循环着它, 犹如一个赛博精神病, 为大卫与露西的爱情而感伤. 之后再去玩往日之影时竟被追求自由的百灵鸟所打动, 是CDPR的剧本进步了, 还是我的脑子变了呢? 二次元很煞笔, 我也是.\n子弹杯里伏特加加冰,\n兑小可可乐.\n生得伟大,\n死的光荣.\n写到这里也该有个结尾了, 本以为会是对废物一样的自己的嘲讽, 总结下来却发现并没有太多的失魂落魄. 祝愿我的未来三年一帆风顺, 祝愿我的人生前程似锦.\n","date":"2024 June 29","externalUrl":null,"permalink":"/acgn/1719632945386-changchun-memory/","section":"ACGN","summary":"","title":"长春回忆录","type":"acgn"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/lua/","section":"Tags","summary":"","title":"Lua","type":"tags"},{"content":"配置仓库见nix-config, fork自SketchyBar作者的配置, 由home-manager管理, 当前效果如下.\nRice一词来自于Race Inspired Cosmetic Enhancements, 即通过改装提高廉价赛车的性能(我看到的说法是日本赛车为主), 在程序员这里Rice被引申为对系统外观的美化, 以Unix系系统为主, 很多人会将自己的Rice分享到Reddit上的unixporn社区.\n原本计划端午节学习Yabai与SketchyBar的配置文件并将整体配色由Sonokai修改为我的 NixOS配置中的自定义配色方案, 然而不论是使用体验还是视觉观感这三个月来当前的桌面配置对我而言都是一个完美的状态, 所以今天只记录一下配置方式以及Nix配置中踩过的坑. 当然, 记录和感想为主, 并不是教程与技术分析.\nYabai # 毕竟不是Linux, Yabai的功能依赖于MacOS使用的Aqua WM, 在闭源代码上做一层套娃效果自然是无法与Linux上的Hyprland、Sway等开源WM相比的, 而Apple对兼容性的忽视也是名声在外, 每次系统更新Yabai都会伴随着部分功能的失效.\n也正是如此我对Yabai的作者koekeishiya是很钦佩的, 根据github的数据可以说他是以一己之力推进着Yabai的维护. 在写这篇文章时我一直都在为假期的流逝而焦虑, 来自峡湾之国的他会不会为此烦恼呢?\n晚上熬大夜看完了WWDC 2024, 大部分时间都在Apple Intelligence, 不过MacOS Sequoia部分提到了自动Window Tiling和快捷键, 对于第三方WM是利是弊还有待观察, 期待未来的MacOS实现原生的Yabai体验.\n写到这里才发现自己对MacOS上的WM知之甚少, 不妨在这里多探讨一些. 这个链接基本囊括了MacOS上的所有WM了, 这个reddit贴子里还提到了 Lasso和Raycast Window Management Extension. 最让我新奇的是里付费闭源WM占据了MacOS的半壁江山, 在我的印象(刻板印象?)里WM都是Geeker们折腾的开源玩具. 其实还挺想体验一下的, 可惜没钱, 估计我8+256的丐版Air也经不起这折腾.\n最终找到的比较流行的开源WM比我想象中要多不少, MacOS的开源生态实际上还是不错的. 有哪个程序员会不喜欢Unix呢, 在我买Mac时这是除了续航之外最重要的原因了. 简单浏览了一下各个项目的README和Wiki, 我这里大致梳理一下各自的特色.\nAmethyst是遵循xmonad标准的WM, 距今已经11年了. Amethyst是紫水晶, 而MacOS的图形层Quartz是水晶, 很有意思的名字. Yabai只支持BSP、Float与Stack布局, 而Amethyst Wiki中一共介绍了14种布局, 大部分都是固定一个主要窗口, 其余窗口按需排列与切换. Amethyst的布局使用js配置, 就在去年Amethyst支持了自定义布局, 可以用户自定义窗口状态变化以及扩展现有布局. Amethyst的所有功能都不需要关闭SIP, 但也因此功能上没有Yabai丰富, 例如透明度、移动工作区等功能都是缺失的.\nYabai是2019年的项目, 但是和Amethyst都是用Objective-C写出来的老东西, 与Yabai同时代的Rectangle已经用上Swift了. Rectangle基于已经archvie的Spectacle, 集成MAShortcut作为快捷键系统, 支持图形化快捷键配置. Rectangle只支持修改窗口的位置与大小, 并不会管理布局, 可以通过鼠标拖拽自动执行Window Tiling, 例如左右拖动让窗口占据半个屏幕, 朝上拖动让窗口最大化. 显然这没有Sequoia引入的Window Tiling智能, 后续可能会跟进官方的新API.\nRectang是自由软件, 但是Rectangle Pro是收费的, 支持管理布局、更丰富的快捷键、云端配置存储等功能. 私以为管理布局是WM最核心的功能, 这么定义的话Rectangle这个残血版可能都不能称之为WM了.\nLoop是2023年的新项目, 着重强调风格化的window resize, 从下面的官方示例中可以看出来对鼠标的支持非常丝滑. Loop仍然处于beta测试阶段, 只支持Ventura以上的版本. 随着使用时间增加Loop的图标会发生变化, 很酷炫的功能.\nAeroSpace同样诞生于2023, 但是要更传统一些, 主要目标是为用户带来类似于i3的窗口管理体验. AeroSpace不需要关闭SIP, 拥有自定义的虚拟工作区, 不依赖于Auqa的工作区系统. 但是从官方Demo来看动画支持是几乎没有的, 配置文件是我很不喜欢的toml格式(说起来Hugo也是toml为主, 但是也支持json, json赛高!), 没有给我什么眼前一亮的感觉.\n说回正题, 粗略浏览了Yabai的源代码, Yabai主要通过C/S结构的进程间通信实现WM配置, 即server进程监听socket, client向socket中写入message. 因此Yabai可以通过shell实现动态配置, Yabai的默认配置文件也只是shell script, 窗口外观配置以及移动窗口、创建工作区等操作都可以通过message来实现. Yabai message格式写在下面. Yabai Wiki中只介绍了一小部分配置, 需要阅读man page才能一览全貌, 我这里不会介绍具体配置选项, man page中有很详细的说明.\nyabai -m \u0026lt;message\u0026gt; \u0026lt;settings\u0026gt; 与其他WM不同, Yabai本身不包括快捷键系统. Yabai作者的另一个项目skhd提供了快捷键配置, 其他第三方软件也是可行的, 支持通过快捷键执行shell script即可. 在我的Hyprland配置中WM的快捷键以super作为基础键, 但MacOS中的大量快捷键已经占据了super(command), 而control和option被我的neovim配置占用, 无奈之下只好通过control + command / option + command来实现, 单手操作会很扭曲. skhd示例如下, 实现了切换工作区的功能:\n# Space Navigation lalt + lcmd - 1 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[1] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[1] lalt + lcmd - 2 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[2] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[2] lalt + lcmd - 3 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[3] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[3] lalt + lcmd - 4 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[4] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[4] lalt + lcmd - 5 : SPACES=($(yabai -m query --displays --display | jq \u0026#39;.spaces[]\u0026#39;)) \u0026amp;\u0026amp; [[ -n $SPACES[5] ]] \u0026amp;\u0026amp; yabai -m space --focus $SPACES[5] Linux WM中常见的border在Yabai中也是缺失的, 我使用的是JankyBorders, 只提供了颜色、宽度、边缘形状、黑白名单等最基础的功能, 比微信要小而美就是了. 我的配置放在下面.\n#!/bin/bash options=( style=round width=6.0 hidpi=off active_color=0xc0e2e2e3 inactive_color=0xc02c2e34 background_color=0x302c2e34 ) borders \u0026#34;${options[@]}\u0026#34; SketchyBar # 接触Unix Rice时往往最先考虑使用哪一个WM, MacOS上还好, Linux上没有WM的话可就得对着Terminal敲代码了, 当然如果会VIM、Emacs这类Editor的话体验也还可以. 但WM管理的仅仅只是窗口而已, 重点在快捷方便而不是美观, 私以为每时每刻都能见到的Status Bar才是Rice的核心部分. 各类开源Status Bar往往具有极高的可定制性, 不像chrome这类商业应用只提供有限的外观选项. 选好WM与壁纸, 写好Status Bar, 配置好terminal, 这就是一次完整的Rice.\nSketchyBar fork自spacebar, 启发自Yabai已经移除的内置Status Bar. 也正因如此SketchyBar的配置方式与Yabai是一脉相承的, 与Yabai配合的很好. SketchyBar官网上列出了很多示例Status Bar, 可以看出定制能力是非常强悍的. MacOS Ricer们真的很喜欢在Status Bar上放一个Apple Logo.\n当然SketchyBar仍然只提供Status Bar相关的功能, 和Linux上的EWW以及AGS等自定义Widget相比定制化能力还是差了一截的. 阅读Yabai文档时我才了解到MacOS上也有个叫Übersicht的自定义Widget, 支持使用CoffeeScript或JavaScript来编写配置, 底层是React. 挺后悔刚接触Rice时学的是EWW, EWW的配置语言是一门叫yuck的lisp方言, 不是很适合编写Widget. 但如果我是作者, 拥有一门自己的语言真的很酷, 还是一门函数式语言, 更酷了.\nSketchyBar官方文档比Yabai的要好很多, 各类配置都可以查到. SketchyBar将Status Bar分为Bar与Item两个部分, Bar是轮船, Item是集装箱, 各个Item具有独立的功能与样式(就像Docker的logo一样). 或者可以这样理解, Bar是一个特殊的Item, 可以自定义样式但是不能自定义功能, 只负责为其他Item提供绘制区域.\nSketchyBar通过注册事件与用户提供的shell script实现Item属性的自动化修改, 支持用户自定义事件. SketchyBar有内置的动画系统, 支持通过动画曲线修改任意通过颜色与整数定义的属性, 十分甚至九分的灵活.\n此外SketchyBar支持数据图、滑条等特殊组件, 支持额外的弹出菜单, 甚至支持将MacOS中各个应用的Menu Bar直接映射到SketchyBar上, 这是最令我印象深刻的功能, 让SketchyBar可以真正的融入到日常工作流中. 但是通过点击触发系统自带的弹出菜单的功能仍在开发中, 在作者自己的配置里通过一个小程序实现了这个功能.\nSketchyBar作者最近有个新项目叫SbarLua, 是SketchyBar的一个插件, 支持用Lua写配置. 这算是我与SketchyBar深入交流的一次契机, 给SbarLua打Nix包让我第一次从源码层面去了解一个开源项目并解决冲突.\n首先聊一下打包过程, 打包代码放在下面. 参数里有Lua包, 但是Nix似乎并不支持将手动指定的依赖暴露在$PATH中, Nix的依赖系统只是会自动修改动态库的路径. 这导致无法直接执行Lua命令, 我目前没有找到解决办法, 需要用户自己在Nix配置中手动安装Lua. 我这里指定的编译器是gcc而不是clang, 因为SbarLua编译过程中需要使用gcc指令. 在MacOS上gcc是被alias到clang的, 但是Nix的编译环境是与系统无关的, 不包含任何预设的环境变量的, 指定clang作为编译器会导致编译过程中找不到gcc. 当然, 就算我指定使用clang, Nix使用的也是nixpkgs中的clang而非系统中的clang, 通常来说版本会新很多.\n{ lib , stdenv , fetchFromGitHub , CoreFoundation , readline , gcc , lua }: stdenv.mkDerivation { pname = \u0026#34;sketchybar-lua\u0026#34;; version = \u0026#34;dev\u0026#34;; src = fetchFromGitHub { owner = \u0026#34;FelixKratz\u0026#34;; repo = \u0026#34;SbarLua\u0026#34;; rev = \u0026#34;29395b1\u0026#34;; sha256 = \u0026#34;sha256-C2tg1mypz/CdUmRJ4vloPckYfZrwHxc4v8hsEow4RZs=\u0026#34;; }; nativeBuildInputs = [ gcc ]; buildInputs = [ CoreFoundation readline ]; enableParallelBuilding = true; buildPhase = \u0026#39;\u0026#39; make bin/sketchybar.so \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; mkdir -p $out/share cp bin/sketchybar.so $out/share/sketchybar.so \u0026#39;\u0026#39;; meta = with lib; { description = \u0026#34;A Lua API for SketchyBar\u0026#34;; homepage = \u0026#34;https://github.com/FelixKratz/SbarLua\u0026#34;; license = licenses.gpl3; platforms = platforms.darwin; }; } SbarLua基本上是对原有配置方式的封装, 但SketchyBar为执行配置文件的进程添加了SIGALRM信号, 使得配置文件的执行时间不超过60s. 代码放在这里:\nstatic inline bool fork_exec(char *command, struct env_vars* env_vars) { int pid = vfork(); if (pid == -1) return false; if (pid != 0) return true; alarm(FORK_TIMEOUT); exit(sync_exec(command, env_vars)); } 对于原本的shell script这是没有问题的, 但是SbarLua是包括了事件监听功能的, 需要lua进程持续运行, 因此作者在SbarLua中取消了SIGALRM(代码中的alarm(0)):\nint event_loop(lua_State* state) { g_state = state; struct stack* stack = stack_create(); stack_init(stack); stack_push(stack, UPDATE); sketchybar_call_log_and_cleanup(stack); alarm(0); mach_server_begin(\u0026amp;g_mach_server, callback_function); CFRunLoopTimerRef orphan_timer = CFRunLoopTimerCreate(kCFAllocatorDefault, CFAbsoluteTimeGetCurrent() + 1.0, 1.0, 0, 0, orphan_check, NULL ); CFRunLoopAddTimer(CFRunLoopGetMain(), orphan_timer, kCFRunLoopDefaultMode); CFRelease(orphan_timer); CFRunLoopRun(); return 0; } 显然作者期望的是直接执行配置文件, 比如作者本人是通过shebang执行sketchybarrc的:\n#!/usr/bin/env lua -- Load the sketchybar-package and prepare the helper binaries require(\u0026#34;helpers\u0026#34;) require(\u0026#34;init\u0026#34;) 然而我们是Nix, 如果Home-Manager是这样写的, 那很抱歉, 它没有执行权限!\n{ ... }: { home.file.\u0026#34;.config/sketchybar/sketchybarrc\u0026#34;.source = .config/sketchybar/sketchybarrc; } 我们可以通过Nix编写配置文件并执行, 代码放在下面. 我这里封装了一层, 因为还需要手动设置SbarLua动态库的路径. 此外代码里还手动trap了SIGALRM信号, 因为SbarLua代码中只能取消父进程的SIGALRM信号, 经过封装后SbarLua现在是sketchybar的孙子进程, 若我没有在配置文件里trap SIGALRM, 60s后执行配置文件的进程就会被杀死, SbarLua位于的孙子进程自然也不再执行. 这个问题困扰了我很久, 它会导致sketchybar运行60s后卡住, 在源码中捕获子进程的信号才终于发现了真相. 这就是自由软件的意义吧.\n{ pkgs, ... }: { services = { # other services sketchybar = { enable = true; extraPackages = [ pkgs.lua5_4_compat pkgs.sketchybar-lua ]; config = \u0026#39;\u0026#39; trap \u0026#34;\u0026#34; SIGALRM export LUA_CPATH=\u0026#34;$LUA_CPATH;${pkgs.sketchybar-lua}/share/?.so\u0026#34; export CONFIG_DIR=$HOME/.config/sketchybar cd $CONFIG_DIR lua init.lua \u0026#39;\u0026#39;; }; # other services }; } End # 写了这么多, 突然萌生出学习Apple技术栈的想法, 或许会很有趣?\n","date":"2024 June 10","externalUrl":null,"permalink":"/unix/1718005170522-macos-rice/","section":"Unix","summary":"","title":"MacOS Rice杂记","type":"unix"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/rice/","section":"Tags","summary":"","title":"Rice","type":"tags"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/sketchybar/","section":"Tags","summary":"","title":"SketchyBar","type":"tags"},{"content":"","date":"2024 June 10","externalUrl":null,"permalink":"/tags/yabai/","section":"Tags","summary":"","title":"Yabai","type":"tags"},{"content":"","date":"2024 June 4","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"现在\u0026amp;未来从事图形学与游戏开发工作.\nNix/Nixvim/Niri/Astal工作中.\n喜欢JRPG!\n","date":"2024 June 4","externalUrl":null,"permalink":"/about/1717500731146-about/","section":"About","summary":"","title":"关于","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]